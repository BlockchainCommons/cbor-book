<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dCBOR Tags - The CBOR, dCBOR, and Gordian Envelope Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The CBOR, dCBOR, and Gordian Envelope Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dcbor-tags"><a class="header" href="#dcbor-tags">dCBOR Tags</a></h1>
<p>As discussed in <a href="../part_1/cbor_tags.html">Part I: CBOR Tags</a>, CBOR tags are an integer that "tags" the CBOR data item that follows, specifying its type or meaning. This is a powerful feature of CBOR.</p>
<p>Let's say we wanted to define a tag that identifies a string as holding an ISO 4217 currency code like <code>USD</code> or <code>EUR</code>. We could just use a bare string, but if we want our type to be completely self-describing, we can define a tag for it.</p>
<p>As long as you are the only one using that tag, you can choose any integer you want. But if you want your structure to interoperate with other systems, you should use a tag that is registered with IANA, discussed previously <a href="../part_1/cbor_tags.html#how-to-register-your-own-fcfs-tags">here</a>.</p>
<p>For our demonstration we'll use the tag <code>33000</code>, which as of this writing is unassigned by IANA.</p>
<p>So how would we tag a string as a currency type? Let's start by defining a constant for our tag:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span>
const TAG_CURRENCY_CODE: u64 = 33000;

<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>We now associate our string with the tag by using the <code>to_tagged_value()</code> method:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span>
let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");

<span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>We can extract the tag and the tagged value using <code>try_into_tagged_value()</code>. The return type is a tuple of a <code>Tag</code> and the tagged item:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span>
let (tag, item) = usd.clone().try_into_tagged_value()?;
assert_eq!(tag.value(), TAG_CURRENCY_CODE);
assert_eq!(item.try_into_text()?, "USD");

<span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>The reason you have to call <code>value()</code> on the returned <code>Tag</code> to get back the numeric value is that a <code>Tag</code> may also include a human-readable name you can define for your tag. We'll discuss naming tags more later in this chapter.</p>
<blockquote>
<p>✅ <strong>NOTE:</strong> A <em>tagged value</em> is the combination of a tag and the value (data item) it tags. But the <em>value of the tag</em> is the integer that identifies the tag.</p>
</blockquote>
<p>If we print the diagnostic notation of our tagged value, we can see the tag in the output:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span>
let diagnostic = usd.diagnostic();
let expected_diagnostic = r#"

33000("USD")

"#.trim();

assert_eq!(diagnostic, expected_diagnostic);

<span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>As shown above, we can always extract the <code>(Tag, CBOR)</code> tuple from a tagged value, and then compare the tag value to our constant to see whether we want to process it further. But it's a common pattern to expect to find a specific tag in a particular place in a CBOR structure. So <code>dcbor</code> provides a convenience method <code>try_into_expected_tagged_value()</code> to test the tag value and return an error if it doesn't match. If it succeeds, it returns the tagged value for further processing.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span>
let item = usd
    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
    .try_into_text()?;
assert_eq!(item, "USD");

<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<h2 id="tagging-a-complex-structure"><a class="header" href="#tagging-a-complex-structure">Tagging a Complex Structure</a></h2>
<p>Let's say we want to combine our tagged currency code with an amount. Currency amounts can be tricky, because they are expressed as having decimal fractions, but many common floating point values, like <code>1.1</code> cannot be represented exactly in binary floating point, meaning that even highly-precise types like <code>f64</code> can't represent common currency values accurately.</p>
<p>So let's define a new type called <code>DecimalFraction</code> that holds an integer mantissa and a signed exponent. The exponent is the number of decimal places, so <code>1.1</code> would be represented as a mantissa of <code>11</code> with an exponent of <code>-1</code>, and <code>1.01</code> would be represented as a mantissa of <code>101</code> with an exponent of <code>-2</code>:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span>pub struct DecimalFraction {
    pub exponent: i8,
    pub mantissa: i64,
}
<span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>✅ <strong>NOTE:</strong> We're not showing a lot of the typical boilerplate code here, like the <code>impl</code>s for <code>Debug</code>, <code>Clone</code>, <code>Display</code>, and things like <code>new()</code> methods. You can find the complete code in the repo for this book.</p>
</blockquote>
<p>It turns out that <a href="https://www.rfc-editor.org/rfc/rfc8949.html#name-decimal-fractions-and-bigfl">RFC8949 §3.4.4</a> already defines a CBOR structure for decimal fractions, so we can use that: it's just a two-element array with the exponent first and the mantissa second. It also reserves the tag <code>4</code> for decimal fractions, so we can use that as our tag.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>
const TAG_DECIMAL_FRACTION: u64 = 4;

impl From&lt;DecimalFraction&gt; for CBOR {
    fn from(value: DecimalFraction) -&gt; Self {
        // Compose the two-element array
        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();

        // Return the tagged array
        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
    }
}

<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>So now we can create a <code>DecimalFraction</code> and convert it to CBOR, showing the diagnostic notation:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span>
let a = DecimalFraction::new(-1, 11);
let cbor: CBOR = a.into();
assert_eq!(cbor.diagnostic(), r#"

4(
    [-1, 11]
)

"#.trim());

<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>Because conversion from CBOR to a given type can fail, we implement the <code>TryFrom&lt;CBOR&gt;</code> trait for our <code>DecimalFraction</code> type:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span>
impl TryFrom&lt;CBOR&gt; for DecimalFraction {
    type Error = dcbor::Error;

    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
        // Decode the tagged array
        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;

        // Convert the item to an array
        let arr = item.try_into_array()?;

        // Validate the length of the array
        if arr.len() != 2 {
            return Err("Expected a two-element array".into());
        }

        // Extract the exponent and mantissa
        let exponent: i8 = arr[0].clone().try_into()?;
        let mantissa: i64 = arr[1].clone().try_into()?;

        // Return the DecimalFraction
        Ok(DecimalFraction::new(exponent, mantissa))
    }
}

<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>Now we can round-trip our tagged value, converting it to CBOR and back to a <code>DecimalFraction</code>:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span>
// Create a DecimalFraction
let a = DecimalFraction::new(11, -1);

// Convert to CBOR
let cbor: CBOR = a.clone().into();

// Convert back to DecimalFraction
let b: DecimalFraction = cbor.try_into()?;

// Check that the original and round-tripped values are equal
assert_eq!(a, b);

<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<h2 id="implementing-a-tagged-string"><a class="header" href="#implementing-a-tagged-string">Implementing a Tagged String</a></h2>
<p>We used a tagged string for our currency code, but we can also define a <code>CurrencyCode</code> type using the <em>newtype</em> pattern. This is a common Rust idiom for creating a new type that wraps an existing type, like <code>String</code>, and provides additional functionality. In this case, the additional functionality is to implement <code>From&lt;CurrencyCode&gt; for CBOR</code> and <code>TryFrom&lt;CBOR&gt; for CurrencyCode</code>.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span>
pub struct CurrencyCode(String);

impl CurrencyCode {
    pub fn new(code: &amp;str) -&gt; Self {
        Self(code.into())
    }

    pub fn code(&amp;self) -&gt; &amp;str {
        &amp;self.0
    }
}

impl From&lt;CurrencyCode&gt; for CBOR {
    fn from(value: CurrencyCode) -&gt; Self {
        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
    }
}

impl TryFrom&lt;CBOR&gt; for CurrencyCode {
    type Error = dcbor::Error;

    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
        let currency_code: String = value.try_into()?;
        Ok(CurrencyCode(currency_code))
    }
}

<span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>Now we can round-trip our <code>CurrencyCode</code> the same way we did with <code>DecimalFraction</code>:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span>
let usd = CurrencyCode::new("USD");
let cbor: CBOR = usd.clone().into();
let usd2: CurrencyCode = cbor.try_into()?;
assert_eq!(usd, usd2);

<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<h2 id="combining-the-two-types"><a class="header" href="#combining-the-two-types">Combining the Two Types</a></h2>
<p>Originally we set out to create a structure that combined a currency code with a decimal fraction: <code>CurrencyAmount</code>. We'd also like this structure to have it's own tag, so we'll use <code>33001</code>, which is also unassigned by IANA as of this writing.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>
const TAG_CURRENCY_AMOUNT: u64 = 33001;

<span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyAmount(CurrencyCode, DecimalFraction);
</span><span class="boring">
</span><span class="boring">impl CurrencyAmount {
</span><span class="boring">    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
</span><span class="boring">        Self(currency, amount)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
</span><span class="boring">        &amp;self.1
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyAmount&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyAmount) -&gt; Self {
</span><span class="boring">        let v: CBOR = vec![
</span><span class="boring">            value.currency().to_cbor(),
</span><span class="boring">            value.amount().to_cbor()
</span><span class="boring">        ].into();
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let currency: CurrencyCode = arr[0].clone().try_into()?;
</span><span class="boring">        let amount: DecimalFraction = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        Ok(CurrencyAmount(currency, amount))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>Now that we have completely reusable constituents, we can define <code>CurrencyAmount</code> as a type that consists of a <code>CurrencyCode</code> and a <code>DecimalFraction</code>.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::fmt;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_CODE: u64 = 33000;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_DECIMAL_FRACTION: u64 = 4;
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v: CBOR = vec![value.exponent as i64, value.mantissa].into();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor: CBOR = a.into();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(11, -1);
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor: CBOR = a.clone().into();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span><span class="boring">
</span><span class="boring">pub struct CurrencyCode(String);
</span><span class="boring">
</span><span class="boring">impl CurrencyCode {
</span><span class="boring">    pub fn new(code: &amp;str) -&gt; Self {
</span><span class="boring">        Self(code.into())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn code(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;CurrencyCode&gt; for CBOR {
</span><span class="boring">    fn from(value: CurrencyCode) -&gt; Self {
</span><span class="boring">        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for CurrencyCode {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
</span><span class="boring">        let currency_code: String = value.try_into()?;
</span><span class="boring">        Ok(CurrencyCode(currency_code))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for CurrencyCode {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "{}", self.0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor: CBOR = usd.clone().into();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">const TAG_CURRENCY_AMOUNT: u64 = 33001;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span>
pub struct CurrencyAmount(CurrencyCode, DecimalFraction);

impl CurrencyAmount {
    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
        Self(currency, amount)
    }

    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
        &amp;self.0
    }

    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
        &amp;self.1
    }
}

impl From&lt;CurrencyAmount&gt; for CBOR {
    fn from(value: CurrencyAmount) -&gt; Self {
        let v: CBOR = vec![
            value.currency().to_cbor(),
            value.amount().to_cbor()
        ].into();
        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
    }
}

impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
    type Error = dcbor::Error;

    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
        let arr = item.try_into_array()?;

        if arr.len() != 2 {
            return Err("Expected a two-element array".into());
        }

        let currency: CurrencyCode = arr[0].clone().try_into()?;
        let amount: DecimalFraction = arr[1].clone().try_into()?;

        Ok(CurrencyAmount(currency, amount))
    }
}

<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_1() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>Notice that in the above example, we're able to call the <code>to_cbor()</code> method on the <code>CurrencyCode</code> and <code>DecimalFraction</code> types, because the <code>dcbor</code> library includes a <em>blanket implementation</em> for another trait called <code>CBOREncodable</code>, which automatically applies to any type that implements <code>Into&lt;CBOR&gt;</code> and <code>Clone</code>. (We implemented <code>From&lt;CurrencyCode&gt; for CBOR</code> and <code>From&lt;DecimalFraction&gt; for CBOR</code> which also implicitly implement the <code>Into&lt;CBOR&gt;</code> trait, so we get the <code>CBOREncodable</code> trait for free.)</p>
<p>The <code>CBOREncodable</code> trait gives us the <code>to_cbor()</code> method, which can be called on a <code>&amp;self</code> (reference to self) unlike the <code>into()</code> method, which consumes the value. It also gives us the <code>to_cbor_data()</code> method, which returns the final, serialized CBOR data as a <code>Vec&lt;u8&gt;</code>.</p>
<blockquote>
<p>🚧 <strong>Work in Progress:</strong> <em>More in this chapter and more chapters forthcoming!</em></p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part_2/using_dcbor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part_3/introducing_gordian_envelope.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part_2/using_dcbor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part_3/introducing_gordian_envelope.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
