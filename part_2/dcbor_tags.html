<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dCBOR Tags - The CBOR, dCBOR, and Gordian Envelope Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The CBOR, dCBOR, and Gordian Envelope Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dcbor-tags"><a class="header" href="#dcbor-tags">dCBOR Tags</a></h1>
<p>As discussed in <a href="../part_1/cbor_tags.html">Part I: CBOR Tags</a>, CBOR tags are an integer that "tags" the CBOR data item that follows, specifying its type or meaning. This is a powerful feature of CBOR.</p>
<p>Let's say we wanted to define a tag that identifies a string as holding an ISO 4217 currency code like <code>USD</code> or <code>EUR</code>. We could just use a bare string, but if we want our type to be completely self-describing, we can define a tag for it.</p>
<p>As long as you are the only one using that tag, you can choose any integer you want. But if you want your structure to interoperate with other systems, you should use a tag that is registered with IANA, discussed previously <a href="../part_1/cbor_tags.html#how-to-register-your-own-fcfs-tags">here</a>.</p>
<p>For our demonstration we'll use the tag <code>33000</code>, which as of this writing is unassigned by IANA.</p>
<p>How would we tag a string as a currency type? Let's start by defining a constant for our tag:</p>
<pre><code class="language-rust">const TAG_CURRENCY_CODE: u64 = 33000;</code></pre>
<p>We now associate our string with the tag by using the <code>to_tagged_value()</code> method:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span>let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
<span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>We can extract the tag and the tagged value using <code>try_into_tagged_value()</code>. The return type is a tuple of a <code>Tag</code> and the tagged item:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span>let (tag, item) = usd.clone().try_into_tagged_value()?;
assert_eq!(tag.value(), TAG_CURRENCY_CODE);
assert_eq!(item.try_into_text()?, "USD");
<span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>The reason you have to call <code>value()</code> on the returned <code>Tag</code> to get back the numeric value is that a <code>Tag</code> may also include a human-readable name you can define for your tag. We'll discuss naming tags later in this chapter.</p>
<blockquote>
<p>✅ <strong>NOTE:</strong> A <em>tagged value</em> is the combination of a tag and the value (data item) it tags. But the <em>value of the tag</em> is the integer that identifies the tag.</p>
</blockquote>
<p>If we print the diagnostic notation of our tagged value, we can see the tag in the output:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span>let diagnostic = usd.diagnostic();
let expected_diagnostic = r#"

33000("USD")

"#.trim();

assert_eq!(diagnostic, expected_diagnostic);
<span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>As shown above, we can always extract the <code>(Tag, CBOR)</code> tuple from a tagged value, and then compare the tag value to our constant to see whether we want to process it further. But it's a common pattern to expect to find a specific tag in a particular place in a CBOR structure. <code>dcbor</code> provides a convenience method <code>try_into_expected_tagged_value()</code> to test the tag value and return an error if it doesn't match. If it succeeds, it returns the tagged value for further processing.</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span>let item = usd
    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
    .try_into_text()?;
assert_eq!(item, "USD");

<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="tagging-a-complex-structure"><a class="header" href="#tagging-a-complex-structure">Tagging a Complex Structure</a></h2>
<p>Let's say we want to combine our tagged currency code with an amount. Currency amounts can be tricky, because they are expressed as having decimal fractions, but many common floating point values, like <code>1.1</code> cannot be represented exactly in binary floating point, meaning that even highly-precise types like <code>f64</code> can't represent common currency values accurately.</p>
<p>Let's define a new type called <code>DecimalFraction</code> that holds an integer mantissa and a signed integer exponent representing powers of 10. When negative, the exponent indicates the number of places to the right of the decimal point, so <code>1.1</code> would be represented as a mantissa of <code>11</code> with an exponent of <code>-1</code>, and <code>1.01</code> would be represented as a mantissa of <code>101</code> with an exponent of <code>-2</code>.</p>
<pre><code class="language-rust"><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">use crate::tags::TAG_DECIMAL_FRACTION;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span>pub struct DecimalFraction {
    pub exponent: i8,
    pub mantissa: i64,
}
<span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v = vec![value.exponent as i64, value.mantissa].to_cbor();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>✅ <strong>NOTE:</strong> We're not showing a lot of the typical boilerplate code here, like the <code>impl</code>s for <code>Debug</code>, <code>Clone</code>, <code>Display</code>, and things like <code>new()</code> methods. You can find the complete code in the repo for this book.</p>
</blockquote>
<p>It turns out that <a href="https://www.rfc-editor.org/rfc/rfc8949.html#name-decimal-fractions-and-bigfl">RFC8949 §3.4.4</a> already defines a CBOR schema for decimal fractions, so we can use that: it's just a two-element array with the exponent first and the mantissa second. It also reserves the tag <code>4</code> for decimal fractions, so we can use that as our tag.</p>
<pre><code class="language-rust">const TAG_DECIMAL_FRACTION: u64 = 4;</code></pre>
<pre><code class="language-rust"><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">use crate::tags::TAG_DECIMAL_FRACTION;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl From&lt;DecimalFraction&gt; for CBOR {
    fn from(value: DecimalFraction) -&gt; Self {
        // Compose the two-element array
        let v = vec![value.exponent as i64, value.mantissa].to_cbor();

        // Return the tagged array
        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
    }
}
<span class="boring">
</span><span class="boring">impl TryFrom&lt;CBOR&gt; for DecimalFraction {
</span><span class="boring">    type Error = dcbor::Error;
</span><span class="boring">
</span><span class="boring">    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
</span><span class="boring">        // Decode the tagged array
</span><span class="boring">        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;
</span><span class="boring">
</span><span class="boring">        // Convert the item to an array
</span><span class="boring">        let arr = item.try_into_array()?;
</span><span class="boring">
</span><span class="boring">        // Validate the length of the array
</span><span class="boring">        if arr.len() != 2 {
</span><span class="boring">            return Err("Expected a two-element array".into());
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Extract the exponent and mantissa
</span><span class="boring">        let exponent: i8 = arr[0].clone().try_into()?;
</span><span class="boring">        let mantissa: i64 = arr[1].clone().try_into()?;
</span><span class="boring">
</span><span class="boring">        // Return the DecimalFraction
</span><span class="boring">        Ok(DecimalFraction::new(exponent, mantissa))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>Now we can create a <code>DecimalFraction</code> and convert it to CBOR, showing the diagnostic notation:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span>let a = DecimalFraction::new(-1, 11);
let cbor = a.to_cbor();
assert_eq!(cbor.diagnostic(), r#"

4(
    [-1, 11]
)

"#.trim());
<span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Because conversion from CBOR to a given type can fail, we implement the <code>TryFrom&lt;CBOR&gt;</code> trait for our <code>DecimalFraction</code> type:</p>
<pre><code class="language-rust"><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">use crate::tags::TAG_DECIMAL_FRACTION;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">pub struct DecimalFraction {
</span><span class="boring">    pub exponent: i8,
</span><span class="boring">    pub mantissa: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DecimalFraction {
</span><span class="boring">    /// Create a new `DecimalFraction` from raw parts.
</span><span class="boring">    pub fn new(exponent: i8, mantissa: i64) -&gt; Self {
</span><span class="boring">        Self { exponent, mantissa }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Convert back to `f64`. May lose precision on large exponents.
</span><span class="boring">    pub fn to_f64(self) -&gt; f64 {
</span><span class="boring">        (self.mantissa as f64) * (10f64).powi(self.exponent as i32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for DecimalFraction {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        if self.mantissa == 0 {
</span><span class="boring">            return write!(f, "0");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let abs_value = self.mantissa.abs();
</span><span class="boring">        let is_negative = self.mantissa &lt; 0;
</span><span class="boring">        let prefix = if is_negative { "-" } else { "" };
</span><span class="boring">
</span><span class="boring">        if self.exponent &gt;= 0 {
</span><span class="boring">            // For positive exponent, add zeros after the number
</span><span class="boring">            write!(f, "{}{}{}", prefix, abs_value, "0".repeat(self.exponent as usize))
</span><span class="boring">        } else {
</span><span class="boring">            // For negative exponent, insert decimal point
</span><span class="boring">            let abs_exp = -self.exponent as usize;
</span><span class="boring">            let value_str = abs_value.to_string();
</span><span class="boring">
</span><span class="boring">            if value_str.len() &lt;= abs_exp {
</span><span class="boring">                // Decimal point at the beginning with possible leading zeros
</span><span class="boring">                let padding = abs_exp - value_str.len();
</span><span class="boring">                write!(f, "{}0.{}{}", prefix, "0".repeat(padding), value_str)
</span><span class="boring">            } else {
</span><span class="boring">                // Insert decimal point within the number
</span><span class="boring">                let decimal_pos = value_str.len() - abs_exp;
</span><span class="boring">                let (integer_part, fractional_part) = value_str.split_at(decimal_pos);
</span><span class="boring">                write!(f, "{}{}.{}", prefix, integer_part, fractional_part)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;DecimalFraction&gt; for CBOR {
</span><span class="boring">    fn from(value: DecimalFraction) -&gt; Self {
</span><span class="boring">        // Compose the two-element array
</span><span class="boring">        let v = vec![value.exponent as i64, value.mantissa].to_cbor();
</span><span class="boring">
</span><span class="boring">        // Return the tagged array
</span><span class="boring">        CBOR::to_tagged_value(TAG_DECIMAL_FRACTION, v)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl TryFrom&lt;CBOR&gt; for DecimalFraction {
    type Error = dcbor::Error;

    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
        // Decode the tagged array
        let item = cbor.try_into_expected_tagged_value(TAG_DECIMAL_FRACTION)?;

        // Convert the item to an array
        let arr = item.try_into_array()?;

        // Validate the length of the array
        if arr.len() != 2 {
            return Err("Expected a two-element array".into());
        }

        // Extract the exponent and mantissa
        let exponent: i8 = arr[0].clone().try_into()?;
        let mantissa: i64 = arr[1].clone().try_into()?;

        // Return the DecimalFraction
        Ok(DecimalFraction::new(exponent, mantissa))
    }
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction() {
</span><span class="boring">    let a = DecimalFraction::new(-1, 11);
</span><span class="boring">    assert_eq!(a.mantissa, 11);
</span><span class="boring">    assert_eq!(a.exponent, -1);
</span><span class="boring">    assert!((a.to_f64() - 1.1).abs() &lt; f64::EPSILON);
</span><span class="boring">
</span><span class="boring">    let b = DecimalFraction::new(-2, 101);
</span><span class="boring">    assert_eq!(b.mantissa, 101);
</span><span class="boring">    assert_eq!(b.exponent, -2);
</span><span class="boring">    assert!((b.to_f64() - 1.01).abs() &lt; f64::EPSILON);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn decimal_fraction_display() {
</span><span class="boring">    // Test zero
</span><span class="boring">    let zero = DecimalFraction::new(0, 0);
</span><span class="boring">    assert_eq!(zero.to_string(), "0");
</span><span class="boring">
</span><span class="boring">    // Test positive value with zero exponent
</span><span class="boring">    let simple = DecimalFraction::new(0, 42);
</span><span class="boring">    assert_eq!(simple.to_string(), "42");
</span><span class="boring">
</span><span class="boring">    // Test positive values with positive exponent
</span><span class="boring">    let pos_exp1 = DecimalFraction::new(2, 5);
</span><span class="boring">    assert_eq!(pos_exp1.to_string(), "500");
</span><span class="boring">
</span><span class="boring">    let pos_exp2 = DecimalFraction::new(3, 123);
</span><span class="boring">    assert_eq!(pos_exp2.to_string(), "123000");
</span><span class="boring">
</span><span class="boring">    // Test negative values with positive exponent
</span><span class="boring">    let neg_pos_exp = DecimalFraction::new(1, -42);
</span><span class="boring">    assert_eq!(neg_pos_exp.to_string(), "-420");
</span><span class="boring">
</span><span class="boring">    // Test positive values with negative exponent
</span><span class="boring">    let pos_neg_exp1 = DecimalFraction::new(-2, 123);
</span><span class="boring">    assert_eq!(pos_neg_exp1.to_string(), "1.23");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp2 = DecimalFraction::new(-1, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp2.to_string(), "0.5");
</span><span class="boring">
</span><span class="boring">    let pos_neg_exp3 = DecimalFraction::new(-3, 5);
</span><span class="boring">    assert_eq!(pos_neg_exp3.to_string(), "0.005");
</span><span class="boring">
</span><span class="boring">    // Test negative values with negative exponent
</span><span class="boring">    let neg_neg_exp1 = DecimalFraction::new(-2, -123);
</span><span class="boring">    assert_eq!(neg_neg_exp1.to_string(), "-1.23");
</span><span class="boring">
</span><span class="boring">    let neg_neg_exp2 = DecimalFraction::new(-3, -5);
</span><span class="boring">    assert_eq!(neg_neg_exp2.to_string(), "-0.005");
</span><span class="boring">
</span><span class="boring">    // Test boundary cases
</span><span class="boring">    let boundary1 = DecimalFraction::new(-9, 123456789);
</span><span class="boring">    assert_eq!(boundary1.to_string(), "0.123456789");
</span><span class="boring">
</span><span class="boring">    let boundary2 = DecimalFraction::new(-1, 1);
</span><span class="boring">    assert_eq!(boundary2.to_string(), "0.1");
</span><span class="boring">}</span></code></pre>
<p>Now we can round-trip our tagged value, converting it to CBOR and back to a <code>DecimalFraction</code>:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span>// Create a DecimalFraction
let a = DecimalFraction::new(-1, 11);
assert_eq!(a.to_string(), "1.1");

// Convert to CBOR
let cbor = a.clone().to_cbor();

// Convert back to DecimalFraction
let b: DecimalFraction = cbor.try_into()?;

// Check that the original and round-tripped values are equal
assert_eq!(a, b);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="implementing-a-tagged-string"><a class="header" href="#implementing-a-tagged-string">Implementing a Tagged String</a></h2>
<p>We used a tagged string for our currency code, but we can also define a <code>CurrencyCode</code> type using the <em>newtype</em> pattern. This is a common Rust idiom for creating a new type that wraps an existing type, like <code>String</code>, and provides additional functionality. In this case, the additional functionality is to implement <code>From&lt;CurrencyCode&gt; for CBOR</code> and <code>TryFrom&lt;CBOR&gt; for CurrencyCode</code>.</p>
<pre><code class="language-rust"><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">use crate::TAG_CURRENCY_CODE;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span>pub struct CurrencyCode(String);

impl CurrencyCode {
    pub fn new(code: &amp;str) -&gt; Self {
        Self(code.into())
    }

    pub fn code(&amp;self) -&gt; &amp;str {
        &amp;self.0
    }
}

impl From&lt;CurrencyCode&gt; for CBOR {
    fn from(value: CurrencyCode) -&gt; Self {
        CBOR::to_tagged_value(TAG_CURRENCY_CODE, value.0)
    }
}

impl TryFrom&lt;CBOR&gt; for CurrencyCode {
    type Error = dcbor::Error;

    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
        let value = cbor.try_into_expected_tagged_value(TAG_CURRENCY_CODE)?;
        let currency_code: String = value.try_into()?;
        Ok(CurrencyCode(currency_code))
    }
}

impl std::fmt::Display for CurrencyCode {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "{}", self.0)
    }
}</code></pre>
<p>Now we can round-trip our <code>CurrencyCode</code> the same way we did with <code>DecimalFraction</code>:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span>let usd = CurrencyCode::new("USD");
let cbor = usd.to_cbor();
let usd2: CurrencyCode = cbor.try_into()?;
assert_eq!(usd, usd2);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="combining-the-two-types"><a class="header" href="#combining-the-two-types">Combining the Two Types</a></h2>
<p>Originally we set out to create a structure that combined a currency code with a decimal fraction: <code>CurrencyAmount</code>. We'd also like this structure to have its own tag, so we'll use <code>33001</code>, which is also unassigned by IANA as of this writing.</p>
<pre><code class="language-rust">const TAG_CURRENCY_AMOUNT: u64 = 33001;</code></pre>
<p>Now that we have completely reusable constituents, we can define <code>CurrencyAmount</code> as a type that consists of a <code>CurrencyCode</code> and a <code>DecimalFraction</code>.</p>
<pre><code class="language-rust"><span class="boring">use dcbor::prelude::*;
</span><span class="boring">use crate::{ CurrencyCode, DecimalFraction, TAG_CURRENCY_AMOUNT };
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, PartialEq, Eq)]
</span>pub struct CurrencyAmount(CurrencyCode, DecimalFraction);

impl CurrencyAmount {
    pub fn new(currency: CurrencyCode, amount: DecimalFraction) -&gt; Self {
        Self(currency, amount)
    }

    pub fn currency(&amp;self) -&gt; &amp;CurrencyCode {
        &amp;self.0
    }

    pub fn amount(&amp;self) -&gt; &amp;DecimalFraction {
        &amp;self.1
    }
}

impl From&lt;CurrencyAmount&gt; for CBOR {
    fn from(value: CurrencyAmount) -&gt; Self {
        let v = vec![value.currency().to_cbor(), value.amount().to_cbor()].to_cbor();
        CBOR::to_tagged_value(TAG_CURRENCY_AMOUNT, v)
    }
}

impl TryFrom&lt;CBOR&gt; for CurrencyAmount {
    type Error = dcbor::Error;

    fn try_from(cbor: CBOR) -&gt; Result&lt;Self, Self::Error&gt; {
        let item = cbor.try_into_expected_tagged_value(TAG_CURRENCY_AMOUNT)?;
        let arr = item.try_into_array()?;

        if arr.len() != 2 {
            return Err("Expected a two-element array".into());
        }

        let currency: CurrencyCode = arr[0].clone().try_into()?;
        let amount: DecimalFraction = arr[1].clone().try_into()?;

        Ok(CurrencyAmount(currency, amount))
    }
}

impl std::fmt::Display for CurrencyAmount {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "{} {}", self.currency(), self.amount())
    }
}</code></pre>
<p>Notice that in the above example, we're able to call the <code>to_cbor()</code> method on the <code>CurrencyCode</code> and <code>DecimalFraction</code> types, because the <code>dcbor</code> library includes a <em>blanket implementation</em> for another trait called <code>CBOREncodable</code>, which automatically applies to any type that implements <code>Into&lt;CBOR&gt;</code> and <code>Clone</code>. (We implemented <code>From&lt;CurrencyCode&gt; for CBOR</code> and <code>From&lt;DecimalFraction&gt; for CBOR</code> which also implicitly implement the <code>Into&lt;CBOR&gt;</code> trait, so we get the <code>CBOREncodable</code> trait for free.)</p>
<p>The <code>CBOREncodable</code> trait gives us the <code>to_cbor()</code> method, which can be called on a <code>&amp;self</code> (reference to self) unlike the <code>into()</code> method, which consumes the value. It also gives us the <code>to_cbor_data()</code> method, which returns the final, serialized CBOR data as a <code>Vec&lt;u8&gt;</code>.</p>
<p>This use of blanket implementations is a common Rust idiom, similar to how types that implement the <code>Display</code> trait automatically implement the <code>ToString</code> trait and hence gain the <code>to_string()</code> method.</p>
<p>Now with all the pieces in place, we can do a full round-trip of our <code>CurrencyAmount</code> type:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_no_names() -&gt; Result&lt;()&gt; {
</span>// Create a CurrencyAmount
let currency_amount = CurrencyAmount::new(
    CurrencyCode::new("USD"),
    DecimalFraction::new(-1, 11)
);
assert_eq!(currency_amount.to_string(), "USD 1.1");

// Convert to CBOR
let cbor = currency_amount.to_cbor();

// Check the diagnostic notation
let expected_diagnostic = r#"
33001(
    [
        33000("USD"),
        4(
            [-1, 11]
        )
    ]
)
"#.trim();
assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);

// Convert to binary CBOR data
let data = cbor.to_cbor_data();

// Check the hex representation of the binary data
let expected_hex = r#"

d9 80e9                 # tag(33001)
    82                  # array(2)
        d9 80e8         # tag(33000)
            63          # text(3)
                555344  # "USD"
        c4              # tag(4)
            82          # array(2)
                20      # negative(-1)
                0b      # unsigned(11)

"#.trim();
assert_eq!(cbor.hex_annotated(), expected_hex);

// Convert back to CBOR
let cbor2 = CBOR::try_from_data(data)?;

// Convert back to CurrencyAmount
let currency_amount2: CurrencyAmount = cbor2.try_into()?;

// Check that the original and round-tripped values are equal
assert_eq!(currency_amount, currency_amount2);
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="named-tags"><a class="header" href="#named-tags">Named Tags</a></h2>
<p>As mentioned, a CBOR tag is just an integer, and that integer is all that is ever serialized to the binary stream. But the <code>dcbor</code> library allows you to associate a human-readable name with a tag, which can be useful for debugging and documentation. The <code>dcbor</code> library provides a macro for defining compile-time constants for tags and their names:</p>
<pre><code class="language-rust"><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span>const_cbor_tag!(4, DECIMAL_FRACTION, "DecimalFraction");
const_cbor_tag!(33000, CURRENCY_CODE, "CurrencyCode");
const_cbor_tag!(33001, CURRENCY_AMOUNT, "CurrencyAmount");
<span class="boring">
</span><span class="boring">pub fn register_tags() {
</span><span class="boring">    with_tags_mut!(|tags_store: &amp;mut TagsStore| {
</span><span class="boring">        tags_store.insert_all(vec![
</span><span class="boring">            cbor_tag!(DECIMAL_FRACTION),
</span><span class="boring">            cbor_tag!(CURRENCY_CODE),
</span><span class="boring">            cbor_tag!(CURRENCY_AMOUNT),
</span><span class="boring">        ]);
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p>These macro invocations are a concise equivalent to the following code:</p>
<pre><code class="language-rust">const TAG_DECIMAL_FRACTION: u64 = 4;
const TAG_NAME_DECIMAL_FRACTION: &amp;str = "DecimalFraction";

const TAG_CURRENCY_CODE: u64 = 33000;
const TAG_NAME_CURRENCY_CODE: &amp;str = "CurrencyCode";

const TAG_CURRENCY_AMOUNT: u64 = 33001;
const TAG_NAME_CURRENCY_AMOUNT: &amp;str = "CurrencyAmount";</code></pre>
<p>To make these names available to runtime calls like <code>CBOR::diagnostic_annotated</code> and <code>CBOR::hex_annotated</code>, we need to <em>register</em> them once at the start of our program:</p>
<pre><code class="language-rust"><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">const_cbor_tag!(4, DECIMAL_FRACTION, "DecimalFraction");
</span><span class="boring">const_cbor_tag!(33000, CURRENCY_CODE, "CurrencyCode");
</span><span class="boring">const_cbor_tag!(33001, CURRENCY_AMOUNT, "CurrencyAmount");
</span><span class="boring">
</span>pub fn register_tags() {
    with_tags_mut!(|tags_store: &amp;mut TagsStore| {
        tags_store.insert_all(vec![
            cbor_tag!(DECIMAL_FRACTION),
            cbor_tag!(CURRENCY_CODE),
            cbor_tag!(CURRENCY_AMOUNT),
        ]);
    });
}</code></pre>
<p>The <code>cbor_tag!</code> macro is actually doing the work of creating the <code>Tag</code> instances for us, using the same naming convention as the constants defined using the <code>const_cbor_tag!</code> macro. The <code>with_tags_mut!</code> macro provides writable, thread-safe access to the global tag registry.</p>
<p>Here's the same example as before, but calling <code>register_tags()</code> at the start of the program. Now both output formats include the human-readable names for the tags:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span>// Register our tags first thing
register_tags();

// Create a CurrencyAmount
let currency_amount = CurrencyAmount::new(
    CurrencyCode::new("USD"),
    DecimalFraction::new(-1, 11)
);
assert_eq!(currency_amount.to_string(), "USD 1.1");

// Convert to CBOR
let cbor = currency_amount.to_cbor();

// Check the diagnostic notation, now with named tags
let expected_diagnostic = r#"

33001(   / CurrencyAmount /
    [
        33000("USD"),   / CurrencyCode /
        4(   / DecimalFraction /
            [-1, 11]
        )
    ]
)

"#.trim();
assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);

// Convert to binary CBOR data
let data = cbor.to_cbor_data();

// Check the hex representation of the binary data, now with named tags
let expected_hex = r#"

d9 80e9                 # tag(33001) CurrencyAmount
    82                  # array(2)
        d9 80e8         # tag(33000) CurrencyCode
            63          # text(3)
                555344  # "USD"
        c4              # tag(4) DecimalFraction
            82          # array(2)
                20      # negative(-1)
                0b      # unsigned(11)

"#.trim();
assert_eq!(cbor.hex_annotated(), expected_hex);

// Convert back to CBOR
let cbor2 = CBOR::try_from_data(data)?;

// Convert back to CurrencyAmount
let currency_amount2: CurrencyAmount = cbor2.try_into()?;

// Check that the original and round-tripped values are equal
assert_eq!(currency_amount, currency_amount2);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_debug = r#"
</span><span class="boring">
</span><span class="boring">CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", currency_amount), expected_debug);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CurrencyAmount`
</span><span class="boring">//
</span><span class="boring">let expected_display = r#"
</span><span class="boring">
</span><span class="boring">USD 1.1
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", currency_amount), expected_display);
</span><span class="boring">
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Debug` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_debug_cbor = r#"
</span><span class="boring">
</span><span class="boring">tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{:?}", cbor), expected_debug_cbor);
</span><span class="boring">
</span><span class="boring">//
</span><span class="boring">// Using the `Display` implementation on `CBOR`
</span><span class="boring">//
</span><span class="boring">let expected_display_cbor = r#"
</span><span class="boring">
</span><span class="boring">33001([33000("USD"), 4([-1, 11])])
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(format!("{}", cbor), expected_display_cbor);
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="a-note-about-the-debug-and-display-implementations-on-cbor"><a class="header" href="#a-note-about-the-debug-and-display-implementations-on-cbor">A Note About the <code>Debug</code> and <code>Display</code> implementations on <code>CBOR</code></a></h2>
<p>You've been learning about calls like <code>CBOR::diagnostic_annotated()</code> and <code>CBOR::hex_annotated()</code>, which are used to print the CBOR data in a human-readable format, and <code>CBOR::to_cbor_data()</code>, which returns the raw CBOR data as a <code>Vec&lt;u8&gt;</code>.</p>
<p>These methods are useful for debugging (and of course serializing your CBOR), but they are not the same as the <code>Debug</code> and <code>Display</code> traits, and it's also important to understand the difference between how these trait outputs are formatted on your <em>original</em> structures, versus how they are formatted on the <code>CBOR</code> type:</p>
<pre><code class="language-rust"><span class="boring">use cbor_book::*;
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn example_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let usd = CBOR::to_tagged_value(TAG_CURRENCY_CODE, "USD");
</span><span class="boring">
</span><span class="boring">let (tag, item) = usd.clone().try_into_tagged_value()?;
</span><span class="boring">assert_eq!(tag.value(), TAG_CURRENCY_CODE);
</span><span class="boring">assert_eq!(item.try_into_text()?, "USD");
</span><span class="boring">
</span><span class="boring">let diagnostic = usd.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33000("USD")
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let item = usd
</span><span class="boring">    .try_into_expected_tagged_value(TAG_CURRENCY_CODE)?
</span><span class="boring">    .try_into_text()?;
</span><span class="boring">assert_eq!(item, "USD");
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">// 33000("USD")
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor() {
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">assert_eq!(cbor.diagnostic(), r#"
</span><span class="boring">
</span><span class="boring">4(
</span><span class="boring">    [-1, 11]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn decimal_fraction_cbor_roundtrip() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a DecimalFraction
</span><span class="boring">let a = DecimalFraction::new(-1, 11);
</span><span class="boring">assert_eq!(a.to_string(), "1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = a.clone().to_cbor();
</span><span class="boring">
</span><span class="boring">// Convert back to DecimalFraction
</span><span class="boring">let b: DecimalFraction = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_code_cbor() -&gt; Result&lt;()&gt; {
</span><span class="boring">let usd = CurrencyCode::new("USD");
</span><span class="boring">let cbor = usd.to_cbor();
</span><span class="boring">let usd2: CurrencyCode = cbor.try_into()?;
</span><span class="boring">assert_eq!(usd, usd2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn currency_amount_cbor_named() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Register our tags first thing
</span><span class="boring">register_tags();
</span><span class="boring">
</span><span class="boring">// Create a CurrencyAmount
</span><span class="boring">let currency_amount = CurrencyAmount::new(
</span><span class="boring">    CurrencyCode::new("USD"),
</span><span class="boring">    DecimalFraction::new(-1, 11)
</span><span class="boring">);
</span><span class="boring">assert_eq!(currency_amount.to_string(), "USD 1.1");
</span><span class="boring">
</span><span class="boring">// Convert to CBOR
</span><span class="boring">let cbor = currency_amount.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the diagnostic notation, now with named tags
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">33001(   / CurrencyAmount /
</span><span class="boring">    [
</span><span class="boring">        33000("USD"),   / CurrencyCode /
</span><span class="boring">        4(   / DecimalFraction /
</span><span class="boring">            [-1, 11]
</span><span class="boring">        )
</span><span class="boring">    ]
</span><span class="boring">)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert to binary CBOR data
</span><span class="boring">let data = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the binary data, now with named tags
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">d9 80e9                 # tag(33001) CurrencyAmount
</span><span class="boring">    82                  # array(2)
</span><span class="boring">        d9 80e8         # tag(33000) CurrencyCode
</span><span class="boring">            63          # text(3)
</span><span class="boring">                555344  # "USD"
</span><span class="boring">        c4              # tag(4) DecimalFraction
</span><span class="boring">            82          # array(2)
</span><span class="boring">                20      # negative(-1)
</span><span class="boring">                0b      # unsigned(11)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(cbor.hex_annotated(), expected_hex);
</span><span class="boring">
</span><span class="boring">// Convert back to CBOR
</span><span class="boring">let cbor2 = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert back to CurrencyAmount
</span><span class="boring">let currency_amount2: CurrencyAmount = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and round-tripped values are equal
</span><span class="boring">assert_eq!(currency_amount, currency_amount2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn debug_and_display_formats() -&gt; Result&lt;()&gt; {
</span>let currency_amount = CurrencyAmount::new(
    CurrencyCode::new("USD"),
    DecimalFraction::new(-1, 11)
);

//
// Using the `Debug` implementation on `CurrencyAmount`
//
let expected_debug = r#"

CurrencyAmount(CurrencyCode("USD"), DecimalFraction { exponent: -1, mantissa: 11 })

"#.trim();
assert_eq!(format!("{:?}", currency_amount), expected_debug);

//
// Using the `Display` implementation on `CurrencyAmount`
//
let expected_display = r#"

USD 1.1

"#.trim();
assert_eq!(format!("{}", currency_amount), expected_display);

let cbor = currency_amount.to_cbor();

//
// Using the `Debug` implementation on `CBOR`
//
let expected_debug_cbor = r#"

tagged(33001, array([tagged(33000, text("USD")), tagged(4, array([negative(-1), unsigned(11)]))]))

"#.trim();
assert_eq!(format!("{:?}", cbor), expected_debug_cbor);

//
// Using the `Display` implementation on `CBOR`
//
let expected_display_cbor = r#"

33001([33000("USD"), 4([-1, 11])])

"#.trim();
assert_eq!(format!("{}", cbor), expected_display_cbor);
<span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<ul>
<li>The <code>Debug</code> trait on <code>CurrencyAmount</code> is just the default <code>Debug</code> implementation for a struct, which prints the field names and values in a human-readable format.</li>
<li>The <code>Display</code> trait on <code>CurrencyAmount</code> is a custom implementation that formats the value as a string with the currency code and amount.</li>
<li>The <code>Debug</code> trait on <code>CBOR</code> is a nested symbolic representation of the CBOR major types and values.</li>
<li>The <code>Display</code> trait on <code>CBOR</code> is the same as would be returned by <code>CBOR::diagnostic_flat()</code>, which is valid diagnostic notation all on one line.</li>
</ul>
<p>Each of these formats is useful in its own way, so knowing when to use each one will help you get the most out of the <code>dcbor</code> library.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part_2/using_dcbor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part_2/determinism_with_dcbor.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part_2/using_dcbor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part_2/determinism_with_dcbor.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
