<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using dCBOR - The CBOR, dCBOR, and Gordian Envelope Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The CBOR, dCBOR, and Gordian Envelope Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="using-dcbor"><a class="header" href="#using-dcbor">Using dCBOR</a></h1>
<p>So after all that discussion of the motivation for dCBOR, let's just recap its rules all in one place, and specifically how they differ from basic CBOR:</p>
<ul>
<li><strong>Map Keys</strong>: No duplicates. Must be serialized sorted lexicographically by the serialized key.</li>
<li><strong>Numeric Values</strong>: "Preferred Serialization" isn't just preferred, it's required.</li>
<li><strong>Numeric Reduction</strong>: Floating point values that can accurately be represented as integers must be serialized as integers.</li>
<li><strong>Indefinite Length</strong>: Indefinite length values are not allowed.</li>
<li><strong>Simple Values</strong>: Only <code>false</code>, <code>true</code>, and <code>null</code> are allowed.</li>
<li><strong>Strings</strong>: Must be encoded in Unicode Normalization Form C (NFC).</li>
<li><strong>Decoders</strong>: Must check all the rules above and reject any serialization that doesn't conform to them.</li>
</ul>
<p>Pretty simple, right?</p>
<p>It gets even simpler when you use a CBOR library that supports dCBOR directly, as the implementation should take care of all the details for you. In fact, a good API will even make it <em>impossible</em> to create invalid dCBOR serializations.</p>
<p>The <a href="https://crates.io/crates/dcbor"><code>dcbor</code></a> crate is the Rust reference implementation of dCBOR from Blockchain Commons, and in this chapter we'll show you how easy it is to use.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>This will add the latest version of the <code>dcbor</code> crate to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-bash">cargo add dcbor
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p><code>dcbor</code> includes a <code>prelude</code> module that re-exports all the types and traits you need to use dCBOR:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span>// This is all you need to import to use the library.
use dcbor::prelude::*;
<span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Many common types are directly convertible into dCBOR. Thanks to dCBOR's numeric reduction, you don't even need to specify whether common numeric types should be serialized as integers or floating point: the <code>dcbor</code> library will automatically choose the best representation for you.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span>pub fn main() {
    // Encode the integer 42
    let i = 42;
    let cbor: CBOR = i.to_cbor();
    // The CBOR type above here for clarity, can be inferred

    // Check the diagnostic representation
    assert_eq!(cbor.diagnostic(), "42");

    // Check the hex representation
    assert_eq!(cbor.hex(), "1a002a");

    // Check the CBOR data
    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>When you use <code>value.to_cbor()</code> or <code>CBOR::from(value)</code>, you're not <em>actually</em> encoding the CBOR serialization in that moment. You're actually creating an intermediate representation of the data (an instance of <code>CBOR</code>) that can be serialized later when you call a method like <code>to_cbor_data</code>.</p>
<p>Converting back from CBOR is also easy: you specify the type you want to convert to, and the <code>dcbor</code> library will do the rest. You use the <code>try_from</code> method to convert from CBOR to a Rust type, which will succeed if the CBOR can be accurately converted to that type. If the conversion fails, it will return an error:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span>let a = 42;
let cbor = a.to_cbor();
let b = i32::try_from_cbor(&amp;cbor)?;
assert_eq!(a, b);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>In the following example we use <code>try_from</code> to convert from CBOR to both a <code>u8</code> type and an <code>f64</code> type. Both succeed, because the value <code>42</code> can be represented as both an 8-bit unsigned integer and a 64-bit floating point number:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span>let a = 42;
let cbor = a.to_cbor();

// Decode as a u8
let b = u8::try_from_cbor(&amp;cbor)?;
assert_eq!(a as u8, b);

// Decode as an f64
let c = f64::try_from_cbor(&amp;cbor)?;
assert_eq!(a as f64, c);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<blockquote>
<p><strong> NOTE:</strong> Observe the call to <code>clone()</code> above, which we need because the <code>try_from</code> method consumes the <code>CBOR</code> value, and we still need an instance for the second <code>try_from</code> call. Instances of <code>CBOR</code> are immutable, and the <code>dcbor</code> library implements structure sharing, so cloning is always cheap.</p>
</blockquote>
<p>Below we encode a floating point value with a non-zero fractional part, which succeeds in being decoded back to floating point but fails to decode back to an integer, because precision would be lost:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span>let a = 1.23456;
let cbor = a.to_cbor();

// Decode as an f64
let b = f64::try_from_cbor(&amp;cbor)?;
assert_eq!(a, b);

// Cannot decode as a i32
assert!(i32::try_from_cbor(&amp;cbor).is_err());
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>This idiom is not just for numeric types: you can use it for any type that implements the <code>TryFrom&lt;CBOR&gt;</code> trait, like <code>String</code>:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span>let a = "Hello, dCBOR!";
let cbor = a.to_cbor();

// Decode as an f64 fails
assert!(f64::try_from_cbor(&amp;cbor).is_err());

// Decode as a String succeeds
let b = String::try_from_cbor(&amp;cbor)?;
assert_eq!(a, b);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>It even works for vectors:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span>// Encode a vector of 8-bit unsigned integers
let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
let cbor = a.to_cbor();

// Decode as Vec of a compatible type: 32-bit signed integers
let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
assert_eq!(b, vec![1, 2, 3, 4, 5]);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="byte-strings"><a class="header" href="#byte-strings">Byte Strings</a></h2>
<p>The last example raises an interesting question: is our <code>Vec&lt;u8&gt;</code> being serialized as a CBOR <em>array</em> or a CBOR <em>byte string</em>? Let's check:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span>// Encode a vector of 8-bit unsigned integers
let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
let cbor = a.to_cbor();

let hex = cbor.hex_annotated();
let expected_hex = r#"

85      # array(5)
    01  # unsigned(1)
    02  # unsigned(2)
    03  # unsigned(3)
    04  # unsigned(4)
    05  # unsigned(5)

"#.trim();

assert_eq!(hex, expected_hex);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>As you can see, the header byte specifies an array of five elements, followed by five CBOR data items for the integers <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>. So the <code>Vec&lt;u8&gt;</code> is being serialized as a CBOR array, not a byte string.</p>
<p>In Rust, <code>Vec&lt;u8&gt;</code> is often used to represent a string or buffer of bytes, but in CBOR, a byte string is a different type distinct from a vector or an array. The <code>CBOR</code> type provides a static method <code>CBOR::to_byte_string</code> that converts a <code>Vec&lt;u8&gt;</code> into a CBOR byte string:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span>// Encode a vector of 8-bit unsigned integers
let a = vec![1, 2, 3, 4, 5];
let byte_string = CBOR::to_byte_string(a);
let cbor = byte_string.to_cbor();

let hex = cbor.hex_annotated();
let expected_hex = r#"

45              # bytes(5)
    0102030405

"#.trim();

assert_eq!(hex, expected_hex);

let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
assert_eq!(b, vec![1, 2, 3, 4, 5]);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Everything in the serialization in this example is the same as the last, <em>except</em> the header byte, which was <code>0x85</code> for a 5-element array, and <code>0x45</code> for a byte string of length 5.</p>
<p>Notice that recovering the byte string is also different. Since a byte string is not an array, we can't extract it as a <code>Vec&lt;u8&gt;</code>. Instead, we extract it as the type <code>ByteString</code>, and then convert <em>that</em> to a <code>Vec&lt;u8&gt;</code> using <code>.into()</code>.</p>
<p><code>ByteString</code> is just a wrapper around <code>Vec&lt;u8&gt;</code>, and it has most of the same capabilities, but the <code>dcbor</code> library treats it as a CBOR byte string, not a CBOR array.</p>
<h2 id="simple-values-false-true-and-null"><a class="header" href="#simple-values-false-true-and-null">Simple Values: <code>false</code>, <code>true</code>, and <code>null</code></a></h2>
<p>dCBOR supports three <em>simple values</em> <code>false</code>, <code>true</code>, and <code>null</code> and the <code>dcbor</code> library provides a set of conveniences for working with them. In the example below we create a CBOR array containing <code>[true, false, null]</code>, and then test its CBOR diagnostic notation and annotated hex serialization:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span>let v: Vec&lt;CBOR&gt; = vec![
    true.into(),
    false.into(),
    CBOR::null(),
];
let cbor = v.to_cbor();

let diagnostic = cbor.diagnostic();
let expected_diagnostic = "[true, false, null]";
assert_eq!(diagnostic, expected_diagnostic);

let hex = cbor.hex_annotated();
let expected_hex = r#"

83      # array(3)
    f5  # true
    f4  # false
    f6  # null

"#.trim();

assert_eq!(hex, expected_hex);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Something interesting is going on here: our array has three values, two of which are booleans and the third is its own type: <code>null</code>. CBOR is designed to handle such <em>heterogeneous arrays</em> with no problem. But Rust (unlike some languages like JavaScript) doesn't have a <code>null</code> value (preferring <code>Option&lt;T&gt;</code> for values which may not be present). Rust also doesn't natively support <code>Vec</code>s containing mixed types. So how does the <code>dcbor</code> library handle this?</p>
<p>First, note that our array is not declared as a <code>Vec&lt;bool&gt;</code> but as a <code>Vec&lt;CBOR&gt;</code>. The CBOR type can hold <em>any</em> CBOR value, including complex values like nested arrays and maps. In the context of the <code>vec!</code> macro composing a <code>Vec&lt;CBOR&gt;</code>, the Rust boolean values <code>true</code> and <code>false</code> can just be converted directly using <code>.into()</code>, and that's what we're doing here.</p>
<p>Rust has no <code>null</code> value, so the <code>dcbor</code> library provides a <code>CBOR::null()</code> method that returns a <code>CBOR</code> instance representing the <code>null</code> value.</p>
<p>And since all three elements of the array are being converted directly into CBOR, there is no problem constructing the heterogeneous array.</p>
<blockquote>
<p><strong> NOTE:</strong> Of course, dCBOR doesn't support CBOR <code>undefined</code> or any of the other simple values, so the <code>dcbor</code> API doesn't have ways to let you construct them.</p>
</blockquote>
<h2 id="extracting-from-a-heterogeneous-array"><a class="header" href="#extracting-from-a-heterogeneous-array">Extracting from a Heterogeneous Array</a></h2>
<p>So now that we've gotten ourselves into this situation, how do we get the values back out? The <code>dcbor</code> library provides a set of methods for testing and extracting the CBOR major types, as well as unique values like <code>true</code>, <code>false</code>, and <code>null</code>:</p>
<p>In the example below we first begin by extracting our CBOR array from the composed <code>CBOR</code> instance. We then demonstrate several methods to either extract values or test them against expected values.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span>// Compose an array of CBOR values
let v: Vec&lt;CBOR&gt; = vec![
    true.into(),
    false.into(),
    CBOR::null(),
];
// Convert the array to a single CBOR object, which would
// be serialized to CBOR data or recovered from it.
let cbor: CBOR = v.to_cbor();

// Recover the array from the CBOR object
let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;

// Check the length of the array
assert_eq!(v2.len(), 3);

// For the first value (`true`), extract it so it could be saved for later.
let t = CBOR::try_bool(&amp;v2[0])?;
assert!(t);

// For the second value (`false`), just assert that it is false.
assert!(v2[1].is_false());

// For the third value (`null`), assert that it is null.
assert!(v2[2].is_null());
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<p>As long as all the types contained in a Rust <code>HashMap</code> or <code>BTreeMap</code> are supported by CBOR (we'll discuss how to make your own types CBOR-compatible in a later chapter), then converting them to CBOR and back is straightforward.</p>
<p>In the example below we round-trip a Rust <code>HashMap</code> with <code>String</code> keys and <code>Vec&lt;String&gt;</code> values all the way to serialized CBOR data and back again:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span>// Create a HashMap with String keys and Vec&lt;String&gt; values
let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);

// Convert the HashMap to a CBOR object
let cbor = h.to_cbor();

// Check the representation in CBOR diagnostic notation
let diagnostic = cbor.diagnostic();
let expected_diagnostic = r#"

{
    "colors":
    ["red", "green", "blue"],
    "animals":
    ["cat", "dog", "horse"]
}

"#.trim();
assert_eq!(diagnostic, expected_diagnostic);

// Serialize the CBOR to binary data
let data: Vec&lt;u8&gt; = cbor.to_cbor_data();

// Check the hex representation of the serialized data
let hex = hex::encode(&amp;data);
let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
assert_eq!(hex, expected_hex);

// Deserialize the data back into a CBOR object
let cbor2: CBOR = CBOR::try_from_data(data)?;

// Convert the CBOR object back into a HashMap
let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;

// Check that the original and deserialized HashMaps are equal
assert_eq!(h, h2);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Those familiar with JSON know that it only supports string keys, but CBOR supports any type of CBOR value as a key, and it's a common pattern to use integers as keys, which are much more compact:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span>// Create a HashMap with integer keys and Vec&lt;String&gt; values
let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());

// Convert the HashMap to a CBOR object
let cbor = h.to_cbor();

// Check the representation in CBOR diagnostic notation
let diagnostic = cbor.diagnostic_flat();
let expected_diagnostic = r#"

{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}

"#.trim();
assert_eq!(diagnostic, expected_diagnostic);

// Convert the CBOR object back into a HashMap
let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;

// Check that the original and deserialized HashMaps are equal
assert_eq!(h, h2);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with CBOR for its keys and values
</span><span class="boring">let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
</span><span class="boring">h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
</span><span class="boring">h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Note the use of <code>diagnostic_flat()</code> in this example, which returns the diagnostic notation with no line breaks or indentation. In previous examples we also used either <code>hex()</code> or <code>hex_annotated()</code> depending on the desired formatting.</p>
<h2 id="heterogeneous-maps"><a class="header" href="#heterogeneous-maps">Heterogeneous Maps</a></h2>
<p>CBOR (and the <code>dcbor</code> library) supports heterogeneous maps, which means that the keys and values can be of different types within the same map. The technique is basically the same as with heterogeneous arrays: you use <code>CBOR</code> as the type for the keys and values, and then convert them to the appropriate types when you extract them.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor: CBOR = i.to_cbor();
</span><span class="boring">    // The CBOR type above here for clarity, can be inferred
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(i32::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from_cbor(&amp;cbor).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from_cbor(&amp;cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = CBOR::try_bool(&amp;v2[0])?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with integer keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, ["cat", "dog", "horse"].map(str::to_string).to_vec());
</span><span class="boring">h.insert(2, ["red", "green", "blue"].map(str::to_string).to_vec());
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_13() -&gt; Result&lt;()&gt; {
</span>// Create a HashMap with CBOR for its keys and values
let mut h: HashMap&lt;CBOR, CBOR&gt; = HashMap::new();
h.insert(1.into(), vec![CBOR::from("cat"), "dog".into(), "horse".into()].into());
h.insert(2.into(), vec![CBOR::from("red"), "green".into(), "blue".into()].into());

// Convert the HashMap to a CBOR object
let cbor = h.to_cbor();

// Check the representation in CBOR diagnostic notation
let diagnostic = cbor.diagnostic_flat();
let expected_diagnostic = r#"

{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}

"#.trim();
assert_eq!(diagnostic, expected_diagnostic);

// Convert the CBOR object back into a HashMap
let h2: HashMap&lt;CBOR, CBOR&gt; = cbor.try_into()?;

// Check that the original and deserialized HashMaps are equal
assert_eq!(h, h2);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_14() -&gt; Result&lt;()&gt; {
</span><span class="boring">// number to CBOR
</span><span class="boring">let n = 10;
</span><span class="boring">let cbor = n.to_cbor();
</span><span class="boring">// CBOR to number
</span><span class="boring">assert_eq!(i32::try_from_cbor(&amp;cbor)?, n);
</span><span class="boring">assert_eq!(f64::try_from_cbor(&amp;cbor)?, n as f64);
</span><span class="boring">
</span><span class="boring">// bool to CBOR
</span><span class="boring">let b = true;
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">// CBOR to bool
</span><span class="boring">assert_eq!(bool::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">assert_eq!(CBOR::try_bool(&amp;cbor)?, b);
</span><span class="boring">
</span><span class="boring">// null to CBOR
</span><span class="boring">// let n = CBOR::null();
</span><span class="boring">// let cbor = n.to_cbor();
</span><span class="boring">// // CBOR to null
</span><span class="boring">// let n2 = CBOR::try_from_cbor(&amp;cbor)?;
</span><span class="boring">// assert_eq!(n2, n);
</span><span class="boring">// assert!(cbor.is_null());
</span><span class="boring">
</span><span class="boring">// bstr to CBOR
</span><span class="boring">let v = vec![1, 2, 3, 4, 5];
</span><span class="boring">let b = ByteString::from(&amp;v);
</span><span class="boring">let cbor = b.to_cbor();
</span><span class="boring">let cbor2 = CBOR::to_byte_string(&amp;v);
</span><span class="boring">assert_eq!(cbor, cbor2);
</span><span class="boring">// CBOR to bstr
</span><span class="boring">assert_eq!(ByteString::try_from_cbor(&amp;cbor)?, b);
</span><span class="boring">let array: Vec&lt;u8&gt; = CBOR::try_byte_string(&amp;cbor)?;
</span><span class="boring">assert_eq!(array, v);
</span><span class="boring">
</span><span class="boring">// tstr to CBOR
</span><span class="boring">let t = "Hello";
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tstr
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;cbor)?, t);
</span><span class="boring">assert_eq!(CBOR::try_text(&amp;cbor)?, t);
</span><span class="boring">
</span><span class="boring">// array to CBOR
</span><span class="boring">let a = vec![1, 2, 3];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">// CBOR to homogenous array
</span><span class="boring">let b = Vec::&lt;i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">// CBOR to heterogeneous array
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = b.iter()
</span><span class="boring">    .map(|x| i32::try_from_cbor(x).map_err(Into::into))
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">let b: Vec&lt;CBOR&gt; = CBOR::try_array(&amp;cbor)?;
</span><span class="boring">let b: Vec&lt;i32&gt; = vec![
</span><span class="boring">    i32::try_from_cbor(&amp;b[0])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[1])?,
</span><span class="boring">    i32::try_from_cbor(&amp;b[2])?,
</span><span class="boring">];
</span><span class="boring">assert_eq!(b, a);
</span><span class="boring">
</span><span class="boring">// map to CBOR
</span><span class="boring">let mut m: HashMap&lt;String, i32&gt; = HashMap::new();
</span><span class="boring">m.insert("a".into(), 1);
</span><span class="boring">m.insert("b".into(), 2);
</span><span class="boring">let cbor = m.to_cbor();
</span><span class="boring">// CBOR to homogenous map
</span><span class="boring">let m2 = HashMap::&lt;String, i32&gt;::try_from_cbor(&amp;cbor)?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">// CBOR to heterogeneous map
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let m2: HashMap&lt;String, i32&gt; = m2.iter()
</span><span class="boring">    .map(|(k, v)| {
</span><span class="boring">        let k = String::try_from_cbor(k).map_err(anyhow::Error::from)?;
</span><span class="boring">        let v = i32::try_from_cbor(v).map_err(anyhow::Error::from)?;
</span><span class="boring">        Ok((k, v))
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Result&lt;_&gt;&gt;()?;
</span><span class="boring">assert_eq!(m, m2);
</span><span class="boring">let m2: dcbor::Map = CBOR::try_map(&amp;cbor)?;
</span><span class="boring">let a: i32 = m2.extract("a")?;
</span><span class="boring">assert_eq!(a, 1);
</span><span class="boring">let b: i32 = m2.extract("b")?;
</span><span class="boring">assert_eq!(b, 2);
</span><span class="boring">
</span><span class="boring">// tagged to CBOR
</span><span class="boring">let t = CBOR::to_tagged_value(999, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(Tag::from(999), t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// tagged (with name) to CBOR
</span><span class="boring">let named_tag = Tag::new(999, "my-tag");
</span><span class="boring">let t = CBOR::to_tagged_value(&amp;named_tag, "Hello");
</span><span class="boring">let cbor = t.to_cbor();
</span><span class="boring">// CBOR to tagged
</span><span class="boring">let t2: (Tag, CBOR) = CBOR::try_tagged_value(&amp;cbor)?;
</span><span class="boring">assert_eq!(named_tag, t2.0);
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2.1)?, "Hello");
</span><span class="boring">// Expecting a specific tag
</span><span class="boring">let t2 = CBOR::try_expected_tagged_value(&amp;cbor, &amp;named_tag)?;
</span><span class="boring">assert_eq!(String::try_from_cbor(&amp;t2)?, "Hello");
</span><span class="boring">
</span><span class="boring">// Registering a tag for diagnostic annotation
</span><span class="boring">with_tags_mut!(|tags: &amp;mut TagsStore| {
</span><span class="boring">    tags.insert(named_tag);
</span><span class="boring">});
</span><span class="boring">assert_eq!(cbor.diagnostic_annotated(), r#"999("Hello")   / my-tag /"#);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>In the next chapter we'll cover how to use tags in dCBOR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part_2/cbor_cde_dcbor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part_2/dcbor_tags.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part_2/cbor_cde_dcbor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part_2/dcbor_tags.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
