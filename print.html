<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The CBOR, dCBOR, and Gordian Envelope Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The CBOR, dCBOR, and Gordian Envelope Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="introduction/images/cover.jpg" alt="Cover Art" /></p>
<h1 id="the-cbor-dcbor-and-gordian-envelope-book"><a class="header" href="#the-cbor-dcbor-and-gordian-envelope-book">The CBOR, dCBOR, and Gordian Envelope Book</a></h1>
<p><em>Wolf McNally</em><br />
<em>Christopher Allen</em></p>
<p><a href="https://www.blockchaincommons.com/">Blockchain Commons</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colophon"><a class="header" href="#colophon">Colophon</a></h1>
<p><strong>The CBOR, dCBOR, and Gordian Envelope Book</strong></p>
<p>by</p>
<p>Wolf McNally<br />
Christopher Allen<br />
and other contributors to Blockchain Commons.</p>
<p>The content is written in Markdown and built using <a href="https://github.com/rust-lang/mdBook">mdBook</a>.</p>
<p>All code examples are in Rust, using the <code>dcbor</code> and <code>bc-envelope</code> crates available on <a href="https://crates.io">crates.io</a>.</p>
<p>This project is open source and collaborative. Contributions require a signed Contributor License Agreement (CLA) as described in the repository. Unless otherwise noted, the content of this book is licensed under the <a href="https://spdx.org/licenses/BSD-2-Clause-Patent.html">BSD-2-Clause Plus Patent License</a>. You are free to use, modify, and redistribute the material under these terms.</p>
<p>For more information, source code, and contribution guidelines, visit the <a href="https://github.com/BlockchainCommons">Blockchain Commons GitHub organization</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="tldr-who-is-this-book-for"><a class="header" href="#tldr-who-is-this-book-for">TL;DR: Who is This Book For?</a></h2>
<ul>
<li>
<p>If your primary goal is to understand a modern, efficient binary serialization format that offers significant performance and size benefits over JSON, Part I provides a comprehensive guide to CBOR.</p>
</li>
<li>
<p>If your application requires absolute, verifiable consistency – for digital signatures, content hashing, consensus, or interoperable verification – Part II delves into the principles of determinism and the specifics of dCBOR, including a tutorial for the <code>dcbor</code> Rust crate.</p>
</li>
<li>
<p>For those building applications that require structured, verifiable, and privacy-preserving data – <em>smart documents</em> – Part III explores the groundbreaking capabilities of Gordian Envelope, including usage of the <code>bc-envelope</code> Rust crate.</p>
</li>
</ul>
<hr />
<h2 id="navigating-the-landscape-of-modern-data-representation"><a class="header" href="#navigating-the-landscape-of-modern-data-representation">Navigating the Landscape of Modern Data Representation</a></h2>
<p>Modern software engineering demands tools that can handle the dual pressures of performance and trust. As systems grow more distributed and data security becomes paramount, developers must move beyond formats that were designed for a simpler era. JSON, while readable and ubiquitous, can introduce unacceptable inefficiencies—slowing performance, bloating payloads, and leaving room for ambiguity where certainty is required.</p>
<p>This book introduces a progressive technological stack—CBOR, dCBOR, and Gordian Envelope—that addresses these modern challenges head-on. Together, they form a path from compact binary encoding to cryptographically verifiable and privacy-preserving data structures. Understanding these tools enables engineers and decision-makers to build faster, leaner, and more trustworthy systems—without compromise.</p>
<h2 id="part-i-the-foundation--achieving-efficiency-with-cbor"><a class="header" href="#part-i-the-foundation--achieving-efficiency-with-cbor">Part I: The Foundation – Achieving Efficiency with CBOR</a></h2>
<p>At the core of this stack is CBOR: Concise Binary Object Representation, defined in RFC 8949. It was designed for constrained environments, enabling implementations with minimal memory and CPU usage—ideal for IoT devices, embedded systems, and high-throughput applications.</p>
<p>CBOR offers significant efficiency over JSON. Its binary encoding means faster parsing, smaller messages, and lower latency. It also supports an extended data model, including binary byte strings, which simplifies integration with existing JSON systems while enabling more advanced use cases.</p>
<p>Crucially, CBOR is extensible. New tags can be introduced without breaking older implementations, reducing long-term maintenance burdens. Protocols can evolve without costly version negotiations, and features can be rolled out faster and more safely.</p>
<p>While JSON emphasizes human readability, CBOR prioritizes performance, resource efficiency, and future-proof extensibility. In many systems—especially where network bandwidth, power, or processing time is scarce—CBOR isn’t just better. It’s necessary.</p>
<h2 id="part-ii-the-guarantee--ensuring-verifiable-consistency-with-dcbor"><a class="header" href="#part-ii-the-guarantee--ensuring-verifiable-consistency-with-dcbor">Part II: The Guarantee – Ensuring Verifiable Consistency with dCBOR</a></h2>
<p>Efficiency alone isn’t enough for systems that rely on trust. Distributed ledgers, digital signatures, and content-addressed data all depend on one principle: the exact same data must always serialize to the exact same bytes.</p>
<p>CBOR provides guidelines for deterministic encoding—but leaves enough leeway to produce different byte sequences for the same logical structure. This is a problem for cryptography and consensus protocols, where even one byte of variance invalidates signatures or breaks agreement.</p>
<p>Deterministic CBOR (dCBOR) solves this. It is a strict profile of CBOR that eliminates ambiguity. It defines canonical rules for numeric encoding (e.g., converting <code>2.0</code> to <code>2</code>, collapsing NaNs into a single representation), mandates lexicographic sorting of map keys by their encoded form, and forbids features like indefinite-length values that undermine determinism.</p>
<p>dCBOR isn’t a fork. It’s fully valid CBOR, but with stricter rules and mandatory validation. Encoders must produce canonical output. Decoders must reject anything that isn’t. This guards against inconsistency, manipulation, and protocol divergence—critical when trust is on the line.</p>
<p>For engineering teams building security-critical systems, dCBOR provides the byte-level reliability needed to anchor hashing, signing, auditing, and cross-platform integrity checks. It replaces ambiguity with assurance.</p>
<h2 id="part-iii-the-breakthrough--secure-structured-privacy-enhancing-data-with-gordian-envelope"><a class="header" href="#part-iii-the-breakthrough--secure-structured-privacy-enhancing-data-with-gordian-envelope">Part III: The Breakthrough – Secure, Structured, Privacy-Enhancing Data with Gordian Envelope</a></h2>
<p>Once determinism is in place, it becomes possible to build something far more powerful: a structured, secure, and privacy-aware data format that can adapt to the demands of modern identity, privacy, and trust. That’s what Gordian Envelope delivers.</p>
<p>Built atop dCBOR, Gordian Envelope enables deeply structured data with built-in cryptographic integrity. It’s a semantic format—often modeled as subject-predicate-object triples—wrapped in a Merkle-like digest tree. This structure guarantees that every element, not just the whole, can be independently verified.</p>
<p>What sets Envelope apart is <strong>holder-controlled elision</strong>: the ability to redact or hide portions of the data without invalidating the overall structure or breaking attached signatures. This enables minimal disclosure, progressive trust, and user-controlled privacy—foundational principles for self-sovereign identity and modern data sovereignty.</p>
<p>Envelope also supports advanced layering: encryption, compression, nested signatures, and semantic annotations. These features don’t just bolt on—they integrate directly with the underlying structure, allowing powerful capabilities like verifiable redaction, authenticated subtrees, and selective disclosure proofs.</p>
<p>Its use cases are broad and high-impact: verifiable credentials, digital wallets, secure logs, privacy-preserving data sharing, and cryptographic asset management. More fundamentally, Envelope shifts control from institutions to individuals. Data no longer belongs solely to the issuer. It’s held, managed, and selectively revealed by the user.</p>
<p>This is the architecture of trust, built from the bottom up: efficient encoding, deterministic consistency, and cryptographic structure, all aligned with privacy and user agency.</p>
<p>CBOR is the foundation. dCBOR is the guarantee. Gordian Envelope is the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-xml-to-json-to-cbor"><a class="header" href="#from-xml-to-json-to-cbor">From XML to JSON to CBOR</a></h1>
<h2 id="a-lingua-franca-for-data"><a class="header" href="#a-lingua-franca-for-data">A <em>Lingua Franca</em> for Data?</a></h2>
<p>In modern computing, data exchange is foundational to everything from web browsing to microservices and IoT devices. The ability for different systems to represent, share, and interpret structured information drives our digital world. Yet no single perfect format has emerged to meet all needs. Instead, we've seen an evolution of data interchange formats, each addressing the specific challenges and technical requirements of its time.</p>
<p>This narrative traces three pivotal data formats: Extensible Markup Language (<a href="https://www.w3.org/TR/xml/">XML</a>), JavaScript Object Notation (<a href="https://www.json.org/">JSON</a>), and Concise Binary Object Representation (<a href="https://cbor.io/">CBOR</a>). We explore their origins and motivations, examine their core design principles and inherent trade-offs, and follow their adoption trajectories within the evolving digital landscape. The journey begins with XML's focus on robust document structure, shifts to JSON's web-centric simplicity and performance, and advances to CBOR's binary efficiency for constrained devices. Understanding this evolution reveals not just technical specifications, but the underlying pressures driving innovation in data interchange formats.</p>
<h2 id="the-age-of-structure-xmls-rise-from-publishing-roots"><a class="header" href="#the-age-of-structure-xmls-rise-from-publishing-roots">The Age of Structure: XML's Rise from Publishing Roots</a></h2>
<p>Modern data interchange formats trace back not to the web, but to challenges in electronic publishing decades earlier. SGML provided the complex foundation that XML would later refine and adapt for the internet age.</p>
<h3 id="the-sgml-inheritance-laying-the-foundation"><a class="header" href="#the-sgml-inheritance-laying-the-foundation">The SGML Inheritance: Laying the Foundation</a></h3>
<p>In the 1960s-70s, IBM researchers Charles Goldfarb, Ed Mosher, and Ray Lorie created Generalized Markup Language (GML) to overcome proprietary typesetting limitations. Their approach prioritized content structure over presentation. GML later evolved into Standard Generalized Markup Language (SGML), formalized as ISO 8879 in 1986.</p>
<p>SGML innovated through its meta-language approach, providing rules for creating custom markup languages. It allowed developers to define specific vocabularies (tag sets) and grammars (Document Type Definitions or DTDs) for different document types, creating machine-readable documents with exceptional longevity independent of processing technologies.</p>
<p>SGML gained traction in sectors managing complex documentation: government, military (CALS DTD), aerospace, legal publishing, and heavy industry. However, its 150+ page specification with numerous special cases complicated parser implementation, limiting broader adoption.</p>
<p>The web's emergence proved pivotal for markup languages. Tim Berners-Lee selected SGML as HTML's foundation due to its text-based, flexible, non-proprietary nature. Dan Connolly created the first HTML DTD in 1992. While HTML became ubiquitous, it drifted toward presentation over structure, with proliferating browser-specific extensions. SGML remained too complex for widespread web use, creating demand for a format that could bring SGML's structural capabilities to the internet in a more accessible form.</p>
<h3 id="w3c-and-the-birth-of-xml-taming-sgml-for-the-web"><a class="header" href="#w3c-and-the-birth-of-xml-taming-sgml-for-the-web">W3C and the Birth of XML: Taming SGML for the Web</a></h3>
<p>By the mid-1990s, the web needed more structured data exchange beyond HTML's presentational focus. In 1996, the W3C established an XML Working Group, chaired by Jon Bosak of Sun Microsystems, to create a simplified SGML subset suitable for internet use while maintaining extensibility and structure.</p>
<p>The W3C XML Working Group developed XML with clear design goals, formalized in the XML 1 Specification (W3C Recommendation, February 1998):</p>
<ol>
<li><strong>Internet Usability</strong>: Straightforward use over the internet</li>
<li><strong>Broad Applicability</strong>: Support for diverse applications beyond browsers</li>
<li><strong>SGML Compatibility</strong>: XML documents should be conforming SGML documents</li>
<li><strong>Ease of Processing</strong>: Simple program development for XML processing</li>
<li><strong>Minimal Optional Features</strong>: Few or no optional features</li>
<li><strong>Human Readability</strong>: Legible and clear documents</li>
<li><strong>Rapid Design</strong>: Quick design process</li>
<li><strong>Formal and Concise Design</strong>: Formal specification amenable to standard parsing</li>
<li><strong>Ease of Creation</strong>: Simple document creation with basic tools</li>
<li><strong>Terseness is Minimally Important</strong>: Conciseness was not prioritized over clarity</li>
</ol>
<p>SGML compatibility was strategically crucial. By defining XML as a valid SGML subset, existing SGML parsers and tools could immediately process XML documents when the standard released in 1998. This lowered adoption barriers for organizations already using SGML and provided an instant software ecosystem. The constraint also helped the working group achieve rapid development by limiting design choices, demonstrating an effective strategy for launching the new standard.</p>
<h3 id="designing-xml-tags-attributes-namespaces-and-schemas"><a class="header" href="#designing-xml-tags-attributes-namespaces-and-schemas">Designing XML: Tags, Attributes, Namespaces, and Schemas</a></h3>
<p>XML's structure uses nested elements marked by tags. An element consists of a start tag (<code>&lt;customer&gt;</code>), an end tag (<code>&lt;/customer&gt;</code>), and content between them, which can be text or other nested elements. Start tags can contain attributes for metadata (<code>&lt;address type="billing"&gt;</code>). Empty elements use syntax like <code>&lt;br/&gt;</code> or <code>&lt;br&gt;&lt;/br&gt;</code>. This hierarchical structure makes data organization explicit and human-readable.</p>
<p>As XML usage expanded, combining elements from different vocabularies created naming conflicts. The "Namespaces in XML" Recommendation (January 1999) addressed this by qualifying elements with unique IRIs, typically URIs. This uses the <code>xmlns</code> attribute, often with a prefix (<code>xmlns:addr="http://www.example.com/addresses"</code>), creating uniquely identified elements (<code>&lt;addr:street&gt;</code>). Default namespaces can be declared (<code>xmlns="URI"</code>) for unprefixed elements, but don't apply to attributes. Though URIs ensure uniqueness, they needn't point to actual online resources.</p>
<p>XML documents are validated using schema languages. XML initially used Document Type Definitions (DTDs) from SGML, which define allowed elements, attributes, and nesting rules. To overcome DTD limitations (non-XML syntax, poor type support), the W3C developed XML Schema Definition (<a href="https://www.w3.org/TR/xmlschema11-1/">XSD</a>), standardized in 2001. XSD offers powerful structure definition, rich data typing, and rules for cardinality and uniqueness. XSD schemas are themselves written in XML.</p>
<p>XML's structure enabled supporting technologies: XPath for node selection, XSL Transformations (<a href="https://www.w3.org/TR/xslt20/">XSLT</a>) for document transformation, and APIs like Document Object Model (DOM) for in-memory representation or Simple API for XML (SAX) for event-based streaming.</p>
<p>While XML effectively modeled complex data structures with extensibility and validation, its power introduced complexity. Creating robust XSD schemas was challenging, leading some to prefer simpler alternatives like RELAX NG or Schematron. Namespaces solved naming collisions but complicated both document authoring and parser development. XML's flexibility allowed multiple valid representations of the same data, potentially hindering interoperability without strict conventions. This inherent complexity, combined with verbosity, eventually drove demand for simpler formats, especially where ease of use and performance outweighed validation and expressiveness. The tension between richness and simplicity significantly influenced subsequent data format evolution.</p>
<h3 id="xmls-reign-and-ripples-adoption-and-impact"><a class="header" href="#xmls-reign-and-ripples-adoption-and-impact">XML's Reign and Ripples: Adoption and Impact</a></h3>
<p>Following its 1998 standardization, XML quickly became dominant across computing domains throughout the early 2000s, offering a standard, platform-independent approach for structured data exchange.</p>
<p>XML formed the foundation of <strong>Web Services</strong> through SOAP (Simple Object Access Protocol), an XML-based messaging framework operating over HTTP. Supporting technologies like WSDL (Web Services Description Language) and UDDI (Universal Description, Discovery and Integration) completed the "WS-*" stack for enterprise integration.</p>
<p><strong>Configuration Files</strong> widely adopted XML due to its structure and readability. Examples include Java's Log4j, Microsoft.NET configurations (<code>web.config</code>, <code>app.config</code>), Apache Ant build scripts, and numerous system parameters.</p>
<p>In <strong>Document Formats and Publishing</strong>, XML fulfilled its original promise by powering XHTML, RSS and Atom feeds, KML geographic data, and specialized formats like DocBook. Its content-presentation separation proved valuable for multi-channel publishing and content management.</p>
<p>As a general-purpose <strong>Data Interchange</strong> format, XML facilitated cross-system communication while avoiding vendor lock-in and supporting long-term data preservation.</p>
<p>This widespread adoption fostered a rich ecosystem of XML parsers, editors, validation tools, transformation engines (XSLT), data binding utilities, and dedicated conferences, building a strong technical community.</p>
<h3 id="the-seeds-of-change-xmls-verbosity-challenge"><a class="header" href="#the-seeds-of-change-xmls-verbosity-challenge">The Seeds of Change: XML's Verbosity Challenge</a></h3>
<p>Despite its success, XML carried the seeds of its own partial decline. A key design principle—"Terseness in XML markup is of minimal importance"—prioritized clarity over compactness, requiring explicit start and end tags for every element.</p>
<p>While enhancing readability, this structure created inherent verbosity. Simple data structures required significantly more characters in XML than in more compact formats. For example, <code>{"name": "Alice"}</code> in JSON versus <code>&lt;name&gt;Alice&lt;/name&gt;</code> in XML added substantial overhead, especially for large datasets with many small elements.</p>
<p>This verbosity became problematic as the web evolved. The rise of AJAX in the mid-2000s emphasized frequent, small data exchanges between browsers and servers for dynamic interfaces. In this context, minimizing bandwidth usage and parsing time became critical. XML's larger payloads and complex parsing requirements created performance bottlenecks.</p>
<p>The XML community recognized these efficiency concerns, leading to initiatives like the W3C's Efficient XML Interchange (EXI) Working Group, which developed a standardized binary XML format. While EXI offered significant compaction, it highlighted the challenge of retrofitting efficiency onto XML's tag-oriented foundation without adding complexity.</p>
<p>The decision to deprioritize terseness, while distinguishing XML from SGML, had unintended consequences. As the web shifted toward dynamic applications prioritizing speed and efficiency, XML's verbose structure became a liability. This created an opportunity for a format that would optimize for precisely what XML had considered minimal: conciseness and ease of parsing within web browsers and JavaScript.</p>
<h2 id="the-quest-for-simplicity-jsons-emergence-in-the-web-20-era"><a class="header" href="#the-quest-for-simplicity-jsons-emergence-in-the-web-20-era">The Quest for Simplicity: JSON's Emergence in the Web 2.0 Era</a></h2>
<p>As XML's verbosity and complexity became problematic in web development, particularly with AJAX's rise, a simpler alternative emerged directly from JavaScript.</p>
<h3 id="javascripts-offspring-douglas-crockford-and-the-discovery-of-json"><a class="header" href="#javascripts-offspring-douglas-crockford-and-the-discovery-of-json">JavaScript's Offspring: Douglas Crockford and the "Discovery" of JSON</a></h3>
<p>JSON (JavaScript Object Notation) originated with Douglas Crockford, an American programmer known for his JavaScript work. In 2001, Crockford and colleagues at State Software needed a lightweight format for data exchange between Java servers and JavaScript browsers without plugins like Flash or Java applets.</p>
<p>Crockford realized JavaScript's object literal syntax (e.g., <code>{ key: value }</code>) could serve this purpose. Data could be sent from servers embedded in JavaScript snippets for browsers to parse, initially using the <code>eval()</code> function. Crockford describes this as a "discovery" rather than invention, noting similar techniques at Netscape as early as 1996.</p>
<p>The initial implementation sent HTML documents containing <code>&lt;script&gt;</code> tags that called JavaScript functions, passing data as object literal arguments. One refinement: all keys required double quotes to avoid conflicts with JavaScript reserved words.</p>
<p>After naming conflicts with JSpeech Markup Language, they settled on "JavaScript Object Notation" or JSON. In 2002, Crockford acquired <a href="https://json.org">json.org</a> and published the grammar and reference parser. Developers quickly submitted parsers for various languages, demonstrating JSON's broader potential.</p>
<h3 id="motivation-a-lightweight-alternative-for-a-faster-web"><a class="header" href="#motivation-a-lightweight-alternative-for-a-faster-web">Motivation: A Lightweight Alternative for a Faster Web</a></h3>
<p>JSON addressed the need for a simpler, lighter data interchange format than XML. Crockford aimed for minimalism, believing "the less we have to agree on in order to inter-operate, the more likely we're going to be able to inter-operate well." He wanted a standard simple enough to fit on a business card.</p>
<p>When challenged that JSON was merely reinventing XML, Crockford famously replied, "The good thing about reinventing the wheel is that you can get a round one."</p>
<p>JSON arrived at the perfect time. AJAX techniques created demand for optimized, small data transfers between servers and browsers. Though "AJAX" meant "Asynchronous JavaScript and XML," JSON proved better for many cases. Its syntax maps directly to JavaScript objects and arrays, making client-side parsing trivial. Its lightweight nature reduced bandwidth usage and improved web application responsiveness.</p>
<p>Despite originating from JavaScript, JSON's success wasn't confined to browsers. Its simplicity made it remarkably easy to implement across programming languages. The core structures—objects (maps/dictionaries), arrays (lists), strings, numbers, booleans, and null—are fundamental to most modern languages. This ease of cross-language implementation drove its rapid adoption, transforming it from a JavaScript-specific solution into a de facto standard for web APIs and configuration files industry-wide. Simplicity became a powerful catalyst for language independence and widespread adoption.</p>
<h3 id="designing-json-key-value-pairs-arrays-and-minimal-types"><a class="header" href="#designing-json-key-value-pairs-arrays-and-minimal-types">Designing JSON: Key-Value Pairs, Arrays, and Minimal Types</a></h3>
<p>JSON's syntax is deliberately minimal, built on just a few structural elements from JavaScript:</p>
<ul>
<li><strong>Objects</strong>: Unordered key-value pairs in curly braces <code>{}</code>. Keys must be double-quoted strings, followed by a colon <code>:</code>, with comma-separated pairs. Example: <code>{ "name": "Alice", "age": 30 }</code>.</li>
<li><strong>Arrays</strong>: Ordered value sequences in square brackets <code>[]</code>, separated by commas. Example: <code>[ "apple", "banana", "cherry" ]</code>.</li>
</ul>
<p>Values can only be:</p>
<ul>
<li><strong>String</strong>: Double-quoted Unicode characters</li>
<li><strong>Number</strong>: Numeric values (without type distinction)</li>
<li><strong>Boolean</strong>: <code>true</code> or <code>false</code> (lowercase)</li>
<li><strong>Null</strong>: <code>null</code> (lowercase)</li>
<li><strong>Object</strong>: Nested JSON object</li>
<li><strong>Array</strong>: Nested JSON array</li>
</ul>
<p>This text-based structure is human-readable and directly maps to common programming data structures, making it developer-friendly.</p>
<p>JSON intentionally omits XML features like comments, namespaces, and attributes. Crockford deliberately excluded comments, noting they were often misused in formats like XML for parsing directives or metadata, potentially breaking interoperability. The recommended approach is to include commentary as regular data with conventional keys like <code>"_comment"</code>.</p>
<p>Native support arrived in ECMAScript 5 (2009) with <code>JSON.parse()</code> and <code>JSON.stringify()</code> methods, providing safe alternatives to <code>eval()</code> for parsing. The <code>stringify</code> method supports optional <code>replacer</code> functions for output control, and objects can implement <code>toJSON()</code> to customize serialization.</p>
<h3 id="json-vs-xml-a-paradigm-shift"><a class="header" href="#json-vs-xml-a-paradigm-shift">JSON vs. XML: A Paradigm Shift</a></h3>
<p>JSON and XML reflect fundamentally different design philosophies:</p>
<ul>
<li><strong>Format Type</strong>: XML is a <em>markup language</em> for structured documents; JSON is purely a <em>data interchange format</em> derived from JavaScript object literals.</li>
<li><strong>Structure</strong>: XML uses hierarchical tags with elements, attributes, and text. JSON uses <em>key-value pairs</em> and ordered <em>arrays</em>.</li>
<li><strong>Verbosity</strong>: XML's tag structure creates inherent verbosity. JSON's minimal syntax produces more compact representations, often 30-40% smaller.</li>
<li><strong>Readability</strong>: Both are text-based, but JSON's simpler structure is typically easier to scan and comprehend.</li>
<li><strong>Parsing</strong>: JSON parsing is simpler and faster, with native support in JavaScript. XML requires more complex parsers to handle tags, attributes, namespaces, and validation.</li>
<li><strong>Features</strong>: XML includes comments, namespaces, attributes, and robust schema languages (DTD, XSD). JSON is intentionally minimal, with extensions like <a href="https://json-schema.org/">JSON Schema</a> and <a href="https://json-ld.org/">JSON-LD</a> handled separately.</li>
<li><strong>Data Types</strong>: JSON supports basic types (string, number, boolean, null, object, array). XML lacks built-in types without schemas, but XSD enables rich typing.</li>
</ul>
<p>This comparison reveals the shift: XML prioritized structure, extensibility, and validation for complex documents, while JSON emphasized simplicity, usability, and performance for web APIs.</p>
<h3 id="rapid-ascent-json-becomes-the-language-of-apis"><a class="header" href="#rapid-ascent-json-becomes-the-language-of-apis">Rapid Ascent: JSON Becomes the Language of APIs</a></h3>
<p>JSON's alignment with web technologies drove its widespread adoption during the "Web 2.0" and AJAX era. It quickly dominated <strong>RESTful web APIs</strong>, with surveys showing over 85% of APIs using JSON as their default format.</p>
<p>Its utility extended to <strong>configuration files</strong> and <strong>data storage</strong>, particularly in NoSQL databases like MongoDB (using <a href="https://bsonspec.org/">BSON</a>) and browser storage via <code>localStorage</code>.</p>
<p>JSON's adoption grew organically through developer preference and the ease of creating parsers across languages, as seen in implementations at <a href="https://json.org">json.org</a>. Formal standardization followed with <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a> and <a href="https://datatracker.ietf.org/doc/html/rfc8259">IETF RFC 8259</a>.</p>
<p>A key factor in JSON's success is its remarkable stability. As Crockford emphasized, JSON is "finished"—it has no version number, and its core specification remains unchanged since inception. This stability contrasts with technologies requiring frequent updates, avoiding the fragmentation and compatibility issues CBOR later explicitly designed against. By providing a simple, reliable foundation, JSON allowed a rich ecosystem to flourish around it without requiring constant adaptation to core changes, proving stability to be a decisive feature for infrastructure technologies.</p>
<h2 id="the-need-for-speed-and-size-enter-cbor"><a class="header" href="#the-need-for-speed-and-size-enter-cbor">The Need for Speed (and Size): Enter CBOR</a></h2>
<p>While JSON offered a much-needed simplification and performance boost over XML for web APIs, its text-based nature still presented limitations in certain demanding environments. The relentless push for greater efficiency, particularly driven by the rise of the Internet of Things (IoT), paved the way for a format that combined JSON's data model with the compactness and speed of binary encoding: CBOR.</p>
<h3 id="beyond-text-the-motivation-for-binary"><a class="header" href="#beyond-text-the-motivation-for-binary">Beyond Text: The Motivation for Binary</a></h3>
<p>Text-based formats like JSON have inherent inefficiencies compared to binary representations:</p>
<ul>
<li><strong>Parsing Speed</strong>: Text parsing requires interpreting character sequences, computationally costlier than decoding structured binary data. Binary formats map more directly to machine data types.</li>
<li><strong>Message Size</strong>: Numbers, booleans, and repeated keys consume more bytes as text than with optimized binary encodings. Comparisons consistently show CBOR significantly reducing data size versus JSON.</li>
<li><strong>Binary Data Handling</strong>: JSON lacks a native binary data type (needed for images, cryptographic keys, sensor readings). Such data requires Base64 encoding, adding complexity and increasing size by ~33%.</li>
</ul>
<p>These limitations become critical in <strong>constrained environments</strong> characteristic of IoT:</p>
<ul>
<li><strong>Limited Resources</strong>: Minimal CPU, memory, and battery power</li>
<li><strong>Constrained Networks</strong>: Low bandwidth, high latency connections (<a href="https://lora-alliance.org/">LoRaWAN</a>, <a href="https://www.gsma.com/solutions-and-impact/technologies/internet-of-things/narrow-band-internet-of-things-nb-iot/">NB-IoT</a>, <a href="https://www.bluetooth.com/">Bluetooth LE</a>)</li>
</ul>
<p>In these scenarios, minimizing message size conserves bandwidth and energy, while reducing processing overhead extends battery life. CBOR was specifically designed to provide JSON's flexible data model in a compact, efficiently processable binary form optimized for resource-constrained environments.</p>
<h3 id="ietf-standardization-building-on-the-json-model"><a class="header" href="#ietf-standardization-building-on-the-json-model">IETF Standardization: Building on the JSON Model</a></h3>
<p>CBOR was developed within the IETF specifically for constrained environments, with Carsten Bormann and Paul Hoffman as key contributors.</p>
<p>CBOR intentionally builds upon the JSON data model, supporting equivalent types (numbers, strings, arrays, maps, booleans, and null) while adding native support for <strong>binary byte strings</strong> to address a key JSON limitation.</p>
<p>Initially standardized in RFC 7049 (2013), CBOR was updated in <a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC 8949</a> (2020) as Internet Standard 94 (STD 94). Importantly, RFC 8949 maintains full wire-format compatibility with its predecessor.</p>
<p>The standard articulates clear design goals:</p>
<ul>
<li><strong>Compact Code Size</strong>: Implementable with minimal code footprint for memory-constrained devices</li>
<li><strong>Reasonable Message Size</strong>: Significantly smaller than JSON without complex compression</li>
<li><strong>Extensibility without Version Negotiation</strong>: Future extensions remain compatible with existing decoders</li>
<li><strong>Schema-Free Decoding</strong>: Self-describing data items, parsable without predefined schemas</li>
<li><strong>Broad Applicability</strong>: Suitable for both constrained nodes and high-volume applications</li>
<li><strong>JSON Compatibility</strong>: Support for JSON data types with reasonable conversion</li>
</ul>
<p>CBOR effectively synthesizes lessons from both JSON and XML. It adopts JSON's familiar data model while optimizing for constrained environments through binary encoding and size efficiency. For extensibility, CBOR provides semantic <strong>tags</strong> (registered via <a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">IANA</a>) that allow new data types to be incorporated without breaking backward compatibility—combining JSON's simplicity with XML's extensibility approach.</p>
<h3 id="where-cbor-shines-constrained-environments"><a class="header" href="#where-cbor-shines-constrained-environments">Where CBOR Shines: Constrained Environments</a></h3>
<p>CBOR has established itself primarily in <strong>Internet of Things (IoT)</strong> and <strong>constrained environments</strong> where its compact representation of complex data structures provides crucial efficiency gains.</p>
<p>Key IETF protocols leveraging CBOR include:</p>
<ul>
<li>
<p><a href="https://coap.space/">CoAP (Constrained Application Protocol)</a>: A lightweight HTTP alternative for constrained networks using CBOR payloads. Mappings exist for protocols like IEC 61850 (smart grids), showing performance benefits over HTTP/XML or WS-SOAP.</p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/rfc8152/">COSE (CBOR Object Signing and Encryption)</a>: Defines cryptographic operations using CBOR, building on JOSE concepts but with binary efficiency. Fundamental to IoT security and used in FIDO WebAuthn passkey authentication.</p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc9200">ACE (Authentication and Authorization for Constrained Environments)</a>: Security framework for IoT resource access using CBOR and COSE.</p>
</li>
<li>
<p><strong>Device Management</strong>: Protocols like <a href="https://core-wg.github.io/comi/draft-ietf-core-comi.html">CORECONF</a> apply NETCONF/YANG concepts to constrained devices via CBOR.</p>
</li>
<li>
<p><strong>Certificate Representation</strong>: <a href="https://datatracker.ietf.org/doc/draft-ietf-cose-cbor-encoded-cert/">C509</a> creates smaller X.509 certificates than traditional DER/ASN.1 encoding.</p>
</li>
</ul>
<p>Beyond IETF standards, formats like <a href="https://json-ld.github.io/cbor-ld-spec/">CBOR-LD</a> and <a href="https://arxiv.org/abs/2407.04398">CBL</a> compress semantic web data for IoT applications.</p>
<p>Widespread <a href="https://cbor.io/impls.html">implementation support</a> across languages (C, C++, Go, Rust, Python, Java, Swift, etc.) facilitates CBOR integration across diverse systems.</p>
<p>While CBOR adoption grows within constrained systems and security protocols, it remains younger than XML and less dominant than JSON in general web APIs. Its binary nature sacrifices human readability for efficiency, making it less suitable where direct inspection and manual editing are priorities.</p>
<h3 id="the-trajectory-cbors-place-and-future"><a class="header" href="#the-trajectory-cbors-place-and-future">The Trajectory: CBOR's Place and Future</a></h3>
<p>CBOR's evolution optimizes for binary efficiency while maintaining JSON's flexible data model. Its growth centers on environments where these optimizations matter most: IoT, M2M communication, and security protocols.</p>
<p>As billions more IoT devices deploy, demand for efficient communication will increase, strengthening CBOR's position. Its integration into security mechanisms like COSE, particularly with passwordless authentication (WebAuthn/Passkeys), drives further adoption. CBOR's semantic tags provide extensibility without breaking backward compatibility.</p>
<p>In Part II, we'll explore another crucial CBOR advantage: deterministic encoding. This property ensures consistent serialization, essential for cryptographic applications including signatures, hashing, secure messaging, and distributed consensus protocols.</p>
<p>Despite these strengths, CBOR won't likely displace JSON in web APIs and general data interchange, where human readability and JavaScript integration remain paramount advantages.</p>
<h2 id="conclusion-an-evolving-landscape-of-data-representation"><a class="header" href="#conclusion-an-evolving-landscape-of-data-representation">Conclusion: An Evolving Landscape of Data Representation</a></h2>
<p>The XML-JSON-CBOR evolution demonstrates technology's pattern of moving from feature-rich solutions toward specialized formats for specific use cases. SGML offered comprehensive features but complexity; XML simplified it for web documents; JSON further streamlined for web APIs; CBOR then optimized for binary efficiency in constrained environments.</p>
<p>The future likely holds coexistence rather than a single dominant format, with selection driven by application requirements. Specialized formats like CBOR achieve superior performance within their niches through deliberate trade-offs, such as exchanging human readability for size and processing speed.</p>
<p><strong>Comparative Overview of XML, JSON, and CBOR</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>XML</th><th>JSON</th><th>CBOR</th></tr></thead><tbody>
<tr><td><strong>Originator/Body</strong></td><td>W3C (Jon Bosak et al.)</td><td>Douglas Crockford; later ECMA, IETF</td><td>IETF (Carsten Bormann, Paul Hoffman)</td></tr>
<tr><td><strong>Primary Goal</strong></td><td>Structured Docs, Web Data Exchange</td><td>Simple/Lightweight Web APIs, Data Interchange</td><td>Binary Efficiency, Compactness, Constrained Environments (IoT)</td></tr>
<tr><td><strong>Format Type</strong></td><td>Markup Language (Text)</td><td>Data Format (Text)</td><td>Data Format (Binary)</td></tr>
<tr><td><strong>Base Model</strong></td><td>SGML Subset</td><td>JavaScript Object Literal Subset</td><td>JSON Data Model Extension</td></tr>
<tr><td><strong>Structure</strong></td><td>Tag-based Tree (Elements, Attributes)</td><td>Key-Value Pairs (Objects) &amp; Ordered Values (Arrays)</td><td>Key-Value Pairs (Maps) &amp; Ordered Values (Arrays)</td></tr>
<tr><td><strong>Schema/Validation</strong></td><td>DTD, XSD (Built-in, Strong)</td><td>JSON Schema (Separate Spec, Optional)</td><td>CDDL (Separate Spec, Optional)</td></tr>
<tr><td><strong>Human Readability</strong></td><td>High (Verbose)</td><td>High (Concise)</td><td>Low (Binary)</td></tr>
<tr><td><strong>Size/Efficiency</strong></td><td>Verbose, Less Efficient Parsing</td><td>Lightweight, Efficient Parsing</td><td>Very Compact, Highly Efficient Parsing</td></tr>
<tr><td><strong>Extensibility</strong></td><td>Namespaces, Schema</td><td>Via conventions (e.g., JSON-LD), JSON Schema</td><td>Semantic Tags (IANA Registry)</td></tr>
<tr><td><strong>Native Binary Support</strong></td><td>No (Requires Encoding, e.g., Base64)</td><td>No (Requires Encoding, e.g., Base64)</td><td>Yes (Byte String Type)</td></tr>
<tr><td><strong>Primary Use Cases</strong></td><td>Documents (HTML, DocBook), SOAP, Config Files</td><td>REST APIs, Config Files, NoSQL Data</td><td>IoT Protocols (CoAP), Security (COSE), Constrained Devices</td></tr>
</tbody></table>
</div>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>
<p><a href="https://www.w3.org/TR/xml/">W3C Recommendation: Extensible Markup Language (XML) 1.0 (Fifth Edition)</a></p>
<ul>
<li>The foundational W3C specification defining XML.</li>
</ul>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8259">IETF RFC 8259: The JavaScript Object Notation (JSON) Data Interchange Format</a></p>
<ul>
<li>The current IETF standard defining JSON, essential for understanding its formal specification.</li>
</ul>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8949">IETF RFC 8949: Concise Binary Object Representation (CBOR)</a></p>
<ul>
<li>The IETF standard defining CBOR, its data model, binary encoding, and extensibility.</li>
</ul>
</li>
<li>
<p><a href="https://nwalsh.com/docs/articles/xml/">Walsh, N. "A Technical Introduction to XML"</a></p>
<ul>
<li>Clearly outlines the original design goals and motivations behind XML's creation.</li>
</ul>
</li>
<li>
<p><a href="https://twobithistory.org/2017/09/21/the-rise-and-rise-of-json.html">"The Rise and Rise of JSON" – Two-Bit History</a></p>
<ul>
<li>Provides an excellent narrative on JSON's origins, motivations, and the context of its emergence relative to XML.</li>
</ul>
</li>
<li>
<p><a href="https://cbor.io/">CBOR.io (Official CBOR Website)</a></p>
<ul>
<li>Authoritative overview of CBOR, its rationale, features, and links to specifications and implementations.</li>
</ul>
</li>
<li>
<p><a href="http://json.org/">JSON.org</a></p>
<ul>
<li>The original website by Douglas Crockford where JSON was first formally described and popularized.</li>
</ul>
</li>
<li>
<p><a href="https://aws.amazon.com/compare/the-difference-between-json-xml/">AWS: "JSON vs XML – Difference Between Data Representations"</a></p>
<ul>
<li>A representative comparison highlighting the practical differences and trade-offs between JSON and XML, explaining JSON's rise in web APIs.</li>
</ul>
</li>
<li>
<p><a href="https://www.corbado.com/glossary/cbor">Corbado Glossary: "What is CBOR?"</a></p>
<ul>
<li>A clear explanation of CBOR's purpose, benefits (efficiency, compactness), relationship to JSON, and relevance in the IoT context.</li>
</ul>
</li>
<li>
<p><a href="https://www.bobdc.com/blog/a-brief-opinionated-history-of/">DuCharme, B. "A brief, opinionated history of XML"</a></p>
<ul>
<li>Offers valuable historical context on XML's roots in SGML and its early development and adoption.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbor-vs-the-other-guys"><a class="header" href="#cbor-vs-the-other-guys">CBOR vs. The Other Guys</a></h1>
<h2 id="the-binary-serialization-landscape"><a class="header" href="#the-binary-serialization-landscape">The Binary Serialization Landscape</a></h2>
<p>In the previous chapter, we traced data interchange formats from verbose XML to simpler JSON, highlighting the quest for better ways to represent and exchange data. JSON's simplicity and performance advantages over XML made it dominant for web APIs. However, its text-based nature limits efficiency in size and processing speed. This led to CBOR (Concise Binary Object Representation), which retains JSON's familiar data model while leveraging binary encoding for compactness and performance—crucial for constrained environments like the Internet of Things (IoT).</p>
<p>CBOR exists within a broader landscape of binary serialization formats, each with specific goals and trade-offs. Understanding how CBOR compares to alternatives helps appreciate its strengths and make informed format decisions. This chapter surveys several prominent binary formats:</p>
<ul>
<li>
<p><a href="https://bsonspec.org/">BSON (Binary JSON)</a>: Developed by MongoDB for internal storage and wire format, extending JSON with database-centric types and optimizing for traversability.</p>
</li>
<li>
<p><a href="https://protobuf.dev/">Protocol Buffers (Protobuf)</a>: Google's high-performance, schema-driven format designed for efficient Remote Procedure Calls and data archival.</p>
</li>
<li>
<p><a href="https://msgpack.org/">MessagePack</a>: A fast, compact binary alternative to JSON, used for network communication and caching.</p>
</li>
<li>
<p><a href="https://avro.apache.org/">Avro</a>: An Apache project emphasizing robust schema evolution, common in big data ecosystems like Hadoop and Kafka.</p>
</li>
</ul>
<p>We'll compare these formats based on origins, data models, encoding strategies, schema approaches, performance characteristics, extensibility mechanisms, and typical use cases.</p>
<p>A fundamental distinction exists between <strong>schema-optional</strong> formats (CBOR, BSON, MessagePack) and <strong>schema-driven</strong> formats (Protocol Buffers, Avro). Schema-optional formats embed type information with the data, allowing parsing without prior structural knowledge—like JSON. This offers flexibility but introduces overhead and may require runtime validation. Schema-driven formats rely on external schemas known by both sender and receiver, potentially enabling more compact encodings (omitting field names/types) and compile-time validation, but requiring schema management and reducing data self-description. This core difference often reflects each format's origin—whether designed for flexible document storage like BSON or for high-performance, predefined message structures like Protobuf.</p>
<h2 id="bson-binary-json-tailored-for-databases"><a class="header" href="#bson-binary-json-tailored-for-databases">BSON: Binary JSON Tailored for Databases</a></h2>
<p>BSON emerged directly from MongoDB's needs. While MongoDB embraced JSON's flexible document model, raw JSON proved suboptimal for database operations due to its limited type system (lacking dates and binary data) and inefficiencies when parsing text for queries and indexing.</p>
<p>MongoDB created BSON to address these limitations—providing a binary JSON representation optimized for storage efficiency, rapid traversal, and enhanced type support while preserving schema flexibility. BSON serves as MongoDB's native format for both storage and network transfer.</p>
<h3 id="design-and-encoding"><a class="header" href="#design-and-encoding">Design and Encoding</a></h3>
<p>BSON documents serialize as binary data with explicit type and length information. Each document begins with a 4-byte total size, followed by a sequence of elements, ending with a null byte. Each element contains a one-byte type code, null-terminated field name, and type-specific value encoding. The inclusion of length prefixes enables MongoDB to quickly traverse documents and access specific fields without parsing entire structures.</p>
<p>BSON extends JSON's data model with several database-essential types:</p>
<ul>
<li>
<p><strong>ObjectId:</strong> A 12-byte unique identifier (timestamp + machine ID + process ID + counter), commonly used as primary key.</p>
</li>
<li>
<p><strong>Date:</strong> 64-bit integer representing milliseconds since Unix epoch.</p>
</li>
<li>
<p><strong>Binary Data (BinData):</strong> Direct embedding of byte arrays with subtype indicators, avoiding Base64 encoding.</p>
</li>
<li>
<p><strong>Timestamp:</strong> Special 64-bit type (seconds since epoch + ordinal) for MongoDB replication logs.</p>
</li>
<li>
<p><strong>Additional Numeric Types:</strong> 32-bit integers (<code>int32</code>), 64-bit integers (<code>int64</code>), 64-bit floats (<code>double</code>), and 128-bit high-precision decimals (<code>Decimal128</code>) for financial applications.</p>
</li>
<li>
<p><strong>Deprecated Types:</strong> Including <code>Undefined</code> (generally discouraged).</p>
</li>
</ul>
<p>A notable design choice is BSON's array encoding—represented as standard BSON documents with string keys matching array indices ("0", "1", "2"). While simplifying internal representation (everything is a document), this adds overhead compared to more efficient array encodings.</p>
<p>BSON prioritizes traversability and in-place updates. Length prefixes enable field skipping during reads, while fixed-size numeric encodings simplify value modification without rewriting entire documents.</p>
<h3 id="pros-and-cons"><a class="header" href="#pros-and-cons">Pros and Cons</a></h3>
<p>BSON's primary strengths derive from its MongoDB integration. It enables faster document traversal than parsing JSON text, with richer data types (dates, binary data, ObjectIds, high-precision decimals) essential for database operations. It maintains JSON's schema flexibility while allowing MongoDB to build indexes on document fields for efficient querying.</p>
<p>However, BSON has notable limitations. Type and length prefixes, along with verbose array encoding, often make BSON documents larger than equivalent JSON, particularly for small documents. It's generally less space-efficient than MessagePack or Protobuf. Like most binary formats, it lacks human readability. Its extended types prevent lossless conversion to standard JSON, limiting interoperability. BSON remains largely confined to the MongoDB ecosystem and lacks built-in RPC mechanisms.</p>
<h3 id="comparison-vs-cbor"><a class="header" href="#comparison-vs-cbor">Comparison vs. CBOR</a></h3>
<p>Both CBOR and BSON are schema-optional binary formats extending the JSON data model, but with different design priorities. BSON optimizes for database storage and traversal, using length prefixes and specialized types like <code>ObjectId</code> and <code>Decimal128</code>, sometimes sacrificing compactness. CBOR prioritizes conciseness and implementation simplicity for network transmission in constrained environments, typically achieving smaller message sizes. While BSON offers database-centric types, CBOR employs a more general type system extended through standardized tags (for dates, bignums, etc.). BSON remains closely tied to MongoDB, whereas CBOR exists as an IETF standard (RFC 8949) used across various internet protocols.</p>
<p>BSON's design clearly reflects its purpose as MongoDB's internal format. The need for rapid field access drove the inclusion of length prefixes, while database requirements dictated specialized types like <code>Date</code>, <code>BinData</code>, and <code>ObjectId</code>. These adaptations make BSON more than just binary JSON—it's an extended format tailored for database operations. This specialization benefits MongoDB but creates trade-offs in size and general interoperability compared to formats designed for broader use cases. The term "Binary JSON" can therefore be somewhat misleading, as its extended types prevent guaranteed lossless round-tripping with standard JSON.</p>
<h2 id="protocol-buffers-schema-driven-performance"><a class="header" href="#protocol-buffers-schema-driven-performance">Protocol Buffers: Schema-Driven Performance</a></h2>
<p>Protocol Buffers (Protobuf) originated at Google as a mechanism for serializing structured data, designed to be smaller, faster, and simpler than XML. Initially created for internal RPC and data storage, Google open-sourced it in 2008.</p>
<h3 id="design-and-encoding-1"><a class="header" href="#design-and-encoding-1">Design and Encoding</a></h3>
<p>Protobuf takes a fundamentally <strong>schema-driven</strong> approach. Data structures ("messages") must be defined in <code>.proto</code> files using Protobuf's Interface Definition Language (IDL).</p>
<p>The workflow centers on the <code>protoc</code> compiler, which processes <code>.proto</code> files to generate source code in various languages (C++, Java, Python, Go, C#, etc.). This generated code provides message classes with methods for field access, serialization, and parsing.</p>
<p>The binary format prioritizes compactness and speed. Instead of field names, each field uses a unique <strong>field number</strong> (tag) paired with a <strong>wire type</strong> indicating the encoding method. Wire types specify how much data to read (e.g., <code>VARINT</code> for variable-length integers, <code>LEN</code> for length-delimited data like strings).</p>
<p>Encoding techniques include <strong>Varints</strong> (using fewer bytes for smaller numbers) and <strong>ZigZag encoding</strong> (for efficient negative number representation). The data model supports numerous scalar types (<code>int32</code>, <code>uint64</code>, <code>bool</code>, <code>string</code>, etc.), nested messages, <code>repeated</code> fields (arrays), <code>map</code> fields (key-value pairs), and <code>oneof</code> (mutually exclusive fields).</p>
<p>Protobuf handles <strong>schema evolution</strong> well. As long as field numbers remain stable, developers can typically add or remove optional/repeated fields without breaking compatibility. Parsers skip unknown fields, enabling forward compatibility. However, changing field types is generally unsafe, and using <code>required</code> fields (discouraged in newer versions) limits evolution flexibility.</p>
<h3 id="pros-and-cons-1"><a class="header" href="#pros-and-cons-1">Pros and Cons</a></h3>
<p>Protobuf's advantages derive from its schema-driven approach, delivering high performance with compact message sizes by replacing field names with numeric tags. The schema and generated code provide compile-time type safety and simplified data access. Its evolution capabilities allow systems to change without breaking compatibility. Language-neutral code generation suits polyglot environments.</p>
<p>However, these schema requirements create notable limitations. Protobuf data isn't self-describing—the <code>.proto</code> definition is essential for interpreting the binary data. The format isn't human-readable. The workflow requires compiling <code>.proto</code> files and managing generated code, reducing flexibility for dynamic data structures. It can be suboptimal for very large messages (over a few megabytes) or multi-dimensional numeric arrays common in scientific computing. While widely adopted, Protobuf lacks formal standardization by bodies like IETF or W3C.</p>
<h3 id="comparison-vs-cbor-1"><a class="header" href="#comparison-vs-cbor-1">Comparison vs. CBOR</a></h3>
<p>The fundamental difference is their schema approach. Protobuf mandates schemas (<code>.proto</code> files) and compilation. CBOR is <strong>schema-optional</strong> with self-describing data containing embedded type indicators. While CBOR supports validation with schema languages like <a href="https://datatracker.ietf.org/doc/html/rfc8610">CDDL</a>, schemas aren't required for basic parsing.</p>
<p>This creates distinctions in self-description (CBOR yes, Protobuf no), encoding strategy (CBOR uses type indicators with string map keys; Protobuf uses numeric field tags and wire types), flexibility (CBOR higher, Protobuf more rigid but safer), and extensibility (CBOR uses IANA-registered tags, Protobuf uses <code>.proto</code>-defined options/extensions).</p>
<p>Performance comparisons are nuanced. Protobuf excels in speed and size, particularly for RPC with pre-shared schemas. CBOR also prioritizes efficiency, especially minimizing codec size for constrained devices. Results depend heavily on data, implementation quality, and use case. For standardization, CBOR is an IETF standard (RFC 8949), while Protobuf remains a Google-driven de facto standard.</p>
<p>Protobuf's philosophy achieves performance, compactness, and type safety through mandatory schemas and code generation—highly effective in controlled environments where schema management is feasible. This tight coupling yields efficiency gains but sacrifices the flexibility and self-description offered by formats like JSON or CBOR. The trade-off is clear: Protobuf prioritizes performance and structural rigidity, whereas CBOR favors flexibility and self-description while maintaining binary efficiency.</p>
<h2 id="messagepack-the-compact-json-alternative"><a class="header" href="#messagepack-the-compact-json-alternative">MessagePack: The Compact JSON Alternative</a></h2>
<p>MessagePack emerged around 2008-2009, created by Sadayuki Furuhashi. Its goal was to provide a more efficient binary serialization format than JSON – "like JSON, but fast and small." It addresses scenarios where JSON's verbosity creates bottlenecks, such as network communication (RPC, message queues) and data caching (e.g., in Memcached).</p>
<h3 id="design-and-encoding-2"><a class="header" href="#design-and-encoding-2">Design and Encoding</a></h3>
<p>MessagePack defines a binary format mirroring JSON's fundamental data types (null, boolean, integer, floating-point, string, array, map) while enabling transparent conversion between formats.</p>
<p>Beyond JSON types, MessagePack adds:</p>
<ul>
<li>
<p><strong><code>bin</code> (Binary Data):</strong> Efficient storage for raw byte sequences.</p>
</li>
<li>
<p><strong><code>ext</code> (Extension Type):</strong> Mechanism for application-specific types, consisting of an integer type code (tag) and a byte string payload.</p>
</li>
</ul>
<p>The encoding prioritizes compactness. Small integers can be encoded in a single byte. Short strings need only a length prefix followed by UTF-8 bytes. Arrays and maps include their element count as a prefix. Unlike JSON, MessagePack allows any data type as map keys, not just strings. Data types and lengths are indicated by initial encoded bytes.</p>
<h3 id="pros-and-cons-2"><a class="header" href="#pros-and-cons-2">Pros and Cons</a></h3>
<p>MessagePack delivers greater efficiency than JSON through smaller serialized output, optimized type encodings, potentially faster network transmission, and reduced storage requirements. Serialization and deserialization can outperform standard JSON libraries, though actual performance depends on implementations and data characteristics. It supports native binary data with an extension mechanism for custom types and offers implementations across numerous programming languages.</p>
<p>However, MessagePack sacrifices human-readability, complicating debugging. A significant limitation affects streaming: since arrays and maps require upfront element counts, streaming serialization becomes difficult when total counts aren't known in advance, potentially requiring complete in-memory buffering. While often faster than JSON, the margin varies with implementation quality and optimization. Compared to CBOR, MessagePack lacks formal standardization through bodies like IETF (its specification resides on GitHub), and its <code>ext</code> mechanism provides less structure than CBOR's IANA-registered tags.</p>
<h3 id="comparison-vs-cbor-2"><a class="header" href="#comparison-vs-cbor-2">Comparison vs. CBOR</a></h3>
<p>CBOR and MessagePack both aim to be efficient, schema-less binary alternatives to JSON with native binary data support, but differ in key aspects:</p>
<ul>
<li>
<p><strong>Encoding Details:</strong> CBOR supports indefinite-length arrays and maps (beneficial for streaming when total size is unknown), while MessagePack typically requires fixed collection counts.</p>
</li>
<li>
<p><strong>Standardization:</strong> CBOR is a formal IETF standard (RFC 8949) developed through consensus, whereas MessagePack uses a community-maintained specification. Many view CBOR as a more rigorous standard inspired by MessagePack.</p>
</li>
<li>
<p><strong>Extensibility:</strong> CBOR employs a standardized semantic tag system with an IANA registry for extended types (dates, URIs, bignums). MessagePack uses a simpler but less structured <code>ext</code> type where applications define tag meanings.</p>
</li>
<li>
<p><strong>Performance and Size:</strong> Comparisons vary by implementation and data. CBOR prioritizes small codec size (for constrained devices) alongside message compactness, while MessagePack focuses primarily on message size and speed.</p>
</li>
<li>
<p><strong>Conceptual Simplicity:</strong> MessagePack's shorter specification appears simpler, but CBOR's unification of types under its major type/additional info system and tag mechanism offers conceptual clarity.</p>
</li>
</ul>
<p>MessagePack pioneered the "binary JSON" concept to improve network performance, optimizing for complete, known data structures rather than streaming scenarios. Its widespread adoption demonstrates market demand. However, CBOR's formal standardization, streaming support through indefinite-length items, and standardized tag registry target broader applications, particularly for constrained devices and internet protocols.</p>
<h2 id="avro-mastering-schema-evolution"><a class="header" href="#avro-mastering-schema-evolution">Avro: Mastering Schema Evolution</a></h2>
<p>Apache Avro emerged from Apache Hadoop around 2009, designed specifically to address schema evolution challenges in large-scale data processing systems. In environments like Hadoop or Kafka data pipelines, where producers and consumers evolve independently, Avro enables seamless schema changes without breaking compatibility. It offers rich data structures and integrates easily with dynamic languages, without requiring code generation.</p>
<h3 id="design-and-encoding-3"><a class="header" href="#design-and-encoding-3">Design and Encoding</a></h3>
<p>Avro is <strong>schema-based</strong>, with schemas typically defined in JSON (though an alternative C-like IDL is available). A fundamental aspect of Avro is that the schema used to <em>write</em> data is always required to <em>read</em> that data. The binary encoding contains no field names or type identifiers—just concatenated field values in schema-defined order. This creates compact data that depends entirely on the schema for interpretation. Writer schemas typically accompany the data in file headers or through schema registry services. Avro also supports JSON encoding for debugging purposes.</p>
<p>Avro includes primitive types (<code>null</code>, <code>boolean</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>bytes</code>, <code>string</code>) and complex types (<code>record</code>, <code>enum</code>, <code>array</code>, <code>map</code>, <code>union</code>, <code>fixed</code>). Records contain named fields, arrays hold sequences, maps store key-value pairs (string keys only), and unions allow values of several specified types—commonly used for optional fields by including <code>null</code> (e.g., <code>["null", "string"]</code>).</p>
<p>Avro's strength lies in its well-defined <strong>schema evolution rules</strong>:</p>
<ul>
<li>Fields can be added or removed only if they have a default value, which readers use when the field is missing.</li>
<li>Field renaming uses <code>aliases</code> in the reader's schema to recognize data written with old names.</li>
<li>Type changes are generally forbidden, with limited exceptions (e.g., <code>int</code> to <code>long</code>).</li>
<li>For enums, adding symbols is backward compatible; removing or renaming breaks compatibility.</li>
</ul>
<p>When reading data with a different but compatible schema, Avro uses <strong>schema resolution</strong>—comparing field names (and aliases) and applying defaults to present data according to the reader's schema.</p>
<h3 id="pros-and-cons-3"><a class="header" href="#pros-and-cons-3">Pros and Cons</a></h3>
<p>Avro's main advantage is sophisticated schema evolution handling, making it ideal for systems with frequent or independent schema changes. JSON-defined schemas are relatively easy to manage. The binary encoding is compact since it omits field names and tags. Avro integrates well with dynamic languages when schemas are available at runtime. It has strong adoption within the Apache ecosystem, particularly Hadoop, Spark, and Kafka.</p>
<p>The primary disadvantage is requiring the writer's schema during deserialization, introducing schema management complexity and often necessitating a schema registry. While compact, some benchmarks suggest Avro may be slower than Protobuf in certain scenarios. The binary format is not human-readable, and developers must carefully follow schema evolution rules to maintain compatibility.</p>
<h3 id="comparison-vs-cbor-3"><a class="header" href="#comparison-vs-cbor-3">Comparison vs. CBOR</a></h3>
<p>Avro and CBOR represent fundamentally different schema philosophies. Avro <em>requires</em> schemas for reading and writing, with design centered on schema resolution. CBOR is <strong>schema-optional</strong> and self-describing; schemas (like CDDL) can validate but aren't needed for parsing.</p>
<p>This affects encoding: Avro omits field identifiers, relying on schema field order. CBOR includes type information and map keys, making it interpretable without external schemas.</p>
<p>Avro handles schema evolution explicitly through resolution rules, defaults, and aliases. CBOR's self-describing nature allows parsers to skip unknown data, but complex changes may require application-level logic or tag conventions. CBOR offers greater ad-hoc flexibility, while Avro enforces structure through schemas. Their ecosystems also differ—Avro dominates Big Data/Apache contexts, while CBOR prevails in IoT and IETF protocols.</p>
<p>Avro's design clearly optimizes for schema evolution in large-scale, long-lived data systems. By requiring the writer's schema at read time, it enables powerful resolution capabilities, allowing independent producer and consumer evolution. This contrasts with Protobuf's reliance on stable tag numbers and CBOR's schema-optional flexibility. The trade-off is explicit: Avro gains robust evolution and dynamic language integration, but requires schema management and produces data that's not self-contained.</p>
<h2 id="comparative-analysis-choosing-the-right-tool"><a class="header" href="#comparative-analysis-choosing-the-right-tool">Comparative Analysis: Choosing the Right Tool</a></h2>
<p>Having examined several binary serialization formats, it's clear that each addresses specific needs in the data interchange landscape. BSON optimizes for MongoDB's database operations. Protocol Buffers achieves high performance and type safety for RPC through mandatory schemas. MessagePack provides a compact binary alternative to JSON for network communication. Avro specializes in managing schema evolution for data pipelines. CBOR offers a standardized, binary-efficient encoding of the JSON data model with emphasis on constrained environments and extensibility.</p>
<p>No single format suits all use cases. The optimal choice depends on specific application requirements. Key decision factors include schema requirements (mandatory vs. optional), performance needs vs. flexibility, schema evolution complexity, ecosystem compatibility, and specialized features like native data types or standardized extensibility mechanisms.</p>
<p>The following table summarizes the key distinctions between these formats:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Feature</th><th style="text-align: left">CBOR</th><th style="text-align: left">BSON</th><th style="text-align: left">Protocol Buffers</th><th style="text-align: left">MessagePack</th><th style="text-align: left">Avro</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Origin/Primary Goal</strong></td><td style="text-align: left">IETF / Constrained Env Efficiency</td><td style="text-align: left">MongoDB / DB Storage &amp; Traversal</td><td style="text-align: left">Google / RPC Performance &amp; Size</td><td style="text-align: left">Furuhashi / JSON Alternative (Speed/Size)</td><td style="text-align: left">Apache / Schema Evolution</td></tr>
<tr><td style="text-align: left"><strong>Schema Handling</strong></td><td style="text-align: left">Optional</td><td style="text-align: left">Optional</td><td style="text-align: left">Required (<code>.proto</code> IDL)</td><td style="text-align: left">Optional</td><td style="text-align: left">Required (JSON or IDL)</td></tr>
<tr><td style="text-align: left"><strong>Schema Location</strong></td><td style="text-align: left">N/A or Separate (e.g., CDDL)</td><td style="text-align: left">N/A</td><td style="text-align: left">Separate (<code>.proto</code> file)</td><td style="text-align: left">N/A</td><td style="text-align: left">With Data (Files) or Registry</td></tr>
<tr><td style="text-align: left"><strong>Self-Describing?</strong></td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td><td style="text-align: left">No (Binary requires schema)</td></tr>
<tr><td style="text-align: left"><strong>Encoding Basis</strong></td><td style="text-align: left">JSON Model + Tags</td><td style="text-align: left">Extended JSON Model</td><td style="text-align: left">Schema Tags/Numbers</td><td style="text-align: left">JSON Model + <code>ext</code> type</td><td style="text-align: left">Schema Field Order</td></tr>
<tr><td style="text-align: left"><strong>Extensibility</strong></td><td style="text-align: left">IANA Tags</td><td style="text-align: left">Custom Types (DB-centric)</td><td style="text-align: left">Proto Extensions/Options</td><td style="text-align: left"><code>ext</code> type</td><td style="text-align: left">Schema Evolution Rules</td></tr>
<tr><td style="text-align: left"><strong>Schema Evolution</strong></td><td style="text-align: left">Implicit (Tags/Skipping)</td><td style="text-align: left">Implicit</td><td style="text-align: left">Explicit (Tag Stability)</td><td style="text-align: left">Implicit (<code>ext</code>/Skipping)</td><td style="text-align: left">Explicit (Resolution, Defaults, Aliases)</td></tr>
<tr><td style="text-align: left"><strong>Typical Size</strong></td><td style="text-align: left">Compact</td><td style="text-align: left">Variable (can be large)</td><td style="text-align: left">Very Compact</td><td style="text-align: left">Compact</td><td style="text-align: left">Compact (Binary)</td></tr>
<tr><td style="text-align: left"><strong>Typical Speed</strong></td><td style="text-align: left">Fast (esp. constrained codec)</td><td style="text-align: left">Fast Traversal (DB context)</td><td style="text-align: left">Very Fast (RPC context)</td><td style="text-align: left">Fast</td><td style="text-align: left">Fast</td></tr>
<tr><td style="text-align: left"><strong>Standardization</strong></td><td style="text-align: left">IETF RFC 8949</td><td style="text-align: left">De facto (MongoDB)</td><td style="text-align: left">De facto (Google)</td><td style="text-align: left">Community Spec</td><td style="text-align: left">Apache Project</td></tr>
<tr><td style="text-align: left"><strong>Primary Use Cases</strong></td><td style="text-align: left">IoT, CoAP, COSE, Security, Deterministic Needs</td><td style="text-align: left">MongoDB</td><td style="text-align: left">RPC, Microservices, Internal Comms</td><td style="text-align: left">Network Comms, Caching, RPC</td><td style="text-align: left">Big Data (Hadoop, Kafka), Data Pipelines</td></tr>
</tbody></table>
</div>
<p><em>Note: Size and speed comparisons are general tendencies; actual performance depends heavily on data structure, implementation quality, and specific workload.</em></p>
<p>This comparison highlights the complex trade-offs between formats. Protocol Buffers excels when validation, compactness, and RPC performance are critical in environments where schema management is feasible. Avro offers superior schema evolution capabilities for large-scale data pipelines, despite requiring schema distribution mechanisms. BSON serves specialized needs within the MongoDB ecosystem. MessagePack provides an efficient binary alternative to JSON for network communication, though with potential streaming limitations. CBOR stands out when IETF standardization, constrained device support, binary-efficient JSON encoding, standardized extensibility, or deterministic encoding are priorities.</p>
<h2 id="why-choose-cbor"><a class="header" href="#why-choose-cbor">Why Choose CBOR?</a></h2>
<p>Based on the preceding comparisons, CBOR presents a unique combination of features that make it the preferred choice in several specific contexts:</p>
<ul>
<li>
<p><strong>JSON Data Model Fidelity in Binary:</strong> CBOR provides a direct binary encoding for the familiar JSON data model. This lowers the adoption barrier for developers already comfortable with JSON, unlike formats requiring different structural concepts or mandatory schemas.</p>
</li>
<li>
<p><strong>Efficiency for Constrained Environments:</strong> CBOR was explicitly designed for the Internet of Things and constrained environments. This yields encoders and decoders with small code footprints, efficient processing, and significantly reduced message sizes compared to JSON—all critical for resource-limited devices.</p>
</li>
<li>
<p><strong>IETF Standardization and Integration:</strong> As an IETF standard (RFC 8949), CBOR benefits from rigorous review and a stable specification. It integrates within the broader internet protocol ecosystem, serving as a payload format in CoAP and forming the basis of COSE (CBOR Object Signing and Encryption), crucial for security in constrained environments.</p>
</li>
<li>
<p><strong>Standardized Extensibility via Tags:</strong> CBOR includes a well-defined mechanism for extending the basic data model using semantic tags. These IANA-registered tags provide standardized ways to represent richer semantics while allowing basic decoders to skip tags they don't understand. This offers a more structured approach than MessagePack's <code>ext</code> type.</p>
</li>
<li>
<p><strong>Schema-Optional Flexibility:</strong> CBOR remains schema-optional like JSON. Data is self-describing, allowing for parsing without predefined schemas—advantageous for evolving systems or ad-hoc data exchange. When validation is needed, external schema languages like CDDL (RFC 8610) can be employed.</p>
</li>
<li>
<p><strong>Native Binary Data Support:</strong> CBOR includes a native byte string type, allowing efficient representation of binary data without inefficient text encodings like Base64 required by JSON.</p>
</li>
<li>
<p><strong>Deterministic Encoding Potential:</strong> RFC 8949 Section 4.2 explicitly defines rules for deterministic encoding, ensuring the same data structure always serializes to identical byte sequences—critical for cryptographic applications where reproducibility is essential.</p>
</li>
</ul>
<p>While CBOR offers these advantages, it's not human-readable like JSON. In high-performance RPC scenarios with fixed schemas, optimized Protobuf implementations might offer better raw performance. Though its ecosystem is growing, particularly in IoT and security domains, it might not have the breadth of tooling found for JSON or Protobuf in every application area.</p>
<p>CBOR occupies a compelling position in the serialization landscape—a standardized, extensible, and efficient binary format built on the widely understood JSON data model. Its design for constrained environments, IETF protocol integration, and support for deterministic encoding make it well-suited for IoT, secure communication, and verifiable data structures, all without imposing the mandatory schemas found in Protocol Buffers or Avro.</p>
<h2 id="cbor-as-a-foundation-for-blockchain-commons"><a class="header" href="#cbor-as-a-foundation-for-blockchain-commons">CBOR as a Foundation for Blockchain Commons</a></h2>
<p>Blockchain Commons' specifications, including dCBOR (Deterministic CBOR) and Gordian Envelope, build directly on CBOR primarily due to its deterministic encoding capabilities.</p>
<p>Gordian Envelope, a "smart documents" format containing cryptographic material like keys and verifiable credentials, relies on cryptographic hashing for data integrity and selective disclosure. These functions require deterministic serialization—identical semantic data must produce identical byte sequences when encoded.</p>
<p>CBOR's RFC 8949 explicitly defines a "Deterministically Encoded CBOR" profile that mandates preferred integer encodings and lexicographically ordered map keys. This standardized approach to determinism gives CBOR a significant advantage over JSON (which lacks universal canonicalization) and other binary formats where determinism isn't prioritized.</p>
<p>While RFC 8949 established deterministic guidelines, Blockchain Commons identified remaining ambiguities that could lead to inconsistent implementations. Their dCBOR application profile, documented as an IETF Internet-Draft, further refines these rules by rejecting duplicate map keys and establishing precise numeric reduction rules to ensure values like 10, 10.0, and 10.00 encode identically.</p>
<p>Beyond determinism, CBOR offered additional advantages: structured binary representation suitable for cryptographic data, conciseness, standardized tag-based extensibility, IETF standardization, compatibility with constrained environments (important for hardware wallets), and platform independence.</p>
<p>CBOR thus provided the standardized deterministic foundation that Blockchain Commons refined through dCBOR to build secure, interoperable systems like Gordian Envelope—topics covered in later chapters.</p>
<h2 id="conclusion-a-diverse-binary-ecosystem"><a class="header" href="#conclusion-a-diverse-binary-ecosystem">Conclusion: A Diverse Binary Ecosystem</a></h2>
<p>The evolution from XML to binary formats like BSON, Protocol Buffers, MessagePack, Avro, and CBOR reflects a landscape where no single "best" serialization format exists. Each represents specific design choices optimized for particular contexts.</p>
<ul>
<li><strong>BSON</strong> prioritizes efficient storage and traversal in MongoDB, extending JSON with specialized types at the cost of compactness and broader interoperability.</li>
<li><strong>Protocol Buffers</strong> achieves performance and compactness for RPC through mandatory schemas and code generation, trading flexibility and self-description.</li>
<li><strong>MessagePack</strong> offers a compact binary JSON alternative for network communication, despite potential streaming limitations.</li>
<li><strong>Avro</strong> excels at schema evolution in data pipelines, requiring schema availability but providing robust compatibility features.</li>
<li><strong>CBOR</strong> delivers an IETF-standardized, binary-efficient JSON encoding that balances flexibility with performance, offering standardized extensibility and serving constrained environments and deterministic encoding needs.</li>
</ul>
<p>These diverse formats will continue to coexist, with developers selecting tools that match their project requirements. CBOR's position as a standardized, efficient format based on the JSON model ensures its relevance, particularly for IoT, secure systems, and verifiable data structures.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-practical-introduction-to-cbor"><a class="header" href="#a-practical-introduction-to-cbor">A Practical Introduction to CBOR</a></h1>
<h2 id="from-comparison-to-construction"><a class="header" href="#from-comparison-to-construction">From Comparison to Construction</a></h2>
<p>In the previous chapter, we explored the diverse landscape of binary serialization formats, comparing CBOR to its contemporaries like BSON, Protocol Buffers, MessagePack, and Avro. We saw how each format emerged from different needs and design philosophies, resulting in distinct trade-offs between schema requirements, performance, compactness, and features like schema evolution. CBOR, standardized by the IETF as <a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC 8949</a>, carved out its niche by providing a binary encoding based on the familiar JSON data model, optimized for efficiency (especially in constrained environments like IoT), extensibility, and standardization within internet protocols.</p>
<p>Having understood <em>why</em> CBOR exists and how it relates to other formats, we now shift our focus to <em>how</em> it works. This chapter provides a practical introduction to the core mechanics of CBOR encoding. The goal is not to replicate the exhaustive detail of RFC 8949, but rather to quickly equip engineers with a solid working understanding of how fundamental data types are represented in CBOR.</p>
<blockquote>
<p><strong>⚠️ NOTE:</strong> Wherever this book may conflict with RFC 8949, the RFC is authoritative. This book is intended to be a practical guide, not a definitive reference. We will also use the term "CBOR" interchangeably to refer to both the encoding and the data model, unless otherwise specified.</p>
</blockquote>
<p>We will progressively build up understanding by examining common data structures, comparing their representation in:</p>
<ul>
<li><strong>JSON:</strong> The familiar text-based format.</li>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-cbor-edn-literals/"><strong>CBOR Diagnostic Notation:</strong></a> A human-readable text format, similar to JSON but extended for CBOR's features, used for documentation and debugging.</li>
<li><strong>Hexadecimal CBOR:</strong> The actual binary representation shown as hexadecimal bytes, which is how CBOR data is transmitted or stored.</li>
</ul>
<p>We will focus on the most common, definite-length encodings and the concept of "preferred serialization" – using the shortest possible form where choices exist.2 Advanced topics such as semantic tags (Major Type 6), indefinite-length encoding, full deterministic encoding rules (beyond preferred serialization), schema definition with CDDL, and CBOR sequences will be introduced in later chapters. By the end of this chapter, you should be able to look at simple CBOR byte sequences and understand the data they represent.</p>
<blockquote>
<p><strong>✅ TIP:</strong> The <a href="https://cbor.me/">CBOR Playground</a> is an excellent tool if you would like to follow along with the examples, converting CBOR Diagnostic Notation to binary and back.</p>
</blockquote>
<h2 id="the-core-encoding-major-types-and-additional-information"><a class="header" href="#the-core-encoding-major-types-and-additional-information">The Core Encoding: Major Types and Additional Information</a></h2>
<p>At the heart of CBOR's encoding lies a simple yet powerful structure contained within the first byte (and potentially subsequent bytes) of any data item. This initial byte conveys two crucial pieces of information:</p>
<pre><code>┌────┬────┬────┬────┬────┬────┬────┬────┐
│  7 │  6 │  5 │  4 │  3 │  2 │  1 │  0 │
├────┴────┴────┼────┴────┴────┴────┴────┤
│  MAJOR TYPE  │ ADDITIONAL INFORMATION │
└──────────────┴────────────────────────┘
</code></pre>
<ol>
<li><strong>Major Type (MT):</strong> The high-order 3 bits (bits 5, 6, and 7) define the general category of the data item. There are 8 major types (0 through 7).</li>
<li><strong>Additional Information (AI):</strong> The low-order 5 bits (bits 0 through 4) provide specific details about the data item, whose meaning depends on the Major Type. This can range from encoding the entire value directly (for small integers or simple constants) to indicating the length of subsequent data or specifying the precision of a floating-point number.</li>
</ol>
<p>This initial byte structure allows a CBOR decoder to immediately understand the fundamental type and size characteristics of the data item it is encountering, enabling efficient parsing without requiring a predefined schema. All multi-byte numerical values in CBOR are encoded in network byte order (big-endian).</p>
<p>Let's break down the Major Types and see how the Additional Information works for each:</p>
<div class="table-wrapper"><table><thead><tr><th>Major Type</th><th>Bits (MT)</th><th>Meaning</th><th>Notes</th></tr></thead><tbody>
<tr><td>0</td><td><code>000</code></td><td>Unsigned Integer</td><td>Values from <code>0</code> to <code>2⁶⁴−1</code></td></tr>
<tr><td>1</td><td><code>001</code></td><td>Negative Integer</td><td>Encodes <code>-1 - n</code> where <code>n</code> is the encoded value</td></tr>
<tr><td>2</td><td><code>010</code></td><td>Byte String</td><td>Sequence of raw bytes</td></tr>
<tr><td>3</td><td><code>011</code></td><td>Text String</td><td>UTF-8 encoded string</td></tr>
<tr><td>4</td><td><code>100</code></td><td>Array</td><td>Ordered list of data items</td></tr>
<tr><td>5</td><td><code>101</code></td><td>Map</td><td>Pairs of keys and values</td></tr>
<tr><td>6</td><td><code>110</code></td><td>Tag</td><td>Semantic qualifier for the following item</td></tr>
<tr><td>7</td><td><code>111</code></td><td>Simple Values / Floating-Point</td><td>Booleans, null, undefined, floats, etc.</td></tr>
</tbody></table>
</div>
<p>The Additional Information values (0-31) modify the meaning of the Major Type:</p>
<div class="table-wrapper"><table><thead><tr><th>AI Value</th><th>Bits (AI)</th><th>Meaning</th></tr></thead><tbody>
<tr><td>0–23</td><td><code>00000</code>–<code>10111</code></td><td>Value or length is encoded directly (literal value)</td></tr>
<tr><td>24</td><td><code>11000</code></td><td>Next 1 byte contains the value or length (uint8)</td></tr>
<tr><td>25</td><td><code>11001</code></td><td>Next 2 bytes contain the value or length (uint16)</td></tr>
<tr><td>26</td><td><code>11010</code></td><td>Next 4 bytes contain the value or length (uint32)</td></tr>
<tr><td>27</td><td><code>11011</code></td><td>Next 8 bytes contain the value or length (uint64)</td></tr>
<tr><td>28–30</td><td><code>11100</code>–<code>11110</code></td><td>Reserved for future use</td></tr>
<tr><td>31</td><td><code>11111</code></td><td>Indefinite-length indicator or special “break”</td></tr>
</tbody></table>
</div>
<p>AI values 0-27 are used for encoding the length of the data item or the value itself, with 24-27 called the <code>1+1</code>, <code>1+2</code>, <code>1+4</code>, and <code>1+8</code> encodings, respectively. The AI value 31 is used for indefinite-length items, which we will cover in a later chapter.</p>
<pre><code>    ┌──────┐
1   │ 0-23 │
    └──────┘
    ┌────┐┌────┐
1+1 │ 24 ││    │
    └────┘└────┘
    ┌────┐┌────┬────┐
1+2 │ 25 ││    │    │
    └────┘└────┴────┘
    ┌────┐┌────┬────┬────┬────┐
1+4 │ 26 ││    │    │    │    │
    └────┘└────┴────┴────┴────┘
    ┌────┐┌────┬────┬────┬────┬────┬────┬────┬────┐
1+8 │ 27 ││    │    │    │    │    │    │    │    │
    └────┘└────┴────┴────┴────┴────┴────┴────┴────┘
</code></pre>
<p>Understanding this MT/AI structure is the key to decoding CBOR. We will now see it in action as we explore specific data types. <a href="part_1/../appendices/cbor_header_bytes.html">An appendix</a> contains a table of all 256 possible Major Type and Additional Information combinations.</p>
<h2 id="simple-scalar-types-integers-booleans-and-null"><a class="header" href="#simple-scalar-types-integers-booleans-and-null">Simple Scalar Types: Integers, Booleans, and Null</a></h2>
<p>Let's start with the simplest data types common to JSON and CBOR: integers, booleans, and null.</p>
<h3 id="integers-major-types-0--1"><a class="header" href="#integers-major-types-0--1">Integers (Major Types 0 &amp; 1)</a></h3>
<p>CBOR distinguishes between unsigned integers (Major Type 0) and negative integers (Major Type 1). The Additional Information determines how the integer's value (or <em>argument</em>) is encoded.2</p>
<ul>
<li><strong>Small Integers (0-23):</strong> If the unsigned integer is between 0 and 23 inclusive, it's encoded directly in the Additional Information bits of the initial byte (Major Type 0).</li>
<li><strong>Larger Integers:</strong> For values 24 or greater, the Additional Information takes the value 24, 25, 26, or 27, indicating that the actual integer value follows in the next 1, 2, 4, or 8 bytes, respectively, in network byte order (big-endian).</li>
<li><strong>Negative Integers:</strong> Encoded using Major Type 1. The value encoded is `−1 − argument. So, an argument of 0 represents the integer -1, an argument of 9 represents -10, and so on. The argument itself is encoded using the same rules as unsigned integers (AI 0-23 for arguments 0-23, AI 24-27 for larger arguments).</li>
</ul>
<p>Preferred Serialization: CBOR allows multiple ways to encode the same number (e.g., the number 10 could theoretically be encoded using 1, 2, 4, or 8 bytes following an initial byte with AI 24, 25, 26, or 27). However, the standard strongly recommends <em>preferred serialization</em>, which means always using the shortest possible form. This avoids ambiguity and unnecessary padding. For non-negative integers, this means:</p>
<div class="table-wrapper"><table><thead><tr><th>Value Range</th><th>AI Value</th><th>Bytes Used After Initial Byte</th><th>Total Encoding Size</th></tr></thead><tbody>
<tr><td>0–23</td><td>0–23</td><td>0</td><td>1 byte</td></tr>
<tr><td>24–255</td><td>24</td><td>1</td><td>2 bytes</td></tr>
<tr><td>256–65,535</td><td>25</td><td>2</td><td>3 bytes</td></tr>
<tr><td>65,536–4,294,967,295</td><td>26</td><td>4</td><td>5 bytes</td></tr>
<tr><td>4,294,967,296–2⁶⁴−1</td><td>27</td><td>8</td><td>9 bytes</td></tr>
</tbody></table>
</div>
<p>The same principle applies to the argument for negative integers.</p>
<p><strong>Examples (Preferred Serialization):</strong></p>
<div class="table-wrapper"><table><thead><tr><th>JSON</th><th>CBOR Diagnostic</th><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>0</code></td><td><code>0</code></td><td><code>00</code></td><td>0</td><td>0</td><td>Value 0 directly encoded</td></tr>
<tr><td><code>10</code></td><td><code>10</code></td><td><code>0a</code></td><td>0</td><td>10</td><td>Value 10 directly encoded</td></tr>
<tr><td><code>23</code></td><td><code>23</code></td><td><code>17</code></td><td>0</td><td>23</td><td>Value 23 directly encoded</td></tr>
<tr><td><code>24</code></td><td><code>24</code></td><td><code>18 18</code></td><td>0</td><td>24</td><td>Value in next byte; <code>0x18</code> = 24</td></tr>
<tr><td><code>100</code></td><td><code>100</code></td><td><code>18 64</code></td><td>0</td><td>24</td><td>Value in next byte; <code>0x64</code> = 100</td></tr>
<tr><td><code>1000</code></td><td><code>1000</code></td><td><code>19 03e8</code></td><td>0</td><td>25</td><td>Value in next 2 bytes; <code>0x03e8</code> = 1000</td></tr>
<tr><td><code>1000000</code></td><td><code>1000000</code></td><td><code>1a 000f4240</code></td><td>0</td><td>26</td><td>Value in next 4 bytes; <code>0x000f4240</code> = 1,000,000</td></tr>
<tr><td><code>-1</code></td><td><code>-1</code></td><td><code>20</code></td><td>1</td><td>0</td><td>-1 = -1 - 0</td></tr>
<tr><td><code>-10</code></td><td><code>-10</code></td><td><code>29</code></td><td>1</td><td>9</td><td>-10 = -1 - 9</td></tr>
<tr><td><code>-100</code></td><td><code>-100</code></td><td><code>38 63</code></td><td>1</td><td>24</td><td>Argument in next byte; <code>0x63</code> = 99 → -1 - 99 = -100</td></tr>
<tr><td><code>-1000</code></td><td><code>-1000</code></td><td><code>39 03e7</code></td><td>1</td><td>25</td><td>Argument in next 2 bytes; <code>0x03e7</code> = 999 → -1000</td></tr>
</tbody></table>
</div>
<h3 id="booleans-and-null-major-type-7"><a class="header" href="#booleans-and-null-major-type-7">Booleans and Null (Major Type 7)</a></h3>
<p>CBOR uses Major Type 7 for various simple values and floating-point numbers. The boolean values <code>true</code> and <code>false</code>, and the <code>null</code> value, have specific, fixed Additional Information values.</p>
<div class="table-wrapper"><table><thead><tr><th>JSON</th><th>CBOR Diagnostic</th><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>f4</code></td><td>7</td><td>20</td><td>Simple value: <code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>f5</code></td><td>7</td><td>21</td><td>Simple value: <code>true</code></td></tr>
<tr><td><code>null</code></td><td><code>null</code></td><td><code>f6</code></td><td>7</td><td>22</td><td>Simple value: <code>null</code></td></tr>
</tbody></table>
</div>
<p>CBOR also defines an <code>undefined</code> simple value (<code>f7</code>, MT 7, AI 23), which doesn't have a direct equivalent in standard JSON but may be useful in certain protocols.</p>
<h2 id="strings-bytes-and-text"><a class="header" href="#strings-bytes-and-text">Strings: Bytes and Text</a></h2>
<p>CBOR has distinct types for byte strings (arbitrary sequences of bytes) and text strings (sequences of Unicode characters encoded as UTF-8). This is a key advantage over JSON, which lacks native binary support and typically requires base64 encoding for binary data.</p>
<h3 id="byte-strings-major-type-2"><a class="header" href="#byte-strings-major-type-2">Byte Strings (Major Type 2)</a></h3>
<p>Byte strings use Major Type 2. The Additional Information encodes the length of the string in bytes, following the same rules as unsigned integers (AI 0-23 for lengths 0-23, AI 24-27 + subsequent bytes for longer lengths). The raw bytes of the string immediately follow the initial byte(s).</p>
<h3 id="examples-definite-length-byte-strings"><a class="header" href="#examples-definite-length-byte-strings">Examples: Definite Length Byte Strings</a></h3>
<p>In CBOR diagnostic notation, byte strings are represented using hexadecimal encoding prefixed with <code>h</code> and enclosed in single quotes.</p>
<div class="table-wrapper"><table><thead><tr><th>Description</th><th>CBOR Diagnostic</th><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td>Empty byte string</td><td><code>h''</code></td><td><code>40</code></td><td>2</td><td>0</td><td>Length 0 bytes</td></tr>
<tr><td>Bytes <code>0x01, 0x02, 0x03</code></td><td><code>h'010203'</code></td><td><code>43 010203</code></td><td>2</td><td>3</td><td>Length 3 bytes; followed by <code>01 02 03</code></td></tr>
<tr><td>24 bytes (e.g., all <code>0x00</code>)</td><td><code>h'…'</code></td><td><code>58 18 …</code></td><td>2</td><td>24</td><td>Length in next byte; <code>0x18</code> = 24; followed by 24 bytes</td></tr>
</tbody></table>
</div>
<h3 id="examples-definite-length-text-strings"><a class="header" href="#examples-definite-length-text-strings">Examples: Definite Length Text Strings</a></h3>
<p>Text strings use Major Type 3 and are explicitly defined as UTF-8 encoded Unicode strings. The Additional Information (AI) specifies the length in <em>bytes</em> of the UTF-8 encoding, <em>not</em> the number of Unicode characters, which can (and often are) different. In diagnostic notation, text strings are enclosed in double quotes (like JSON).</p>
<div class="table-wrapper"><table><thead><tr><th>JSON</th><th>CBOR Diagnostic</th><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>""</code></td><td><code>""</code></td><td><code>60</code></td><td>3</td><td>0</td><td>Empty string; length 0</td></tr>
<tr><td><code>"a"</code></td><td><code>"a"</code></td><td><code>61 61</code></td><td>3</td><td>1</td><td>Length 1 byte; <code>0x61</code> = <code>'a'</code></td></tr>
<tr><td><code>"hello"</code></td><td><code>"hello"</code></td><td><code>65 68656c6c6f</code></td><td>3</td><td>5</td><td>Length 5 bytes; <code>68 65 6c 6c 6f</code> = <code>'hello'</code></td></tr>
<tr><td><code>"IETF"</code></td><td><code>"IETF"</code></td><td><code>64 49455446</code></td><td>3</td><td>4</td><td>Length 4 bytes; <code>49 45 54 46</code> = <code>'IETF'</code></td></tr>
<tr><td><code>"ü"</code></td><td><code>"ü"</code></td><td><code>62 c3bc</code></td><td>3</td><td>2</td><td>Length 2 bytes; <code>c3 bc</code> is UTF-8 for <code>'ü'</code></td></tr>
<tr><td><code>"你好"</code></td><td><code>"你好"</code></td><td><code>66 e4bda0e5a5bd</code></td><td>3</td><td>6</td><td>Length 6 bytes; <code>e4 bd a0 e5 a5 bd</code> is UTF-8 for <code>'你好'</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>⚠️ NOTE:</strong> that CBOR does not perform string escaping like JSON does (e.g., for quotes or backslashes). Since the length is provided upfront, the decoder knows exactly how many bytes constitute the string content. So the string <code>"Hello"</code>, <em>including</em> the quotes is seven bytes long, and the CBOR encoding would be eight bytes:</p>
</blockquote>
<pre><code>67               # Text(7 bytes)
  2248656C6C6F22 # "Hello"
</code></pre>
<p>If you use the CBOR Playground to convert this to Diagnostic Notation, you'll get:</p>
<pre><code>"\"Hello\""
</code></pre>
<p>So backslash escapes are part of CBOR Diagnostic Notation, but <em>not</em> part of the CBOR encoding itself.</p>
<h2 id="collections-arrays-and-maps"><a class="header" href="#collections-arrays-and-maps">Collections: Arrays and Maps</a></h2>
<p>CBOR supports ordered sequences of items (arrays) and unordered key-value pairs (maps), mirroring JSON's structures but with some key differences. This section focuses on definite-length collections, where the number of elements or pairs is known upfront.</p>
<h3 id="arrays-major-type-4"><a class="header" href="#arrays-major-type-4">Arrays (Major Type 4)</a></h3>
<p>Arrays use Major Type 4. The Additional Information encodes the number of data items (elements) contained within the array, using the same encoding rules as unsigned integers (AI 0-23 for counts 0-23, AI 24-27 + subsequent bytes for larger counts). The encoded data items follow the initial byte(s) in sequence.2</p>
<p>Like JSON, CBOR Diagnostic Notation uses square brackets <code>[]</code> with comma-separated elements.</p>
<h3 id="examples-definite-length-arrays"><a class="header" href="#examples-definite-length-arrays">Examples: Definite Length Arrays</a></h3>
<p>Arrays in CBOR use Major Type 4. The Additional Information (AI) specifies the number of elements in the array. The elements are encoded sequentially after the initial byte.</p>
<div class="table-wrapper"><table><thead><tr><th>JSON</th><th>CBOR Diagnostic</th><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>[]</code></td><td><code>[]</code></td><td><code>80</code></td><td>4</td><td>0</td><td>Array with 0 elements</td></tr>
<tr><td><code>[1, 2, 3]</code></td><td><code>[1, 2, 3]</code></td><td><code>83 01 02 03</code></td><td>4</td><td>3</td><td>Array with 3 elements; <code>01</code>, <code>02</code>, <code>03</code> encode integers 1, 2, and 3</td></tr>
<tr><td><code>[true, null]</code></td><td><code>[true, null]</code></td><td><code>82 f5 f6</code></td><td>4</td><td>2</td><td>Array with 2 elements; <code>f5</code> = true, <code>f6</code> = null</td></tr>
<tr><td><em>no equivalent</em></td><td><code>["a", h'01']</code></td><td><code>82 61 61 41 01</code></td><td>4</td><td>2</td><td>Array with 2 elements; <code>61 61</code> = "a", <code>41 01</code> = byte string <code>h'01'</code></td></tr>
</tbody></table>
</div>
<h3 id="maps-major-type-5"><a class="header" href="#maps-major-type-5">Maps (Major Type 5)</a></h3>
<p>Maps (also known variously as <em>dictionaries</em> or <em>associative arrays</em>) use Major Type 5. The Additional Information encodes the number of <em>pairs</em> in the map (not the total number of keys and values). Again, the encoding follows the rules for unsigned integers. The key-value pairs follow the initial byte(s), with each key immediately followed by its corresponding value (key1, value1, key2, value2,...).2</p>
<p>A significant difference from JSON is that CBOR map keys can be <em>any</em> CBOR data type (integers, strings, arrays, etc.), not just text strings.</p>
<h3 id="examples-definite-length-maps"><a class="header" href="#examples-definite-length-maps">Examples: Definite Length Maps</a></h3>
<p>CBOR maps use Major Type 5. The Additional Information (AI) specifies the number of key-value pairs. Keys and values follow in alternating sequence. Diagnostic notation uses curly braces <code>{}</code> with comma-separated <code>key: value</code> pairs.</p>
<div class="table-wrapper"><table><thead><tr><th>JSON</th><th>CBOR Diagnostic</th><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{}</code></td><td><code>{}</code></td><td><code>a0</code></td><td>5</td><td>0</td><td>Map with 0 key-value pairs</td></tr>
<tr><td><code>{"a": 1}</code></td><td><code>{"a": 1}</code></td><td><code>a1 61 61 01</code></td><td>5</td><td>1</td><td>1 pair: key <code>"a"</code> (<code>61 61</code>), value <code>1</code> (<code>01</code>)</td></tr>
<tr><td><code>{"a": 1, "b": 2}</code></td><td><code>{"a": 1, "b": 2}</code></td><td><code>a2 61 61 01 61 62 02</code></td><td>5</td><td>2</td><td>2 pairs: <code>"a"</code>→<code>1</code>, <code>"b"</code>→<code>2</code>; encoded in sequence</td></tr>
<tr><td><em>no equivalent</em></td><td><code>{1: "one", 2: "two"}</code></td><td><code>a2 01 63 6f6e65 02 63 74776f</code></td><td>5</td><td>2</td><td>2 pairs: <code>1</code>→<code>"one"</code>, <code>2</code>→<code>"two"</code>; strings encoded as <code>63</code> (length 3)</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>⚠️ NOTE:</strong> Although map keys have to be serialized in <em>some</em> order, CBOR maps are considered <em>orderless</em>. This means that CBOR encoders will typically not treat the order of pairs as significant, and neither should you. Similarly, nothing in the CBOR specification requires that map keys be <em>unique</em>. Theoretically you could have multiple pairs with the same key, but many implementations will simply choose to keep one of the pairs and throw away the other. You should therefore never rely on the behavior of particular implementations regarding the order of keys or duplicate keys. Determinisic encoding profiles we'll discuss later in this book will address these ambiguities.</p>
</blockquote>
<h2 id="floating-point-and-other-simple-values-major-type-7"><a class="header" href="#floating-point-and-other-simple-values-major-type-7">Floating-Point and Other Simple Values (Major Type 7)</a></h2>
<p>Major Type 7 serves as a catch-all for simple values (like <code>true</code>, <code>false</code>, and <code>null</code>, covered earlier) and floating-point numbers.</p>
<h3 id="floating-point-numbers-major-type-7"><a class="header" href="#floating-point-numbers-major-type-7">Floating-Point Numbers (Major Type 7)</a></h3>
<p>CBOR supports <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754</a> binary floating-point numbers in half, single, and double precision. The Additional Information (AI) field specifies the precision, and the bytes that follow are in network byte order (big-endian).</p>
<div class="table-wrapper"><table><thead><tr><th>Precision</th><th>AI Value</th><th>Bytes After Initial Byte</th><th>Total Size</th><th>Notes</th></tr></thead><tbody>
<tr><td>Half-precision</td><td>25</td><td>2 bytes</td><td>3 bytes</td><td>16-bit float (<code>float16</code>)</td></tr>
<tr><td>Single-precision</td><td>26</td><td>4 bytes</td><td>5 bytes</td><td>32-bit float (<code>float32</code>)</td></tr>
<tr><td>Double-precision</td><td>27</td><td>8 bytes</td><td>9 bytes</td><td>64-bit float (<code>float64</code>)</td></tr>
</tbody></table>
</div>
<h4 id="preferred-serialization-for-floating-point-numbers"><a class="header" href="#preferred-serialization-for-floating-point-numbers">Preferred Serialization for Floating-Point Numbers</a></h4>
<p>Similar to integers, preferred serialization for floating point values dictates using the shortest floating-point representation that can exactly encode a given value. If a number can be precisely represented in <code>float16</code>, it is encoded that way instead of using <code>float32</code> or <code>float64</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>CBOR Diagnostic</th><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>0.0</code></td><td><code>0.0</code></td><td><code>f9 00 00</code></td><td>7</td><td>25</td><td>Half-precision (<code>float16</code>); zero</td></tr>
<tr><td><code>1.0</code></td><td><code>1.0</code></td><td><code>f9 3c 00</code></td><td>7</td><td>25</td><td>Half-precision; <code>0x3c00</code> encodes <code>1.0</code></td></tr>
<tr><td><code>-1.5</code></td><td><code>-1.5</code></td><td><code>f9 be 00</code></td><td>7</td><td>25</td><td>Half-precision; <code>0xbe00</code> encodes <code>-1.5</code></td></tr>
<tr><td><code>10000.0</code></td><td><code>10000.0</code></td><td><code>fa 47 c3 50 00</code></td><td>7</td><td>26</td><td>Single-precision; <code>0x47c35000</code> encodes <code>10000.0</code></td></tr>
<tr><td><code>1.1</code></td><td><code>1.1</code></td><td><code>fb 3f f1 99 99 99 99 99 9a</code></td><td>7</td><td>27</td><td>Double-precision; only this width exactly encodes <code>1.1</code></td></tr>
<tr><td><code>3.14159</code></td><td><code>3.14159</code></td><td><code>fb 40 09 21 f9 f0 1b 86 6e</code></td><td>7</td><td>27</td><td>Double-precision; needed to preserve exact π approximation</td></tr>
<tr><td><code>1.0e+300</code></td><td><code>1.0e+300</code></td><td><code>fb 7e 37 e4 3c 88 00 75 9c</code></td><td>7</td><td>27</td><td>Double-precision; high magnitude</td></tr>
<tr><td><code>Infinity</code></td><td><code>Infinity</code></td><td><code>f9 7c 00</code></td><td>7</td><td>25</td><td>Half-precision encoding for positive infinity</td></tr>
<tr><td><code>NaN</code></td><td><code>NaN</code></td><td><code>f9 7e 00</code></td><td>7</td><td>25</td><td>Half-precision encoding for NaN (payload may vary)</td></tr>
</tbody></table>
</div>
<h3 id="other-simple-values"><a class="header" href="#other-simple-values">Other Simple Values</a></h3>
<p>Besides <code>false</code>, <code>true</code>, <code>null</code>, and <code>undefined</code> (AI 20-23), Major Type 7 allows for simple values 0 through 19 (encoded directly with AI 0-19) and 32 through 255 (encoded using AI 24 followed by one byte). The specific meanings of these simple values are generally undefined by the core CBOR specification and are reserved for specific profiles or applications.</p>
<div class="table-wrapper"><table><thead><tr><th>Value Range</th><th>Encoding Method</th><th>Semantics</th></tr></thead><tbody>
<tr><td>0–19</td><td>MT 7, AI = value (1-byte)</td><td>Reserved</td></tr>
<tr><td>20</td><td>MT 7, AI = 20 (0xf4)</td><td><code>false</code></td></tr>
<tr><td>21</td><td>MT 7, AI = 21 (0xf5)</td><td><code>true</code></td></tr>
<tr><td>22</td><td>MT 7, AI = 22 (0xf6)</td><td><code>null</code></td></tr>
<tr><td>23</td><td>MT 7, AI = 23 (0xf7)</td><td><code>undefined</code></td></tr>
<tr><td>24</td><td>MT 7, AI = 24, followed by 1 byte</td><td>Reserved</td></tr>
<tr><td>25–27</td><td>MT 7, AI = 25–27, followed by 2–8 bytes</td><td>Floating-point numbers</td></tr>
<tr><td>28–30</td><td>MT 7, AI = 28–30</td><td>Reserved</td></tr>
<tr><td>31</td><td>MT 7, AI = 31 (0xff)</td><td>"break" stop code</td></tr>
<tr><td>32–255</td><td>MT 7, AI = 24, followed by 1 byte (value)</td><td>Reserved</td></tr>
</tbody></table>
</div>
<p><strong>Notes:</strong></p>
<ul>
<li><strong>Values 0–19</strong> are currently unassigned and reserved for future use.</li>
<li><strong>Values 20–23</strong> represent the simple values <code>false</code>, <code>true</code>, <code>null</code>, and <code>undefined</code>, respectively.</li>
<li><strong>Value 24</strong> is reserved and not used for encoding simple values.</li>
<li><strong>Values 25–27</strong> are used to encode floating-point numbers of different precisions:
<ul>
<li>25: Half-precision (16-bit)</li>
<li>26: Single-precision (32-bit)</li>
<li>27: Double-precision (64-bit)</li>
</ul>
</li>
<li><strong>Values 28–30</strong> are reserved for future extensions.</li>
<li><strong>Value 31</strong> is used as a "break" stop code to indicate the end of an indefinite-length item.</li>
<li><strong>Values 32–255</strong> are unassigned and available for application-specific use.</li>
</ul>
<p>For the most up-to-date information, refer to the <a href="https://www.iana.org/assignments/cbor-simple-values/cbor-simple-values.xhtml">IANA CBOR Simple Values registry</a>.</p>
<h2 id="putting-it-together-a-nested-example"><a class="header" href="#putting-it-together-a-nested-example">Putting It Together: A Nested Example</a></h2>
<p>Now let's combine these elements into a more complex, nested structure. Consider the following JSON object:</p>
<p>JSON</p>
<pre><code>{
  "name": "Gadget",
  "id": 12345,
  "enabled": true,
  "parts": [
    "bolt",
    "nut"
  ],
  "spec": {
    "size": 10.5,
    "data": "AQAA/w=="
  }
}
</code></pre>
<p>Note that the <code>"data"</code> value in JSON is base64 encoded, representing the bytes <code>0x01, 0x00, 0x00, 0xff</code>. In CBOR, we can represent this directly as a byte string.</p>
<p><strong>CBOR Diagnostic Notation:</strong></p>
<pre><code>{
  "name": "Gadget",
  "id": 12345,
  "enabled": true,
  "parts": [
    "bolt",
    "nut"
  ],
  "spec": {
    "size": 10.5,
    "data": h'010000ff'
  }
}
</code></pre>
<p><strong>CBOR Hexadecimal Encoding with Commentary:</strong></p>
<pre><code>a5                     # map(5 pairs follow)
   64 6e616d65         # key 0: text (4 bytes, "name")
   66 476164676574     # value 0: text (6 bytes, "Gadget")
   62 6964             # key 1: text (2 bytes, "id")
   19 3039             # value 1: unsigned(12345)
   67 656e61626c6564   # key 2: text (7 bytes, "enabled")
   f5                  # value 2: primitive(21) (true)
   65 7061727473       # key 3: text(5 bytes, "parts")
   82                  # value 3: array(2 elements follow)
      64 626f6c74         # element 0: text(4 bytes, "bolt")
      63 6e7574           # element 1: text(3 bytes, "nut")
   64 73706563         # key 4: text(4 bytes, "spec")
   A2                  # value 4: map(2 pairs follow)
      64 73697A65         # key 0: text(4 bytes, "size")
      F9 4940             # value 0: float(10.5) (half-precision)
      64 64617461         # key 1: text(4 bytes, "data")
      44 010000FF         # value 1: bytes(4 bytes, h'010000FF')
</code></pre>
<p>This example demonstrates how the basic building blocks combine to represent complex, nested data structures efficiently.</p>
<h2 id="conclusion-foundations-laid"><a class="header" href="#conclusion-foundations-laid">Conclusion: Foundations Laid</a></h2>
<p>This chapter has laid the groundwork for understanding CBOR by dissecting its core encoding mechanism. We've seen how the header byte, through its Major Type and Additional Information fields, defines the structure and type of every data item. We explored the preferred binary representations for fundamental types inherited from the JSON data model – integers (positive and negative), booleans, null, text strings, arrays, and maps – along with CBOR's native byte strings and standard floating-point numbers. By consistently comparing JSON, CBOR Diagnostic Notation, and the raw hexadecimal CBOR, we've illuminated the direct mapping between the familiar data model and its concise binary encoding.</p>
<p>With this foundation, you should now be able to interpret the structure of basic CBOR data items encoded using definite lengths and preferred serialization. You understand how CBOR achieves compactness while remaining self-describing at a fundamental level, allowing decoders to process data without prior schema knowledge.</p>
<p>However, this is just the beginning of the CBOR story. We intentionally deferred several important features to establish this core understanding:</p>
<ul>
<li><strong>Semantic Tags (Major Type 6):</strong> CBOR's powerful extensibility mechanism for adding meaning beyond the basic types.</li>
<li><strong>Indefinite-Length Items:</strong> Encoding strings, arrays, and maps when their final size isn't known upfront, crucial for streaming applications.</li>
<li><strong>CBOR Sequences:</strong> Transmitting multiple independent CBOR data items back-to-back in a stream.</li>
<li><strong>Schema Definition (CDDL):</strong> Formal languages like CDDL used to define and validate the structure of CBOR data.</li>
<li><strong>Deterministic Encoding:</strong> The stricter rules beyond preferred serialization needed to guarantee identical byte sequences for identical data, essential for cryptographic applications.</li>
</ul>
<p>These advanced topics build upon the fundamentals covered here. In the upcoming chapters, we will explore CBOR's extensibility through tags, dive deep into the requirements and techniques for achieving deterministic encoding (dCBOR), and see how these elements combine to create robust, verifiable data structures like Gordian Envelope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-semantics-with-cbor-tags"><a class="header" href="#extending-semantics-with-cbor-tags">Extending Semantics with CBOR Tags</a></h1>
<h2 id="beyond-basic-types-the-need-for-meaning"><a class="header" href="#beyond-basic-types-the-need-for-meaning">Beyond Basic Types: The Need for Meaning</a></h2>
<p>In the previous chapter, we explored the fundamental mechanics of CBOR encoding, focusing on how basic data types like integers, strings, arrays, and maps are represented in a compact binary form. We saw how CBOR leverages a simple initial byte structure (Major Type and Additional Information) to create a self-describing format at the byte level, closely mirroring the familiar JSON data model but optimized for efficiency.</p>
<p>However, real-world data often carries meaning beyond these fundamental structures. How do we distinguish a simple integer representing a count from one representing seconds since an epoch? How do we represent a date, a URI, or a number larger than standard 64-bit integers can hold? While applications could implicitly agree on the meaning of specific fields (e.g., "the 'timestamp' field is always epoch seconds"), this approach lacks standardization and can lead to ambiguity and interoperability issues.</p>
<p>CBOR addresses this need for richer semantics through its <strong>tagging mechanism</strong>. Tags allow us to annotate underlying data items, providing additional context or type information without fundamentally changing the encoding structure. They are a cornerstone of CBOR's extensibility, enabling the representation of a vast range of data types beyond the core set, from standard types like dates and URIs to application-specific structures.</p>
<p>This chapter delves into CBOR Tags (Major Type 6). We will explore:</p>
<ul>
<li>How tags work mechanically.</li>
<li>Their purpose in adding semantic meaning and enabling extensibility.</li>
<li>The IANA registry that standardizes tag definitions.</li>
<li>The different ranges of tag numbers and their implications for interoperability.</li>
<li>A selection of commonly used ("notable") tags with practical examples.</li>
</ul>
<p>By the end of this chapter, you will understand how to use and interpret CBOR tags, unlocking a powerful feature for representing complex and meaningful data structures efficiently.</p>
<blockquote>
<p><strong>⚠️ NOTE:</strong> As before, this chapter aims for practical understanding. For definitive details, always refer to the official specification,(<a href="https://datatracker.ietf.org/doc/html/rfc8949">https://datatracker.ietf.org/doc/html/rfc8949</a>), and the IANA registries it defines.</p>
</blockquote>
<h2 id="tagging-mechanism-major-type-6"><a class="header" href="#tagging-mechanism-major-type-6">Tagging Mechanism (Major Type 6)</a></h2>
<p>CBOR dedicates Major Type 6 specifically for tags. A tag consists of two parts:</p>
<ol>
<li><strong>Tag Number:</strong> An unsigned integer (ranging from 0 up to 2⁶⁴−1) that identifies the tag's meaning.</li>
<li><strong>Tag Content:</strong> A single, subsequent CBOR data item that is being tagged.</li>
</ol>
<pre><code>┌──────────────────────┐
│   TAG HEADER BYTE    │   → Major Type 6 + AI (determines length of tag number)
├──────────────────────┤
│   TAG NUMBER BYTES   │   → (0 to 8 bytes depending on AI)
└──────────────────────┘
           ↓
┌──────────────────────┐
│   TAGGED DATA ITEM   │   → Any valid CBOR item (primitive, array, map, etc.)
└──────────────────────┘
</code></pre>
<p>The encoding follows the standard CBOR pattern. The initial byte has its high-order 3 bits set to <code>110</code> (Major Type 6). The low-order 5 bits (Additional Information) encode the tag number itself, using the same rules used for all the major types:</p>
<div class="table-wrapper"><table><thead><tr><th>Tag Number Range</th><th>Initial Byte</th><th>Additional Bytes</th><th>Total Tag Header Size</th><th>Notes</th></tr></thead><tbody>
<tr><td>0 to 23</td><td><code>0xC0</code> to <code>0xD7</code></td><td>None</td><td>1 byte</td><td>Tag number in AI (0–23)</td></tr>
<tr><td>24 to 255</td><td><code>0xD8</code></td><td>1 byte (uint8)</td><td>2 bytes</td><td>AI = 24</td></tr>
<tr><td>256 to 65535</td><td><code>0xD9</code></td><td>2 bytes (uint16)</td><td>3 bytes</td><td>AI = 25</td></tr>
<tr><td>65536 to 4294967295</td><td><code>0xDA</code></td><td>4 bytes (uint32)</td><td>5 bytes</td><td>AI = 26</td></tr>
<tr><td>4294967296 to 2⁶⁴−1</td><td><code>0xDB</code></td><td>8 bytes (uint64)</td><td>9 bytes</td><td>AI = 27</td></tr>
</tbody></table>
</div>
<p>Immediately following the initial byte(s) that encode the tag number comes the complete encoding of the single data item that serves as the tag's content.</p>
<p><strong>Example:</strong> Tag 2 (unsigned bignum) applied to the byte string <code>h'0102'</code></p>
<div class="table-wrapper"><table><thead><tr><th>CBOR Hex</th><th>MT</th><th>AI</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>c2</code></td><td>6</td><td>2</td><td>Tag(2): Major Type 6, AI encodes tag number 2</td></tr>
<tr><td><code>42</code></td><td>2</td><td>2</td><td>Byte String (Major Type 2), length = 2 bytes</td></tr>
<tr><td><code>0102</code></td><td>–</td><td>–</td><td>Tag Content: raw bytes <code>0x01</code>, <code>0x02</code></td></tr>
</tbody></table>
</div>
<p><strong>CBOR Diagnostic Notation:</strong> <code>2(h'0102')</code></p>
<blockquote>
<p><strong>⚠️ NOTE:</strong> If you put this diagnostic notation into the <a href="https://cbor.me/">CBOR playground</a>, convert it to its hexadecimal representation and back, you will get the value <code>258</code>! This is because the playground understands that byte strings tagged with <strong>Tag 2</strong> (unsigned bignum) are interpreted as a single integer value. In this case, the first byte <code>0x01</code> is the most significant byte, and the second byte <code>0x02</code> is the least significant byte, leading to the calculation: <code>(1 * 256 + 2) = 258</code>. This is the playground enforcing <em>preferred serialization</em> of numbers, which is a feature of the playground, not a requirement of CBOR itself.</p>
</blockquote>
<h3 id="purpose-of-tags"><a class="header" href="#purpose-of-tags">Purpose of Tags</a></h3>
<p>Why introduce this extra layer? Tags serve several crucial purposes aligned with CBOR's design goals:</p>
<ul>
<li><strong>Adding Semantics:</strong> Tags provide standardized meaning to underlying data. Tag 1 indicates that an integer or float represents epoch-based time; Tag 32 indicates a text string is a URI. This allows applications to interpret data correctly without relying solely on field names or out-of-band agreements.</li>
<li><strong>Extensibility:</strong> Tags are CBOR's primary mechanism for defining new data types beyond the basic set, without requiring version negotiation. New standards or applications can define tags for specialized data structures (like cryptographic keys, geographic coordinates, or domain-specific objects) and register them, allowing the CBOR ecosystem to grow organically.</li>
<li><strong>Interoperability Hints:</strong> Some tags provide guidance for converting CBOR data to other formats, particularly JSON which lacks native support for types like byte strings or dates. Tags 21-23, for example, suggest how binary data might be represented using base64 or hex encoding if conversion is necessary.</li>
<li><strong>Type System Augmentation:</strong> Tags allow CBOR to represent data types common in programming languages but not directly present in the basic JSON model, such as unsigned 64-bit integers, arbitrarily large integers (bignums), specific date/time formats, UUIDs, and more.</li>
</ul>
<p>This mechanism of using an inline prefix tag number followed by the content provides a compact, binary-native way to convey type and semantic information. This contrasts with more verbose text-based approaches like XML namespaces or JSON-LD contexts, aligning with CBOR's goal of message size efficiency.</p>
<h3 id="decoder-behavior"><a class="header" href="#decoder-behavior">Decoder Behavior</a></h3>
<p>Crucially, CBOR decoders are <strong>not required</strong> to understand the semantics of every tag they encounter. This is a key aspect of CBOR's extensibility and forward compatibility. A generic decoder encountering an unknown tag <code>N</code> followed by content <code>C</code> can simply:</p>
<ol>
<li>Decode the tag number <code>N</code>.</li>
<li>Decode the tag content <code>C</code>.</li>
<li>Pass both <code>N</code> and <code>C</code> to the application.</li>
</ol>
<p>The application can then decide whether it understands tag <code>N</code> and how to interpret <code>C</code> based on it. If the application doesn't recognize tag <code>N</code>, it might treat <code>C</code> as opaque data, ignore it, or raise an error, depending on the application's logic. This allows systems to process messages containing newer, unknown tags without failing, provided the application logic can handle the tagged data appropriately (perhaps by ignoring it).</p>
<h3 id="tag-nesting"><a class="header" href="#tag-nesting">Tag Nesting</a></h3>
<p>Tags can be nested. A tag can enclose another tag, which in turn encloses a data item. For example, consider <code>TagA(TagB(ItemC))</code>. The interpretation applies from the inside out: <code>TagB</code> modifies or adds semantics to <code>ItemC</code>, and then <code>TagA</code> applies to the result of <code>TagB(ItemC)</code>.</p>
<p>Later in the book we'll discuss Gordian Envelope. The CBOR diagnostic notation for a very simple envelope containing just a text string might look like this:</p>
<pre><code>200(201("Hello, envelope!"))
</code></pre>
<p>Tag 200 is registered with IANA as "Gordian Envelope". So anytime you encounter tag 200, you know you're looking at a Gordian Envelope. The tag 201 represents dCBOR (deterministic CBOR), which we'll also cover in this book. In the Gordian Envelope specification, an Envelope containing just dCBOR is a <code>LEAF</code> node, which can be any valid dCBOR-- in this case, a text string.</p>
<h2 id="finding-your-tags-the-iana-registry"><a class="header" href="#finding-your-tags-the-iana-registry">Finding Your Tags: The IANA Registry</a></h2>
<p>With potentially 2⁶⁴ tag numbers available, how do we ensure that different applications don't use the same number for conflicting purposes? With that many tags, you could just pick them at random and be pretty certain nobody else is using them, but there's a better way! The Internet Assigned Numbers Authority (IANA) maintains the official <a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">Concise Binary Object Representation (CBOR) Tags registry</a>.</p>
<p>This registry serves as the central, authoritative source for standardized tag assignments. Its importance cannot be overstated:</p>
<ul>
<li><strong>Interoperability:</strong> The registry ensures that a specific tag number (especially in the lower, standardized ranges) consistently refers to the same semantic meaning and expected data item type across different implementations and protocols that adhere to the standards. This prevents conflicts where one application might use tag <code>X</code> for dates while another uses it for URIs.</li>
<li><strong>Discovery:</strong> It provides a public catalog where developers can look up existing tags for common data types (like dates, bignums, UUIDs, MIME messages, etc.) before defining their own. This encourages reuse and avoids unnecessary proliferation of tags for the same concept.</li>
</ul>
<p>The registry is presented as a table with columns including:</p>
<ul>
<li><strong>Tag:</strong> The tag number.</li>
<li><strong>Data Item:</strong> The expected CBOR type(s) of the tag content (e.g., text string, byte string, array, integer).</li>
<li><strong>Semantics:</strong> A brief description of the tag's meaning.</li>
<li><strong>Reference:</strong> A pointer to the document (an RFC or other stable specification) that defines the tag in detail.</li>
</ul>
<h2 id="tag-number-ranges-and-registration-procedures"><a class="header" href="#tag-number-ranges-and-registration-procedures">Tag Number Ranges and Registration Procedures</a></h2>
<p>The IANA registry doesn't treat all tag numbers equally. The vast space from 0 to 264−1 is divided into distinct ranges, each with its own allocation policy. These policies reflect the intended use and required level of standardization for tags within that range. Understanding these ranges is crucial for choosing appropriate tags and understanding their interoperability implications.</p>
<p>The primary ranges and their procedures are:</p>
<ol>
<li>
<p><strong>Range 0-23 (Standards Action)</strong></p>
<ul>
<li><strong>Encoding:</strong> These are the most compact tags, encoded directly within the initial byte (<code>0xc0</code> to <code>0xd7</code>).</li>
<li><strong>Procedure:</strong> Requires <strong>Standards Action</strong>. Assignment typically necessitates definition within an IETF Request for Comments (RFC) or a standard from another recognized body. This is the most rigorous process, requiring that the IETF adopt the tag as part of a formal standard.</li>
<li><strong>Intended Use:</strong> Reserved for core, fundamental, and widely applicable data types expected to be broadly interoperable (e.g., standard date/time formats, bignums, basic content hints).</li>
</ul>
</li>
<li>
<p><strong>Range 24-32767 (Specification Required)</strong></p>
<ul>
<li><strong>Encoding:</strong> Covers tags requiring 1 additional byte (<code>0xd8 xx</code>, for tags 24-255) and the lower half of tags requiring 2 additional bytes (<code>0xd9 xxxx</code>, for tags 256-32767).</li>
<li><strong>Procedure:</strong> Requires <strong>Specification Required</strong>. This means a stable, publicly accessible specification document defining the tag's semantics, expected data item format, and intended use must exist. IANA-appointed experts review the specification before registration. It's less formal than full Standards Action but still requires clear documentation and review.</li>
<li><strong>Intended Use:</strong> Suitable for well-defined data types used within specific protocols, communities, or domains (e.g., COSE security tags, MIME messages, UUIDs, URIs, dCBOR, and Gordian Envelope). These tags are expected to be interoperable among parties using the defining specifications.</li>
</ul>
</li>
<li>
<p><strong>Range 32768 - 18446744073709551615 (First Come First Served - FCFS)</strong></p>
<ul>
<li><strong>Encoding:</strong> Covers the upper half of 2-byte tags, all 4-byte tags (<code>0xda xxxxxxxx</code>), and all 8-byte tags (<code>0xdb xxxxxxxxxxxxxxxx</code>). This is the vast majority of the tag number space.</li>
<li><strong>Procedure:</strong> <strong>First Come First Served (FCFS)</strong>. Registration is granted to the first applicant who provides the required information (based on the RFC 8949 template), including contact details and preferably a URL pointing to a description of the semantics. The review is primarily for completeness, not semantic detail or overlap (beyond the number itself).</li>
<li><strong>Intended Use:</strong> Designed for application-specific tags, experimental use, vendor-specific extensions, or types where broad standardization isn't necessary or desired. Useful for rapid development or closed ecosystems.</li>
</ul>
</li>
</ol>
<p>This tiered structure represents a deliberate design choice, reflecting a spectrum from highly standardized and stable core types to flexible application-specific extensions. It reserves the most efficiently encoded tag numbers (0-23) for the most common, universally understood types, while providing ample space for innovation and specific needs in the higher ranges. All registration requests, regardless of range, must follow the basic template defined in RFC 8949 to ensure a minimum level of documentation.</p>
<h2 id="choosing-and-using-tags-wisely"><a class="header" href="#choosing-and-using-tags-wisely">Choosing and Using Tags Wisely</a></h2>
<p>The existence of different registration ranges has direct practical consequences for developers choosing tags:</p>
<ul>
<li>
<p><strong>Interoperability Guarantees:</strong></p>
<ul>
<li><strong>Standards Action (0-23):</strong> Offers the highest likelihood of interoperability. Implementations aiming for broad CBOR compliance should recognize and potentially handle these tags. Use them whenever your data semantically matches a tag in this range.</li>
<li><strong>Specification Required (24-32767):</strong> Provides good interoperability <em>within the community that uses the defining specification</em>. Consumers outside this community may not recognize the tag without consulting the specification. Ideal for domain-specific standards (e.g., security tokens, IoT protocols).</li>
<li><strong>FCFS (32768+):</strong> Offers the lowest <em>inherent</em> interoperability guarantee. Use primarily for private or application-specific data types where producers and consumers are tightly coupled or have explicitly agreed on the tag's meaning. Relying on FCFS tags for broad, unspecified interoperability is risky.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>⚠️ NOTE:</strong> <strong>The Danger of "Squatting"</strong> Never use an <em>unregistered</em> tag number from the Standards Action (0-23) or Specification Required (24-32767) ranges for your own private or experimental purposes. This practice, sometimes called "tag squatting," inevitably leads to collisions when IANA officially assigns that number for a different purpose. It breaks interoperability and creates significant problems down the line. Use the FCFS range for experimentation or application-specific needs.</p>
</blockquote>
<h2 id="how-to-register-your-own-fcfs-tags"><a class="header" href="#how-to-register-your-own-fcfs-tags">How to Register your own FCFS Tags</a></h2>
<blockquote>
<p><strong>✅ TIP:</strong> There is no charge to register a new tag.</p>
</blockquote>
<ol>
<li>Check the <a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">IANA CBOR Tags Registry</a> to ensure that there isn't already an existing tag that does what you want. If you find one, use that instead of creating a new one.</li>
<li>Write your specification. This should be a stable, publicly accessible document that defines the tag's semantics, expected data item format, and intended use. It can be as simple as a <a href="https://gist.github.com/">GitHub Gist</a>, but it should be clear, unambiguous, and have a stable URL.</li>
<li>Check the <a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">IANA CBOR Tags Registry</a> to ensure the tag you want isn't already taken.</li>
<li>Review <a href="https://www.rfc-editor.org/rfc/rfc8949.html#name-cbor-tags-registry">the section of RFC 8949</a> that describes the registry, the registration process for tags, and the template for submitting a registration request.</li>
<li>Review the <a href="https://www.iana.org/protocols">IANA list of protocol registries</a>. You'll find the one called <code>CBOR Tags</code>, which also lists the IANA experts assigned to review tag registrations if they are in the <em>Specification Required</em> range.</li>
<li>Fill out the <a href="https://www.iana.org/form/protocol-assignment">IANA "General Request for Assignments" form</a>.</li>
</ol>
<p>The form itself is very simple. You will need to provide:</p>
<ul>
<li>Your name and email address.</li>
<li>The type of assignment you're requesting (CBOR Tags).</li>
<li>The registry you're requesting the assignment from (the CBOR Tags registry).</li>
<li>A reason for the assignment. This information is optional, but helpful and recommended.</li>
<li>"Additional Information". For each tag, you're registering provide information corresponding to a column in the IANA registry. We recommend you review at the registry for examples:
<ul>
<li><strong>Tag:</strong> The tag number.</li>
<li><strong>Data Item:</strong> The expected CBOR type(s) of the tag content (e.g., text string, byte string, array, integer).</li>
<li><strong>Semantics:</strong> A brief description of the tag's meaning.</li>
<li><strong>Reference:</strong> A pointer to the document (an RFC or other stable specification) that defines the tag in detail.</li>
</ul>
</li>
</ul>
<p>That's it! Submit the form, and IANA will respond to your request by email.</p>
<h2 id="notable-tags"><a class="header" href="#notable-tags">Notable Tags</a></h2>
<p>The IANA CBOR Tags registry is authoritative and growing, listing hundreds of registered tags. Navigating this full list can be daunting. Fortunately, the IETF community maintains a document, <a href="https://datatracker.ietf.org/doc/draft-bormann-cbor-notable-tags/">Notable CBOR Tags</a>, which serves as a curated guide or "roadmap" to a selection of the most commonly used, interesting, or otherwise "notable" tags, particularly those defined since the original CBOR specification.</p>
<p>The <a href="https://datatracker.ietf.org/doc/draft-bormann-cbor-notable-tags/">Internet Draft on Notable Tags</a> provides a number of tags in other interesting categories, including:</p>
<ul>
<li>
<p><strong>RFC 7049 (original CBOR specification)</strong>
Tags defined in the original CBOR specification, including standard date/time strings, bignums, decimal fractions, and base64 encodings.</p>
</li>
<li>
<p><strong>Security</strong>
Tags used in security contexts, such as COSE (CBOR Object Signing and Encryption) and CBOR Web Tokens (CWT).</p>
</li>
<li>
<p><strong>CBOR-based Representation Formats</strong>
Tags used in CBOR-based representation formats like YANG-CBOR.</p>
</li>
<li>
<p><strong>Protocols</strong>
Tags utilized in specific protocols, including DOTS (DDoS Open Threat Signaling) and RAINS (Another Internet Naming Service).</p>
</li>
<li>
<p><strong>Datatypes</strong>
Tags representing advanced datatypes, such as advanced arithmetic types, variants of undefined, and typed/homogeneous arrays.</p>
</li>
<li>
<p><strong>Domain-Specific</strong>
Tags tailored for specific domains, including human-readable text and extended time formats.</p>
</li>
<li>
<p><strong>Platform-Oriented</strong>
Tags related to specific platforms or programming languages, such as Perl, JSON, and unusual text encodings.</p>
</li>
<li>
<p><strong>Application-Specific</strong>
Tags designed for particular applications, including enumerated alternative data items.</p>
</li>
<li>
<p><strong>Implementation Aids</strong>
Tags intended to assist with implementation, such as invalid tags and programming aids for simple values.</p>
</li>
</ul>
<blockquote>
<p><strong>✅ TIP:</strong> While the IANA registry is the definitive source, the "Notable CBOR Tags" draft provides valuable context and summaries for many practical tags.</p>
</blockquote>
<h2 id="a-few-commonly-used-tags"><a class="header" href="#a-few-commonly-used-tags">A Few Commonly Used Tags</a></h2>
<p>Let's explore a few of the most fundamental and useful tags, many defined in the original CBOR specification and detailed further in the notable tags draft:</p>
<h3 id="tag-0-standard-datetime-string"><a class="header" href="#tag-0-standard-datetime-string">Tag 0: Standard Date/Time String</a></h3>
<ul>
<li><strong>Content:</strong> UTF-8 string</li>
<li><strong>Semantics:</strong> Represents a date and time expressed as a string, following the standard format defined in <a href="https://datatracker.ietf.org/doc/html/rfc3339">RFC 3339</a> (a profile of ISO 8601). This is a human-readable format.</li>
<li><strong>Diagnostic:</strong> <code>0("2013-03-21T20:04:00Z")</code></li>
<li><strong>Hex Example:</strong></li>
</ul>
<pre><code>C0                                      # tag(0)
   74                                   # text(20)
      323031332D30332D32315432303A30343A30305A # "2013-03-21T20:04:00Z"
</code></pre>
<h3 id="tag-1-epoch-based-datetime"><a class="header" href="#tag-1-epoch-based-datetime">Tag 1: Epoch-Based Date/Time</a></h3>
<ul>
<li><strong>Content:</strong> Integer or Floating-point number</li>
<li><strong>Semantics:</strong> Represents a point in time as a numeric offset (in seconds, with optional fractional part for floats) from the standard Unix epoch (1970-01-01T00:00:00Z UTC). More compact and suitable for computation than Tag 0.</li>
<li><strong>Diagnostic (Integer):</strong> <code>1(1363896240)</code></li>
<li><strong>Hex Example (Integer):</strong></li>
</ul>
<pre><code>C1             # tag(1)
   1A 514B67B0 # unsigned(1363896240)
</code></pre>
<ul>
<li><strong>Diagnostic (Float):</strong> <code>1(1698417015.123)</code></li>
<li><strong>Hex Example (Float - double precision):</strong></li>
</ul>
<pre><code>C1                     # tag(1)
   FB 41D94EF25DC7DF3B # 1698417015.123
</code></pre>
<blockquote>
<p><strong>✅ TIP:</strong> The choice between integer and float depends on the need for sub-second precision. More advanced time tags exist (e.g., Tag 1001) offering higher precision and timescale information, but Tag 1 remains the basic epoch representation.</p>
</blockquote>
<h3 id="tag-2-and-3-bignums"><a class="header" href="#tag-2-and-3-bignums">Tag 2 and 3: Bignums</a></h3>
<ul>
<li><strong>Content:</strong> Byte string</li>
<li><strong>Semantics:</strong> Represents an arbitrarily large non-negative integer (Tag 2) or negative integer (Tag 3) that does not have to fit into the 64-bit unsigned integer (Major Type 0). The byte string contains the magnitude of the integer in network byte order (big-endian), with no leading zero bytes permitted in preferred/deterministic encoding.</li>
<li><strong>Diagnostic (representing 18446744073709551616):</strong> <code>2(h'010000000000000000')</code></li>
<li><strong>Hex Example (representing 18446744073709551616):</strong></li>
</ul>
<pre><code>C2                         # Tag(2, non-negative bignum)
    49 010000000000000000  # Byte String (length 9 bytes, 18446744073709551616)
</code></pre>
<h3 id="tag-32-uri"><a class="header" href="#tag-32-uri">Tag 32: URI</a></h3>
<ul>
<li><strong>Content:</strong> UTF-8 string</li>
<li><strong>Semantics:</strong> Identifies the text string content as a Uniform Resource Identifier according to(<a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC-3986</a>).</li>
<li><strong>Diagnostic:</strong> <code>32("http://cbor.io/")</code></li>
<li><strong>Hex Example:</strong></li>
</ul>
<pre><code>D8 20                                # tag(32)
   6F                                # text(15)
      687474703A2F2F63626F722E696F2F # "http://cbor.io/"
</code></pre>
<p><strong>Tag 37: UUID</strong></p>
<ul>
<li><strong>Content:</strong> Byte string (must be 16 bytes long)</li>
<li><strong>Semantics:</strong> Identifies the byte string content as a Universally Unique Identifier, as defined in(<a href="https://datatracker.ietf.org/doc/html/rfc9562">RFC-9562</a>).</li>
<li><strong>Diagnostic:</strong> <code>37(h'f81d4fae7dec11d0a76500a0c91e6bf6')</code></li>
<li><strong>Hex Example:</strong></li>
</ul>
<pre><code>D8 25                   # Tag(37) - uses 1+1 encoding (0xd8 0x25)
    50                   # Byte String (length 16 bytes)
        f81d4fae7dec11d0a76500a0c91e6bf6
</code></pre>
<h2 id="example-tags-in-action"><a class="header" href="#example-tags-in-action">Example: Tags in Action:</a></h2>
<p>Let's see how these tags combine with basic CBOR types to represent a more complex data structure. Consider this JSON object representing a hypothetical sensor reading message:</p>
<p><strong>JSON:</strong></p>
<pre><code>{
  "sensorID": "urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6",
  "captureTime": "2023-10-27T14:30:15.123Z",
  "reading": -12.345,
  "readingScale": -3,
  "rawValue": -12345,
  "statusURL": "https://example.com/status/f81d4fae",
  "alertPayload": "AQIDBA=="
}
</code></pre>
<p>Here, <code>sensorID</code> is a UUID, <code>captureTime</code> is a standard timestamp, <code>reading</code> could be represented as a decimal fraction (<code>-12345 * 10^-3</code>), <code>statusURL</code> is a URI, and <code>alertPayload</code> is base64-encoded binary data (<code>0x01020304</code>).</p>
<p><strong>CBOR Diagnostic Notation (using tags):</strong></p>
<pre><code>{
  "sensorID": 37(h'f81d4fae7dec11d0a76500a0c91e6bf6'),    // Tag 37 for UUID
  "captureTime": 0("2023-10-27T14:30:15.123Z"),           // Tag 0 for RFC3339 string
  // Alternative: Represent reading as decimal fraction
  // "reading": 4([-3, -12345]),                          // Tag 4 for decimal fraction
  "reading": -12.345,                                     // Using standard float for simplicity here
  "readingScale": -3,                                     // Simple integer
  "rawValue": -12345,                                     // Simple integer
  "statusURL": 32("https://example.com/status/f81d4fae"), // Tag 32 for URI
  "alertPayload": h'01020304'                             // Direct byte string
  // Alternative: Use Tag 22 hint if JSON interop requires base64
  // "alertPayload": 22(h'01020304')
}
</code></pre>
<p>This example illustrates how tags integrate seamlessly into the CBOR structure. Tag 37 clearly identifies the <code>sensorID</code> bytes as a UUID, Tag 0 provides a standard string representation for <code>captureTime</code>, and Tag 32 marks the <code>statusURL</code> string as a URI. We chose to represent <code>reading</code> as a standard float, but Tag 4 could have been used for exact decimal precision if required by the application. For <code>alertPayload</code>, we used a direct byte string, as CBOR handles binary natively; Tag 22 could be added as a hint if this data frequently needs conversion to base64 for JSON compatibility. The tags add semantic precision and clarity beyond what the JSON representation alone could offer directly.</p>
<h2 id="conclusion-the-power-of-extensibility"><a class="header" href="#conclusion-the-power-of-extensibility">Conclusion: The Power of Extensibility</a></h2>
<p>CBOR Tags (Major Type 6) are the primary mechanism for extending CBOR's data model beyond its fundamental types. They provide a standardized way to imbue data items with specific semantic meaning, enabling the representation of complex types like dates, times, large or high-precision numbers, URIs, UUIDs, and much more, all while maintaining CBOR's characteristic compactness.1 The IANA registry plays a vital role in ensuring interoperability by providing a central authority for tag definitions, while the tiered registration system balances the need for stable, standardized core tags with flexibility for application-specific extensions.1</p>
<p>Understanding tags—how they work, where to find them, the implications of different ranges, and how to apply common ones—is key to leveraging the full power of CBOR. They allow engineers to model complex, meaningful data structures efficiently and in a way that promotes clarity and potential interoperability.</p>
<p>Looking ahead, tags are not just an isolated feature; they interact significantly with other advanced CBOR concepts:</p>
<ul>
<li><strong>Deterministic Encoding (dCBOR):</strong> As we will explore later, achieving a canonical, byte-for-byte identical encoding for the same logical data requires strict rules. These rules apply to tags as well, mandating preferred serialization for tag numbers, and often requiring the consistent presence or absence of specific tags for certain semantic types. This is essential for applications like digital signatures or content-addressable storage where byte-level reproducibility is paramount.</li>
<li><strong>Application Profiles (COSE, Gordian Envelope):</strong> Many higher-level protocols and data formats built upon CBOR rely heavily on specific tags to define their structures and semantics. CBOR Object Signing and Encryption (COSE) uses tags extensively to identify signed, MACed, and encrypted messages and related security parameters. Similarly, the Gordian Envelope specification, which we will cover in detail later in this book, defines its own set of tags to structure its secure, layered data format. A solid grasp of CBOR tags is fundamental to working with these important application profiles.</li>
</ul>
<p>Mastering CBOR tags moves us beyond simply encoding basic data structures towards building rich, extensible, and semantically precise data formats suitable for a wide range of applications, from constrained IoT devices to complex web protocols.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indefinite-length-items"><a class="header" href="#indefinite-length-items">Indefinite-Length Items</a></h1>
<h2 id="introduction-beyond-known-lengths"><a class="header" href="#introduction-beyond-known-lengths">Introduction: Beyond Known Lengths</a></h2>
<p>In <a href="part_1/./practical_introduction_to_cbor.html">A Practical Introduction to CBOR</a>, we established the foundational mechanics of CBOR encoding, focusing on how the initial byte(s) of a data item—through the interplay of Major Type (MT) and Additional Information (AI)—convey the item's type and, crucially, its size or value. We saw how integers, strings, arrays, and maps are typically encoded using <em>definite lengths</em>, where the exact number of bytes (for strings) or elements/pairs (for collections) is specified upfront using AI values 0 through 27. This approach, particularly when combined with preferred serialization rules, leads to compact and efficiently parsable representations, provided the size of the data item is known <em>before</em> serialization begins.</p>
<p>However, there are common scenarios where determining the total size of a data item in advance is impractical, inefficient, or even impossible. Consider these situations:</p>
<ul>
<li><strong>Incremental Generation:</strong> A system might generate a large log entry or document piece by piece, appending data as it becomes available. Calculating the final size would require buffering the entire content first.</li>
<li><strong>Network Streaming:</strong> Sensor data or results from a long-running computation might need to be transmitted over a network as soon as parts are ready, without waiting for the entire dataset to be complete.</li>
<li><strong>Data Pipelines:</strong> An intermediate process might receive data chunks from one source and need to forward them immediately in CBOR format to the next stage, without the memory or latency budget to assemble the complete object first.</li>
</ul>
<p>For these kinds of streaming applications, requiring the total length upfront negates the benefits of incremental processing. CBOR addresses this challenge directly with <em>indefinite-length encoding</em>, a mechanism specifically designed for situations where the size of certain data items is not known when serialization starts. This alternative encoding applies only to byte strings (Major Type 2), text strings (Major Type 3), arrays (Major Type 4), and maps (Major Type 5).</p>
<p>This chapter delves into the practical details of indefinite-length CBOR encoding. We will explore the specific encoding mechanism, examine how strings and collections are represented using this method, discuss its primary use cases and practical implications for parsers, survey its application in real-world protocols, and crucially, understand why this flexible encoding is explicitly disallowed in deterministic CBOR profiles. By the end of this chapter, you will have a solid working knowledge of how CBOR handles streaming data and the trade-offs involved.</p>
<h2 id="the-indefinite-length-mechanism-ai-31-and-the-break-code"><a class="header" href="#the-indefinite-length-mechanism-ai-31-and-the-break-code">The Indefinite-Length Mechanism: AI 31 and the "Break" Code</a></h2>
<p>The core mechanism for indefinite-length encoding leverages a specific value within the Additional Information (AI) part of the initial byte, alongside a unique stop code.</p>
<p>Recall from the <a href="part_1/./practical_introduction_to_cbor.html">Practical Introduction</a> chapter the structure of the initial byte in any CBOR data item:</p>
<pre><code>┌────┬────┬────┬────┬────┬────┬────┬────┐
│  7 │  6 │  5 │  4 │  3 │  2 │  1 │  0 │
├────┴────┴────┼────┴────┴────┴────┴────┤
│  MAJOR TYPE  │ ADDITIONAL INFORMATION │
└──────────────┴────────────────────────┘
</code></pre>
<p>While AI values 0 through 27 are used to encode literal values or definite lengths/counts, the AI value 31 (binary <code>11111</code>) serves a distinct purpose related to indefinite-length items.</p>
<p><strong>Signaling the Start:</strong> When AI value 31 is combined with the Major Types that support indefinite lengths (2, 3, 4, and 5), it signals the <em>start</em> of an indefinite-length data item of that specific type. It essentially acts as a marker indicating, "An item of this type begins here, but its total length is not provided; subsequent data items or chunks will follow until a specific terminator is encountered."</p>
<p><strong>Applicable Major Types:</strong> It is crucial to remember that indefinite-length encoding is <em>only</em> defined for the following Major Types:</p>
<div class="table-wrapper"><table><thead><tr><th>Major Type</th><th>Description</th></tr></thead><tbody>
<tr><td>2</td><td>Byte String</td></tr>
<tr><td>3</td><td>Text String</td></tr>
<tr><td>4</td><td>Array</td></tr>
<tr><td>5</td><td>Map</td></tr>
</tbody></table>
</div>
<p>Other Major Types (0, 1, 6, 7) do not have an indefinite-length encoding mechanism defined via AI 31 in this manner.</p>
<p><strong>The Universal Terminator: The <code>0xff</code> "Break" Code:</strong> To signal the end of an indefinite-length sequence (whether it's chunks of a string or elements/pairs of a collection), CBOR defines a unique, single-byte stop code: <code>0xff</code>. This byte is often referred to as the "break" code.</p>
<p>The encoding of the break code itself is Major Type 7 (Simple Values / Floating-Point) with Additional Information 31. This specific combination (<code>111 11111</code> binary) is reserved solely for this purpose. Its structure ensures it cannot be mistaken for the start of any standard CBOR data item, making it an unambiguous terminator for indefinite-length sequences. A parser encountering <code>0xff</code> in a context where it's expecting the next chunk of an indefinite string, the next element of an indefinite array, or the next key/value of an indefinite map knows that the indefinite-length item is now complete.</p>
<p>The following table summarizes the specific initial bytes used to start indefinite-length items and the universal break code:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>MT</th><th>AI</th><th>Encoding</th><th>Description</th></tr></thead><tbody>
<tr><td>Indefinite Byte String</td><td>2</td><td>31</td><td><code>5f</code></td><td>Start of indefinite byte string</td></tr>
<tr><td>Indefinite Text String</td><td>3</td><td>31</td><td><code>7f</code></td><td>Start of indefinite text string</td></tr>
<tr><td>Indefinite Array</td><td>4</td><td>31</td><td><code>9f</code></td><td>Start of indefinite array</td></tr>
<tr><td>Indefinite Map</td><td>5</td><td>31</td><td><code>bf</code></td><td>Start of indefinite map</td></tr>
<tr><td>Break Code</td><td>7</td><td>31</td><td><code>ff</code></td><td>End of any indefinite-length item</td></tr>
</tbody></table>
</div>
<p>Understanding these specific byte values (<code>5f</code>, <code>7f</code>, <code>9f</code>, <code>bf</code> for starting, <code>ff</code> for stopping) is key to recognizing and parsing indefinite-length CBOR data streams.</p>
<h2 id="streaming-data-indefinite-length-strings"><a class="header" href="#streaming-data-indefinite-length-strings">Streaming Data: Indefinite-Length Strings</a></h2>
<p>Indefinite-length strings provide a way to encode byte sequences or UTF-8 text without knowing the total number of bytes beforehand. They achieve this by breaking the string content into manageable chunks.</p>
<p>The fundamental concept is that an indefinite-length string is represented as:</p>
<ol>
<li>The specific start marker (<code>5f</code> for byte strings, <code>7f</code> for text strings).</li>
<li>A sequence of zero or more <em>definite-length</em> string chunks of the <em>same</em> major type.</li>
<li>The <code>0xff</code> break code.</li>
</ol>
<p>The logical value of the complete string is obtained by concatenating the <em>content</em> (the raw bytes or UTF-8 text, excluding the definite-length headers) of these chunks in the order they appear.</p>
<h3 id="indefinite-length-byte-strings-major-type-2-ai-31"><a class="header" href="#indefinite-length-byte-strings-major-type-2-ai-31">Indefinite-Length Byte Strings (Major Type 2, AI 31)</a></h3>
<ul>
<li><strong>Encoding Structure:</strong> An indefinite-length byte string starts with <code>5f</code>, followed by zero or more definite-length byte string chunks, and terminates with <code>ff</code>.</li>
</ul>
<pre><code>5f [chunk1][chunk2]... ff
</code></pre>
<ul>
<li><strong>Chunk Structure:</strong> Each <code>[chunkN]</code> must be a complete, definite-length byte string data item (Major Type 2, AI 0-27). For example, <code>43 010203</code> represents a chunk containing the 3 bytes <code>0x01</code>, <code>0x02</code>, <code>0x03</code>. An empty chunk, encoded as <code>40</code>, is also valid and contributes nothing to the concatenated value.</li>
<li><strong>Examples:</strong>
<ul>
<li>An empty byte string encoded using indefinite length:
<ul>
<li>CBOR Diagnostic: <code>_ h''</code></li>
<li>CBOR Hex: <code>5f ff</code></li>
</ul>
</li>
<li>The byte sequence <code>0x01, 0x02, 0x03, 0x04, 0x05</code> encoded indefinitely with two chunks:
<ul>
<li>CBOR Diagnostic: <code>_ h'010203' h'0405'</code></li>
<li>CBOR Hex: <code>5f 43 010203 42 0405 ff</code>
<ul>
<li><code>5f</code>: Start indefinite byte string</li>
<li><code>43 010203</code>: Chunk 1 (definite length 3, bytes <code>01 02 03</code>)</li>
<li><code>42 0405</code>: Chunk 2 (definite length 2, bytes <code>04 05</code>)</li>
<li><code>ff</code>: Break code</li>
</ul>
</li>
</ul>
</li>
<li>The same byte sequence encoded indefinitely with a single chunk:
<ul>
<li>CBOR Diagnostic: <code>_ h'0102030405'</code></li>
<li>CBOR Hex: <code>5f 45 0102030405 ff</code>
<ul>
<li><code>5f</code>: Start indefinite byte string</li>
<li><code>45 0102030405</code>: Chunk 1 (definite length 5, bytes <code>01 02 03 04 05</code>)</li>
<li><code>ff</code>: Break code</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Notice that the same logical byte sequence (<code>0102030405</code>) can be represented in multiple ways using indefinite-length encoding, depending on the chunking strategy. This flexibility is the core benefit for streaming, but it also introduces non-canonical representations. Furthermore, compared to the definite-length encoding (<code>45 0102030405</code>), the indefinite-length versions carry an overhead of at least two bytes (the <code>5f</code> start marker and the <code>ff</code> break code), plus the header bytes for each chunk. This trade-off between flexibility, overhead, and canonicality is central to understanding indefinite-length encoding.</p>
<h3 id="indefinite-length-text-strings-major-type-3-ai-31"><a class="header" href="#indefinite-length-text-strings-major-type-3-ai-31">Indefinite-Length Text Strings (Major Type 3, AI 31)</a></h3>
<ul>
<li><strong>Encoding Structure:</strong> An indefinite-length text string starts with <code>7f</code>, followed by zero or more definite-length text string chunks, and terminates with <code>ff</code>.</li>
</ul>
<pre><code>7f [chunk1][chunk2]... ff
</code></pre>
<ul>
<li><strong>Chunk Structure:</strong> Each <code>[chunkN]</code> must be a complete, definite-length <em>text</em> string data item (Major Type 3, AI 0-27), meaning it must contain a sequence of bytes that constitutes valid UTF-8 encoding. For example, <code>63 666f6f</code> represents a chunk containing the 3 bytes for the UTF-8 string "foo".</li>
<li><strong>UTF-8 Integrity Constraint:</strong> This is a critical rule specific to indefinite-length <em>text</em> strings: chunk boundaries <strong>must not</strong> occur in the middle of a multi-byte UTF-8 character sequence. Each individual chunk, when decoded, must result in a valid UTF-8 string. The concatenation of these valid chunks naturally forms the final, valid UTF-8 string. This constraint implies that an encoder generating indefinite-length text strings must be UTF-8 aware. When deciding where to split the text into chunks during streaming, it cannot simply cut after an arbitrary number of bytes; it must ensure the cut occurs only at a character boundary. This adds a layer of complexity compared to encoding indefinite-length byte strings, where chunks can be split arbitrarily.</li>
<li><strong>Examples:</strong>
<ul>
<li>An empty text string encoded using indefinite length:
<ul>
<li>CBOR Diagnostic: <code>_ ""</code></li>
<li>CBOR Hex: <code>7f ff</code></li>
</ul>
</li>
<li>The text string <code>"Hello World"</code> encoded indefinitely with three chunks:
<ul>
<li>CBOR Diagnostic: <code>_ "Hello" " " "World"</code></li>
<li>CBOR Hex: <code>7f 65 48656c6c6f 61 20 65 576f726c64 ff</code>
<ul>
<li><code>7f</code>: Start indefinite text string</li>
<li><code>65 48656c6c6f</code>: Chunk 1 ("Hello", definite length 5)</li>
<li><code>61 20</code>: Chunk 2 (" ", definite length 1)</li>
<li><code>65 576f726c64</code>: Chunk 3 ("World", definite length 5)</li>
<li><code>ff</code>: Break code</li>
</ul>
</li>
</ul>
</li>
<li>The text string <code>"你好"</code> (UTF-8 bytes: <code>e4 bda0 e5 a5bd</code>) encoded indefinitely:
<ul>
<li><em>Valid</em> Chunking (split between characters):
<ul>
<li>CBOR Diagnostic: <code>_ "你" "好"</code></li>
<li>CBOR Hex: <code>7f 63 e4bda0 63 e5a5bd ff</code> (Chunk 1: "你", length 3; Chunk 2: "好", length 3)</li>
</ul>
</li>
<li><em>Invalid</em> Chunking (attempting to split within a character): An encoder must not produce, for example, a chunk ending in <code>e4 bd</code> followed by a chunk starting with <code>a0</code>. Each chunk's byte sequence must stand alone as valid UTF-8.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Similar to byte strings, indefinite-length text strings offer streaming flexibility at the cost of overhead and non-canonical representation, with the added requirement of maintaining UTF-8 validity within each chunk.</p>
<h2 id="streaming-collections-indefinite-length-arrays-and-maps"><a class="header" href="#streaming-collections-indefinite-length-arrays-and-maps">Streaming Collections: Indefinite-Length Arrays and Maps</a></h2>
<p>Just as strings can be streamed chunk by chunk, CBOR allows arrays and maps to be encoded without knowing the total number of elements or pairs upfront.</p>
<p>The principle is straightforward:</p>
<ol>
<li>Start with the specific indefinite-length marker (<code>9f</code> for arrays, <code>bf</code> for maps).</li>
<li>Encode the elements (for arrays) or key-value pairs (for maps) sequentially, one after another.</li>
<li>Terminate the sequence with the <code>0xff</code> break code.</li>
</ol>
<h3 id="indefinite-length-arrays-major-type-4-ai-31"><a class="header" href="#indefinite-length-arrays-major-type-4-ai-31">Indefinite-Length Arrays (Major Type 4, AI 31)</a></h3>
<ul>
<li><strong>Encoding Structure:</strong> An indefinite-length array starts with <code>9f</code>, followed by zero or more encoded data items (its elements), and terminates with <code>ff</code>.</li>
</ul>
<pre><code>9f [item1][item2][item3]... ff
</code></pre>
<ul>
<li><strong>Element Structure:</strong> Each <code>[itemN]</code> can be <em>any</em> valid CBOR data item, including integers, strings (definite or indefinite), floats, booleans, null, tags, or even other arrays and maps (definite or indefinite).</li>
<li><strong>Nesting:</strong> Indefinite-length arrays can freely contain other indefinite-length items, allowing for complex, nested structures to be streamed.</li>
<li><strong>Examples:</strong>
<ul>
<li>An empty array encoded using indefinite length:
<ul>
<li>CBOR Diagnostic: <code>[_]</code></li>
<li>CBOR Hex: <code>9f ff</code></li>
</ul>
</li>
<li>The array <code>[1, "two", true]</code> encoded indefinitely:
<ul>
<li>CBOR Diagnostic: <code>[_ 1, "two", true]</code></li>
<li>CBOR Hex: <code>9f 01 63 74776f f5 ff</code>
<ul>
<li><code>9f</code>: Start indefinite array</li>
<li><code>01</code>: Element 1 (integer 1)</li>
<li><code>63 74776f</code>: Element 2 (text string "two")</li>
<li><code>f5</code>: Element 3 (true)</li>
<li><code>ff</code>: Break code</li>
</ul>
</li>
</ul>
</li>
<li>A nested indefinite array <code>[_ "a", "b"]</code>:
<ul>
<li>CBOR Diagnostic: <code>[_ "a", "b"]</code></li>
<li>CBOR Hex: <code>9f 01 9f 61 61 61 62 ff 03 ff</code>
<ul>
<li><code>9f</code>: Start outer indefinite array</li>
<li><code>01</code>: Outer element 1 (integer 1)</li>
<li><code>9f</code>: Start inner indefinite array (Outer element 2)</li>
<li><code>61 61</code>: Inner element 1 ("a")</li>
<li><code>61 62</code>: Inner element 2 ("b")</li>
<li><code>ff</code>: Break code for inner array</li>
<li><code>03</code>: Outer element 3 (integer 3)</li>
<li><code>ff</code>: Break code for outer array</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="indefinite-length-maps-major-type-5-ai-31"><a class="header" href="#indefinite-length-maps-major-type-5-ai-31">Indefinite-Length Maps (Major Type 5, AI 31)</a></h3>
<ul>
<li><strong>Encoding Structure:</strong> An indefinite-length map starts with <code>bf</code>, followed by zero or more key-value pairs encoded sequentially (key1, value1, key2, value2,...), and terminates with <code>ff</code>.</li>
</ul>
<pre><code>bf [key1][value1][key2][value2]... ff
</code></pre>
<ul>
<li><strong>Pair Structure:</strong> Each key and each value can be <em>any</em> valid CBOR data item. Crucially, the data items between the <code>bf</code> marker and the <code>ff</code> break code must come in pairs. A map must contain an even number of data items following the initial <code>bf</code>.</li>
<li><strong>Nesting:</strong> Indefinite-length maps can contain indefinite-length items as either keys or values.</li>
<li><strong>Examples:</strong>
<ul>
<li>An empty map encoded using indefinite length:
<ul>
<li>CBOR Diagnostic: <code>_ {}</code></li>
<li>CBOR Hex: <code>bf ff</code></li>
</ul>
</li>
<li>The map <code>{"a": 1, "b": false}</code> encoded indefinitely:
<ul>
<li>CBOR Diagnostic: <code>_ {"a": 1, "b": false}</code></li>
<li>CBOR Hex: <code>bf 61 61 01 61 62 f4 ff</code>
<ul>
<li><code>bf</code>: Start indefinite map</li>
<li><code>61 61</code>: Key 1 ("a")</li>
<li><code>01</code>: Value 1 (integer 1)</li>
<li><code>61 62</code>: Key 2 ("b")</li>
<li><code>f4</code>: Value 2 (false)</li>
<li><code>ff</code>: Break code</li>
</ul>
</li>
</ul>
</li>
<li>A map containing an indefinite-length byte string as a value <code>{"data": _ h'01' h'02'}</code>:
<ul>
<li>CBOR Diagnostic: <code>_ {"data": _ h'01' h'02'}</code></li>
<li>CBOR Hex: <code>bf 64 64617461 5f 41 01 41 02 ff ff</code>
<ul>
<li><code>bf</code>: Start indefinite map</li>
<li><code>64 64617461</code>: Key ("data")</li>
<li><code>5f</code>: Start indefinite byte string (Value)</li>
<li><code>41 01</code>: Chunk 1 (<code>h'01'</code>)</li>
<li><code>41 02</code>: Chunk 2 (<code>h'02'</code>)</li>
<li><code>ff</code>: Break code for byte string</li>
<li><code>ff</code>: Break code for map</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The requirement for an even number of items between <code>bf</code> and <code>ff</code> is an important validation check for parsers. If a parser encounters the <code>ff</code> break code immediately after reading a key but before reading its corresponding value, it indicates a malformed indefinite-length map. This adds a slight amount of state tracking (ensuring pairs are complete) compared to parsing indefinite-length arrays.</p>
<h2 id="use-cases-and-practical-considerations"><a class="header" href="#use-cases-and-practical-considerations">Use Cases and Practical Considerations</a></h2>
<p>The primary motivation for indefinite-length encoding is to support streaming scenarios where data sizes are unknown upfront.</p>
<ul>
<li><strong>Network Protocols:</strong> In protocols designed for constrained environments or transferring large objects, the ability to send data in chunks without pre-calculating the total size is valuable. CoAP (Constrained Application Protocol) Block-Wise Transfers ((<a href="https://datatracker.ietf.org/doc/html/rfc7959">RFC-7959</a>)) is often cited in this context. While CoAP itself manages the blocking at the protocol level, and the payloads within those blocks are often CBOR using definite lengths for simplicity, the overall concept aligns with handling large data incrementally. Indefinite-length CBOR <em>could</em> be used within such frameworks, although definite-length chunks are common in practice.</li>
<li><strong>Log Generation/Aggregation:</strong> Systems that generate extensive logs or aggregate log streams from various sources can benefit. An application can start an indefinite-length array or map for a log record, append fields (potentially including large, streamed strings) as they become available, and finalize the record with the break code without needing to buffer the entire structure in memory first.</li>
<li><strong>Data Pipelines:</strong> When CBOR data flows through multiple processing stages, using indefinite-length encoding can sometimes avoid the need for intermediate stages to buffer entire large strings or collections just to determine their length before passing them on.</li>
</ul>
<p>However, using indefinite-length items introduces practical considerations for implementation:</p>
<ul>
<li><strong>Parser Implementation:</strong> Parsing definite-length items is often simpler. The parser reads the length L, potentially allocates memory for L bytes or L items, and then reads exactly that amount of data. Parsing indefinite-length items requires a different logic: the parser reads the start marker (<code>5f</code>/<code>7f</code>/<code>9f</code>/<code>bf</code>), then enters a loop, reading one complete data item (a chunk, an element, or a key-value pair) at a time. After each item, it must check if the next byte is the <code>0xff</code> break code. If not, it continues the loop; if it is, the indefinite item is complete. This typically involves more state management within the parser.</li>
<li><strong>Buffering Considerations:</strong> While indefinite-length encoding allows the <em>sender</em> to stream data without knowing the total size, it doesn't automatically eliminate the need for buffering on the <em>receiver's</em> side. If the receiving application needs the entire concatenated string value, or needs access to all array elements simultaneously, before it can perform its processing, it will still have to accumulate the incoming chunks or elements in memory until the <code>0xff</code> break code is received. The primary benefit of streaming often accrues to the sender by reducing memory requirements and latency-to-first-byte, but the receiver's processing model dictates whether it can also process the data incrementally or must buffer.</li>
<li><strong>Nesting Complexity:</strong> Parsing nested indefinite-length items requires careful management. When a parser encounters an indefinite-length start marker while already parsing another indefinite-length item, it must correctly associate the eventual <code>0xff</code> break codes with their corresponding start markers. This is typically handled using a stack internally within the parser to keep track of the nesting depth and the type of indefinite item currently being parsed.</li>
</ul>
<h2 id="indefinite-length-items-in-the-wild"><a class="header" href="#indefinite-length-items-in-the-wild">Indefinite-Length Items in the Wild</a></h2>
<p>While indefinite-length encoding is a standard part of the CBOR specification ((<a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a>)), its adoption in specific protocols and applications appears less widespread than definite-length encoding.</p>
<p>As mentioned, CoAP Block-Wise Transfers ((<a href="https://datatracker.ietf.org/doc/html/rfc7959">RFC-7959</a>)) provides a mechanism conceptually similar to streaming, allowing large resources (which might be represented in CBOR) to be transferred in chunks over constrained networks. However, the specification focuses on the CoAP-level blocking and doesn't mandate the use of CBOR indefinite-length encoding <em>within</em> those blocks. Implementations often favor definite-length CBOR for the block payloads due to simpler handling and the deterministic nature often desired, even if the overall resource size isn't known initially by the CoAP endpoints.</p>
<p>Finding other prominent, standardized protocols that <em>mandate</em> or heavily rely on CBOR indefinite-length encoding can be challenging. This might be partly attributed to the implications for deterministic encoding (discussed next) and the fact that many applications prioritize predictability or can manage buffering to determine definite lengths.</p>
<p>Nonetheless, the mechanism exists as a standard tool for scenarios where a sender truly cannot determine the size beforehand, particularly in highly resource-constrained environments or pure streaming pipelines where avoiding buffering on the sender side is paramount.</p>
<h2 id="why-not-deterministic-the-canonical-conundrum"><a class="header" href="#why-not-deterministic-the-canonical-conundrum">Why Not Deterministic? The Canonical Conundrum</a></h2>
<p>One of the most significant implications of indefinite-length encoding is its incompatibility with <em>deterministic</em> encoding requirements.</p>
<p><strong>The Goal of Deterministic Encoding:</strong> As outlined in RFC 8949, Section 4.2 ("Core Deterministic Encoding Requirements"), and forming the basis for profiles like dCBOR, the primary goal of deterministic encoding is to ensure that any given CBOR data model instance has <strong>exactly one</strong>, unambiguous, canonical binary representation. This property is absolutely critical for several use cases:</p>
<ul>
<li><strong>Cryptographic Signatures:</strong> To verify a digital signature over CBOR data, the verifier must be able to reconstruct the exact sequence of bytes that was originally hashed and signed. If multiple valid encodings exist for the same logical data, signature verification becomes unreliable or impossible.</li>
<li><strong>Hashing:</strong> When using cryptographic hashes for data integrity checks, content addressing (like in distributed systems or blockchains), or indexing, it's essential that identical data always produces the identical hash. This requires a single, canonical byte representation.</li>
<li><strong>Data Comparison:</strong> In databases or distributed systems, comparing data items for equality often relies on simple byte-wise comparison for efficiency. This only works correctly if the encoding is canonical.</li>
</ul>
<p><strong>The Ambiguity of Indefinite-Length:</strong> Indefinite-length encoding fundamentally breaks the canonical requirement because it allows the same logical data (a specific string, array, or map) to be encoded into multiple, different byte sequences based solely on how the sender chooses to chunk the data (for strings) or simply by virtue of using the indefinite markers instead of definite ones.</p>
<p>Consider the simple byte string <code>h'01020304'</code>:</p>
<ul>
<li><strong>Definite-Length Encoding (Canonical):</strong> <code>44 01020304</code> (1 initial byte + 4 content bytes = 5 bytes total)</li>
<li><strong>Indefinite-Length (1 chunk):</strong> <code>5f 44 01020304 ff</code> (1 start byte + 1 chunk header byte + 4 content bytes + 1 break byte = 7 bytes total)</li>
<li><strong>Indefinite-Length (2 chunks):</strong> <code>5f 42 0102 42 0304 ff</code> (1 start + 1+2 chunk1 + 1+2 chunk2 + 1 break = 8 bytes total)</li>
<li><strong>Indefinite-Length (4 chunks):</strong> <code>5f 41 01 41 02 41 03 41 04 ff</code> (1 start + 4*(1+1) chunks + 1 break = 10 bytes total)</li>
</ul>
<p>All four representations above correspond to the same logical sequence of four bytes. However, they result in distinct binary encodings (<code>44...</code>, <code>5f 44...</code>, <code>5f 42...</code>, <code>5f 41...</code>).</p>
<p><strong>Violation of Canonical Requirement:</strong> This inherent possibility of multiple valid byte sequences for identical data directly violates the core principle of deterministic, canonical encoding. There is no single "preferred" way to chunk an indefinite-length string, making the representation inherently ambiguous from a byte-sequence perspective.</p>
<p><strong>Exclusion from Deterministic Profiles:</strong> Consequently, specifications defining deterministic CBOR encoding, such as RFC 8949 Section 4.2.2 ("Length-Determinism"), explicitly <strong>forbid</strong> the use of indefinite-length encoding. Any data item whose initial byte is <code>5f</code>, <code>7f</code>, <code>9f</code>, or <code>bf</code> is disallowed in contexts requiring Core Deterministic Encoding or similar canonical profiles. This exclusion is not arbitrary; it is a necessary consequence of prioritizing byte-for-byte reproducibility over the flexibility offered by indefinite-length streaming. Applications requiring canonical forms <em>must</em> use definite-length encoding, which necessitates knowing the size of strings and the counts for collections before serialization.</p>
<h2 id="conclusion-flexibility-vs-predictability"><a class="header" href="#conclusion-flexibility-vs-predictability">Conclusion: Flexibility vs. Predictability</a></h2>
<p>Indefinite-length encoding stands as a specialized feature within the CBOR standard, designed to address the practical challenge of serializing data whose size is unknown when encoding begins. By using dedicated start markers (<code>5f</code>, <code>7f</code>, <code>9f</code>, <code>bf</code>) based on Major Type combined with Additional Information 31, and a universal <code>0xff</code> break code, CBOR allows byte strings, text strings, arrays, and maps to be constructed incrementally. For strings, this involves concatenating definite-length chunks; for collections, it involves appending elements or key-value pairs sequentially until the break code is encountered.</p>
<p>The primary advantage of this mechanism is its ability to support streaming applications, enabling senders (especially those with limited memory or needing low latency) to transmit data without first buffering the entire object to calculate its size.</p>
<p>However, this flexibility comes with significant trade-offs, including non-canonical representations leading to exclusion from deterministic profiles, potential overhead in encoding size, and increased complexity in parsing logic. The requirement for UTF-8 integrity in indefinite-length text strings and dealing with nested indefinite items adds further complexity for implementers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbor-sequences-streaming-independent-data-items"><a class="header" href="#cbor-sequences-streaming-independent-data-items">CBOR Sequences: Streaming Independent Data Items</a></h1>
<h2 id="introduction-beyond-single-items"><a class="header" href="#introduction-beyond-single-items">Introduction: Beyond Single Items</a></h2>
<p>Previous chapters have explored the encoding of individual Concise Binary Object Representation (CBOR) data items, covering fundamental types like integers, strings, booleans, and null, as well as structured types like arrays and maps. We examined how definite-length and indefinite-length encodings work, and how semantic tags (Major Type 6) extend the basic data model. The focus thus far has been on representing self-contained, individual data structures, analogous to a single JSON document or a distinct object in memory.</p>
<p>However, many real-world applications involve data that doesn't naturally fit into a single, monolithic structure. Consider scenarios like generating log entries over time, receiving a continuous stream of sensor measurements, or exchanging a series of independent commands and responses between systems. While it's possible to wrap such sequences within a top-level CBOR array (Major Type 4), perhaps even an indefinite-length one, this approach can be inefficient or semantically awkward. It forces a collection structure onto items that might be fundamentally independent, and it requires either knowing the total count upfront (for definite-length arrays) or managing start and end markers (for indefinite-length arrays).</p>
<p>To address these scenarios more directly and efficiently, the IETF defined <strong>CBOR Sequences</strong> in (<a href="https://datatracker.ietf.org/doc/html/rfc8742">RFC-8742</a>). A CBOR Sequence provides a way to represent a stream or series of distinct CBOR data items without enclosing them in an overarching container like an array.</p>
<p>Formally, a CBOR Sequence is defined recursively as a sequence of bytes that is either:</p>
<ol>
<li>An empty (zero-length) sequence of bytes.</li>
<li>The sequence of bytes representing a single, well-formed encoded CBOR data item (as defined in (<a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a>)), immediately followed by another CBOR Sequence.</li>
</ol>
<p>In essence, a CBOR Sequence is generated by simply <strong>concatenating</strong> the binary encodings of zero or more individual CBOR data items. This concatenation is the core mechanism. Crucially, there are <strong>no explicit delimiters, framing bytes, or termination markers</strong> inserted between the constituent CBOR items within the sequence itself. This minimalist design is possible because standard CBOR data items are inherently self-delimiting; the initial byte(s) of any CBOR item contain information about its type and length (or value), allowing a parser to determine exactly where that item ends and the next one begins. This contrasts sharply with formats like JSON Text Sequences ((<a href="https://datatracker.ietf.org/doc/html/rfc7464">RFC-7464</a>)), which require explicit markers (like the ASCII Record Separator character followed by a newline) between JSON texts because JSON values themselves are not always self-delimiting when concatenated.</p>
<p>The official media type associated with this format is <code>application/cbor-seq</code>. Additionally, the structured syntax suffix <code>+cbor-seq</code> has been registered, allowing other media types to indicate that their underlying structure is a CBOR Sequence, analogous to how <code>+cbor</code> signifies a base of a single CBOR item.</p>
<p>This definition highlights the fundamental simplicity of CBOR Sequences – mere concatenation. The absence of sequence-level headers, item counts, or termination markers is a deliberate design choice rooted in CBOR's self-describing nature. Since each CBOR item encodes its own type and length, a parser can theoretically determine item boundaries without extra framing. Adding such framing would introduce overhead, running counter to CBOR's goal of conciseness, particularly for applications streaming many small items. However, this simplicity places the responsibility of determining the overall <em>end</em> of the sequence entirely on mechanisms external to the sequence format itself, such as the end of a file or the closure of a network connection. This characteristic has significant implications for how sequences are transported and how errors are handled, which will be explored later in this chapter.</p>
<h2 id="why-cbor-sequences-technical-motivations"><a class="header" href="#why-cbor-sequences-technical-motivations">Why CBOR Sequences? Technical Motivations</a></h2>
<p>The design of CBOR Sequences stems from specific technical requirements where traditional single-item encodings or array structures fall short. The primary motivations include enabling efficient streaming, facilitating incremental processing, offering potential efficiency gains over arrays, and leveraging the simplicity of concatenation.</p>
<ul>
<li>
<p><strong>Streaming Data:</strong> CBOR Sequences are particularly well-suited for scenarios where data is generated or consumed continuously over time, and the total volume or number of items is not known when the process begins. Common examples include streaming application logs, transmitting time-series sensor data from IoT devices, or handling real-time event feeds. In such cases, appending a new, independently encoded CBOR item to the end of an existing sequence is straightforward. This contrasts with definite-length CBOR arrays, which require the element count to be specified upfront, and indefinite-length arrays, which, while streamable, still represent a single logical collection that must eventually be terminated by a specific 'break' byte (<code>0xFF</code>). Sequences allow indefinite extension without modifying previously transmitted data.</p>
</li>
<li>
<p><strong>Incremental Processing:</strong> A key advantage is that sequences allow both producers and consumers to operate on discrete items one at a time. A producer can fully encode and transmit a single CBOR item. A consumer can receive the bytes for that item, decode it completely, and process it before the next item even begins to arrive. This model avoids the need for complex streaming parsers or encoders that must handle partially received or generated structures (like elements within a large array). This simplification is especially valuable for resource-constrained environments, such as IoT devices, where memory limitations might make buffering large, monolithic arrays impractical.</p>
</li>
<li>
<p><strong>Efficiency Compared to Arrays:</strong> When representing a list or sequence of items, CBOR arrays (Major Type 4) introduce a small amount of overhead. A definite-length array requires an initial byte (or potentially more for very large counts) to encode the number of elements it contains. An indefinite-length array requires an initial byte indicating the indefinite type (<code>0x9F</code> for arrays, <code>0xBF</code> for maps) and must be terminated by a final <code>0xFF</code> break byte. For a sequence containing <em>N</em> items, using a CBOR array introduces 1 to 9 bytes of structural overhead (for the count or start/end markers). In contrast, a CBOR Sequence adds <em>zero</em> bytes of overhead beyond the concatenated bytes of the items themselves. While this overhead is often negligible, it can become significant when dealing with a very large number of very small items, a common pattern in sensor data or event streams.</p>
</li>
<li>
<p><strong>Simplicity of Concatenation:</strong> The definition itself highlights this: generating a CBOR Sequence is achieved simply by concatenating the byte representations of individually encoded CBOR items. Furthermore, concatenating two valid CBOR Sequences always results in another valid CBOR Sequence. This property can simplify certain data aggregation pipelines or forwarding proxies where streams of CBOR items from different sources need to be merged.</p>
</li>
</ul>
<p>These motivations reveal a fundamental design choice: CBOR Sequences prioritize the representation of a <em>flow</em> of independent items over a <em>structured collection</em>. CBOR arrays and maps (Major Types 4 and 5) represent semantically coherent, single data items within the CBOR data model; they possess a defined structure and element/pair count. Sequences, lacking this inherent enclosing structure, are better suited for streams where items might be processed individually and may not form a single logical entity. The decision between using an array or a sequence often hinges on whether the data is conceptually viewed as "one large object containing parts" or "many small, sequential objects". If the application requires an explicit marker for the end of the sequence within the data stream itself, (<a href="https://datatracker.ietf.org/doc/html/rfc8742">RFC-8742</a>) suggests that encoding the items within a CBOR array might be the more appropriate representation. Choosing sequences implies a shift away from processing a single, potentially large, structure towards processing a series of smaller, independent units.</p>
<h2 id="encoding-simple-concatenation"><a class="header" href="#encoding-simple-concatenation">Encoding: Simple Concatenation</a></h2>
<p>The mechanism for encoding a CBOR Sequence is remarkably straightforward: individually encode each constituent data item according to the standard CBOR encoding rules defined in (<a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a>) (and detailed in a preceding chapter), and then simply concatenate the resulting byte strings in the desired order. No additional bytes, delimiters, or framing information are introduced between the encoded items as part of the sequence format itself.</p>
<p>Let's illustrate this with hexadecimal examples:</p>
<ul>
<li>
<p>Example 1: Simple Sequence</p>
<p>Consider encoding the sequence of values: 1, then "foo", then true.</p>
<ol>
<li>The integer <code>1</code> (Unsigned Integer, Major Type 0, Additional Information 1) encodes as a single byte: <code>01</code>.</li>
<li>The text string <code>"foo"</code> (Text String, Major Type 3, Additional Information 3 indicates length 3) encodes as the header byte <code>63</code> followed by the 3 UTF-8 bytes for "foo" (<code>66 6f 6f</code>): <code>63 666f6f</code>.</li>
<li>The boolean <code>true</code> (Simple Value, Major Type 7, Additional Information 21) encodes as a single byte: <code>f5</code>. The resulting CBOR Sequence is the direct concatenation: <code>01 63 666f6f f5</code>.</li>
</ol>
</li>
<li>
<p>Example 2: Sequence Containing Structured Items</p>
<p>Consider encoding the sequence: <code>[10, false]</code>, then <code>{"a": -1}</code>.</p>
<ol>
<li>The array <code>[10, false]</code> (Array, Major Type 4, Additional Information 2 indicates 2 elements) encodes as: <code>82</code> (header) followed by <code>0a</code> (encoding for 10) and <code>f4</code> (encoding for false): <code>82 0a f4</code>.</li>
<li>The map <code>{"a": -1}</code> (Map, Major Type 5, Additional Information 1 indicates 1 pair) encodes as: <code>a1</code> (header) followed by <code>61 61</code> (encoding for key "a") and <code>20</code> (encoding for value -1): <code>a1 61 61 20</code>. The resulting CBOR Sequence is the concatenation: <code>82 0a f4 a1 61 61 20</code>.</li>
</ol>
</li>
<li>
<p>Example 3: Empty Sequence</p>
<p>An empty CBOR Sequence, containing zero items, is represented by an empty (zero-length) sequence of bytes.</p>
</li>
</ul>
<p>It is instructive to contrast the CBOR Sequence encoding with CBOR array encodings for the same logical list of items. Taking the data from Example 1 (<code>1</code>, <code>"foo"</code>, <code>true</code>):</p>
<ul>
<li><strong>As a Definite-Length Array <code>[1, "foo", true]</code>:</strong> Encoded as <code>83 01 63 666f6f f5</code>. The initial byte <code>83</code> signifies Major Type 4 (Array) with Additional Information 3 (three elements follow).</li>
<li><strong>As an Indefinite-Length Array <code>[1, "foo", true]</code>:</strong> Encoded as <code>9f 01 63 666f6f f5 ff</code>. This starts with <code>9f</code> (Major Type 4, AI 31 - indefinite-length array), includes the encoded elements, and ends with the <code>ff</code> (Major Type 7, AI 31 - break code) marker.</li>
</ul>
<p>The following table summarizes these differences visually, including a comparison to JSON:</p>
<div class="table-wrapper"><table><thead><tr><th>Data Model</th><th>Representation</th><th>Hexadecimal Encoding</th><th>Overhead Bytes</th><th>Framing Mechanism</th></tr></thead><tbody>
<tr><td><code>[1, "foo", true]</code></td><td>JSON</td><td><code>[31, 2c, 22 66 6f 6f 22, 2c, 74 72 75 65]</code> (ASCII)</td><td>Variable</td><td>Text delimiters (<code>[</code>, <code>,</code>, <code>]</code>)</td></tr>
<tr><td><code>[1, "foo", true]</code></td><td>CBOR Definite Array</td><td><code>83 01 63 666f6f f5</code></td><td>1 (<code>83</code>)</td><td>Initial byte (Type 4 + Count 3)</td></tr>
<tr><td><code>[1, "foo", true]</code></td><td>CBOR Indefinite Array</td><td><code>9f 01 63 666f6f f5 ff</code></td><td>2 (<code>9f</code>, <code>ff</code>)</td><td>Start marker (<code>9f</code>) + Break (<code>ff</code>)</td></tr>
<tr><td><code>1, "foo", true</code></td><td>CBOR Sequence</td><td><code>01 63 666f6f f5</code></td><td>0</td><td>None (Self-delimiting items)</td></tr>
</tbody></table>
</div>
<p>This comparison clearly shows that CBOR Sequences eliminate the structural overhead associated with arrays by relying entirely on the self-delimiting nature of the constituent CBOR items. This byte-level difference underscores the efficiency motivation, especially for streams of numerous small items.</p>
<h2 id="decoding-reading-item-by-item"><a class="header" href="#decoding-reading-item-by-item">Decoding: Reading Item by Item</a></h2>
<p>Decoding a CBOR Sequence involves processing the input byte stream iteratively or recursively, extracting one complete CBOR data item at a time until the stream is exhausted. The fundamental process is:</p>
<ol>
<li><strong>Check for End:</strong> Determine if the input stream or remaining buffer is empty. If it is, the sequence decoding is complete.</li>
<li><strong>Decode Item:</strong> Attempt to decode a single, complete CBOR data item starting from the current position in the stream/buffer. This requires the decoder to correctly interpret the initial byte(s) to understand the item's major type, additional information, and any subsequent length or value bytes, thereby determining the total number of bytes constituting this single item.</li>
<li><strong>Yield and Consume:</strong> If decoding the item is successful, yield or otherwise process the resulting data model value. Advance the position in the stream/buffer by the number of bytes consumed by the decoded item.</li>
<li><strong>Repeat:</strong> Go back to Step 1 with the remainder of the stream/buffer.</li>
</ol>
<p>The self-delimiting property of standard CBOR items is the cornerstone of this process; the decoder must be able to precisely identify the boundaries of each item based solely on the CBOR encoding rules.</p>
<p><strong>Handling Stream Boundaries and Errors:</strong></p>
<ul>
<li><strong>Normal Termination:</strong> Successful decoding concludes when the input stream is fully consumed exactly after a complete CBOR item has been decoded.</li>
<li><strong>Truncation:</strong> If the input stream ends unexpectedly <em>while</em> decoding an item (i.e., the header indicates more bytes are needed than are available), this signifies truncation. A decoder designed for streaming data might pause at this point, waiting for more bytes to arrive before declaring an error. For file-based decoding, this typically indicates an incomplete file.</li>
<li><strong>Malformed Item:</strong> If the bytes encountered do not form a well-formed CBOR data item (e.g., invalid major type/additional information combination, inconsistent length information), the decoder loses its ability to determine where the erroneous item ends. Because there are no explicit delimiters between items in a sequence, the decoder cannot reliably find the beginning of the <em>next</em> potential item. Consequently, a single malformed item usually prevents the decoding of the remainder of the sequence. While sophisticated error recovery might be attempted in some implementations, it is not guaranteed by the specification.</li>
<li><strong>Missing Items:</strong> The CBOR Sequence format itself provides no way to detect if expected items are simply absent from the <em>end</em> of the sequence. If the stream terminates cleanly after the last item that was actually present, the decoder will report success. Detecting missing items requires application-level logic, such as checking expected counts, using timeouts in network protocols, or implementing specific acknowledgement mechanisms.</li>
</ul>
<p>The fragility in the face of malformed items is a direct consequence of the design choice to omit explicit delimiters for the sake of conciseness. Unlike newline-delimited formats like NDJSON, where a parser can often resynchronize by searching for the next newline character even after encountering invalid JSON, a CBOR Sequence parser relies entirely on the internal integrity of each item to navigate the byte stream. If an item's structure is compromised, the parser effectively becomes lost. This implies that applications relying on CBOR Sequences should prioritize robust data validation <em>before</em> or <em>during</em> sequence generation, or they must be prepared for the possibility that transmission errors affecting a single item could render a large portion of a sequence unusable. For applications demanding higher resilience against such errors, incorporating additional framing or error-checking mechanisms at a higher protocol layer might be necessary.</p>
<h2 id="cbor-sequences-in-diagnostic-notation"><a class="header" href="#cbor-sequences-in-diagnostic-notation">CBOR Sequences in Diagnostic Notation</a></h2>
<p>The current draft for <a href="https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-16.html">CBOR Extended Diagnostic Notation</a> (EDN) proposes a way to represent CBOR Sequences in a human-readable format using <code>&lt;&lt;</code> and <code>&gt;&gt;</code> as delimiters, with the items separated by commas:</p>
<pre><code>&lt;&lt; item1, item2, item3, ... &gt;&gt;
</code></pre>
<p>The sequence from the example given above would be represented as:</p>
<pre><code>&lt;&lt; 1, "foo", true &gt;&gt;
</code></pre>
<p>If you enter this into the <a href="https://cbor.me">CBOR Playground</a> and convert it to the serialized hexadecimal representation, you'll see that it converts the sequence to a CBOR byte string:</p>
<pre><code>46              # bytes(6)
   0163666F6FF5
</code></pre>
<p>If we manually parse this out, we can see that the first byte <code>0x46</code> indicates a byte string of length 6, followed by the bytes for the integer <code>1</code>, the string <code>"foo"</code>, and the boolean <code>true</code> with no other delimiters or framing:</p>
<pre><code>46              # bytes(6)
   01           # unsigned(1)
   63666F6F     # "foo"
   F5           # true
</code></pre>
<p>The fact that the byte string header <code>0x46</code> is included might be confusing, as it implies that the sequence is a single item.</p>
<p>When we convert the serialized sequence back into diagnostic notation, we just get the byte string representation, as we would expect:</p>
<pre><code>h'0163666F6FF5'
</code></pre>
<p>CBOR arrays begin with a header that specifies the array's fixed length, and indefinite-length arrays begin with the <em>indefinite array</em> item and end with the <em>break</em> item. But sequences do not themselves have delimiters or other framing.</p>
<p>The EDN notation is just a way to represent the sequence in a human-readable format, but it does not change the underlying encoding of the sequence itself. Sequences serialized this way are therefor not self-identifying. A CBOR decoder could be instructed to decode a byte string as a sequence, but the fact that it <em>is</em> a sequence cannot be determined by inspecting the byte string itself.</p>
<h2 id="practical-use-cases"><a class="header" href="#practical-use-cases">Practical Use Cases</a></h2>
<p>The characteristics of CBOR Sequences make them suitable for a variety of applications, particularly those involving streams or sequences of independent data units.</p>
<ul>
<li>
<p><strong>Streaming Applications:</strong> This is a primary motivator for CBOR Sequences.</p>
<ul>
<li><strong>Logs, Metrics, and Events:</strong> Systems generating continuous streams of structured log entries, performance metrics, or discrete events can encode each entry/event as an individual CBOR item and concatenate them into a sequence for transmission or storage. The low overhead is advantageous, and the independence of items aligns well with the nature of logs or events.</li>
<li><strong>Sensor Data Feeds:</strong> IoT devices often transmit time-series data from sensors. Using CBOR Sequences allows sending each reading or batch of readings as a separate item, benefiting from CBOR's general compactness and avoiding the per-sequence overhead of arrays, which can be significant for frequent, small readings.</li>
</ul>
</li>
<li>
<p><strong>Record Sequences (Binary NDJSON Equivalent):</strong> CBOR Sequences provide a binary alternative to text-based formats like Newline Delimited JSON (<a href="https://github.com/ndjson/ndjson-spec">NDJSON</a>) or JSON Lines (<a href="https://jsonlines.org/">JSONL</a>). They can be used for efficiently transferring large datasets as a sequence of records, such as rows from a database query or batches of results from an API, allowing for incremental processing on the receiving end. The key advantage over NDJSON is the potential for smaller size and faster parsing due to the binary encoding and native support for binary data types without base64 encoding.</p>
</li>
<li>
<p><strong>Message Delimitation in Protocols:</strong> In network protocols built on persistent connections (like TCP or WebSockets), where multiple distinct messages need to be exchanged, each message can be encoded as a single CBOR data item. A CBOR Sequence can represent the stream of these messages. For example, a sequence of Remote Procedure Call (RPC) requests or responses, or a stream of server-sent events, could be structured this way. However, a critical caveat applies: the CBOR Sequence format <em>itself</em> does not provide message framing over stream transports like raw TCP. The protocol implementation must rely on the transport layer (e.g., WebSocket message boundaries) or add its own framing mechanism (like length prefixing) to allow the receiver to distinguish individual messages within the stream.</p>
</li>
<li>
<p><strong>Sequential File Formats:</strong> Large datasets can be stored in files as a CBOR Sequence, allowing applications to read or write the file incrementally, processing one CBOR item at a time without loading the entire file into memory. This approach might be combined with proposed mechanisms for adding CBOR magic numbers or tags at the beginning of the file or sequence for identification purposes.</p>
</li>
</ul>
<p>Observing these use cases reveals a common underlying pattern: they often rely on an <em>external</em> mechanism to determine the boundaries of the sequence or the items within it, especially in streaming contexts. CBOR Sequence defines the <em>content</em> format (concatenated self-delimiting items) but not the <em>framing</em> for transport or storage. Streaming logs over TCP relies on the connection lifecycle or application-level protocols; WebSocket usage relies on WebSocket framing; file storage relies on the end-of-file marker. Therefore, while CBOR Sequences offer an efficient encoding for sequential data, engineers must consciously address how these sequences (or the individual items within them) are delimited and detected within the specific transport or storage context being used. Relying solely on the CBOR Sequence format definition without considering this framing aspect can lead to implementation pitfalls.</p>
<h2 id="comparison-with-alternatives"><a class="header" href="#comparison-with-alternatives">Comparison with Alternatives</a></h2>
<p>Choosing the right data representation format involves understanding the trade-offs. CBOR Sequences should be compared against other relevant CBOR structures (arrays) and common streaming formats (like NDJSON).</p>
<ul>
<li>
<p><strong>CBOR Sequences vs. CBOR Arrays (Definite and Indefinite):</strong></p>
<ul>
<li><strong>Structure:</strong> A fundamental difference lies in the data model. A CBOR Sequence represents multiple, independent top-level data items concatenated together. A CBOR Array (Major Type 4) is always a <em>single</em> top-level data item, whose content is an ordered list of elements.1</li>
<li><strong>Framing:</strong> Sequences have no internal framing; boundaries are implicit based on item self-delimitation. Definite-length arrays encode the element count in their header. Indefinite-length arrays use a specific start byte (<code>0x9F</code>) and require a terminating <code>0xFF</code> break byte.1</li>
<li><strong>Overhead:</strong> Sequences introduce zero framing overhead. Definite arrays add 1-9 bytes for the count. Indefinite arrays add exactly 2 bytes (<code>0x9F</code> + <code>0xFF</code>).</li>
<li><strong>Processing Model:</strong> Sequences naturally lend themselves to item-by-item streaming and processing. While indefinite-length arrays also allow streaming of their <em>elements</em>, they are still conceptually processed as a single array unit that is only complete upon encountering the <code>0xFF</code> marker. Definite-length arrays typically imply processing as a whole unit once all elements are received.</li>
<li><strong>Use Case Alignment:</strong> Sequences are ideal for streams of independent items, especially when the total count is unknown or potentially unbounded, and minimizing overhead is paramount. Arrays are better suited when the data represents a single, semantically coherent list, the structure of the collection itself is significant, and an explicit end marker (for indefinite) or count (for definite) is desirable within the CBOR structure itself.</li>
<li><strong>Error Handling:</strong> As discussed, a malformed item in a sequence can prevent decoding the rest of the stream. Errors within an array element might be more contained, although recovery, especially in indefinite arrays, can still be challenging.</li>
</ul>
</li>
<li>
<p><strong>CBOR Sequences vs. NDJSON / JSON Lines:</strong></p>
<ul>
<li><strong>Encoding:</strong> Sequences use CBOR's binary encoding, which is typically more compact and faster to parse than NDJSON's text-based JSON encoding for each line.</li>
<li><strong>Delimitation:</strong> Sequences rely on the self-delimiting nature of CBOR items. NDJSON uses an explicit newline character (<code>\n</code>) after each JSON text, making it line-oriented.</li>
<li><strong>Efficiency:</strong> CBOR Sequences generally offer better performance in terms of size and processing speed due to their binary nature.</li>
<li><strong>Error Handling:</strong> The explicit newline delimiter in NDJSON often makes it easier for parsers to skip over a malformed JSON line and attempt to process the next one. CBOR Sequences lack this explicit delimiter, making recovery from malformed items harder.</li>
<li><strong>Binary Data:</strong> CBOR has native support for byte strings (Major Type 2), allowing efficient embedding of binary data. NDJSON requires binary data to be encoded within JSON strings, typically using Base64, which adds significant size overhead (around 33%) and processing complexity.</li>
<li><strong>Human Readability:</strong> NDJSON, being text-based, is human-readable with standard text tools. CBOR Sequences require specialized tools for inspection.</li>
</ul>
</li>
</ul>
<p>The following table summarizes the key characteristics of these alternatives:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>CBOR Sequence</th><th>CBOR Indefinite Array</th><th>NDJSON / JSON Lines</th></tr></thead><tbody>
<tr><td><strong>Encoding</strong></td><td>Binary</td><td>Binary</td><td>Text (JSON per line)</td></tr>
<tr><td><strong>Structure</strong></td><td>Concatenated items (multi-root)</td><td>Single array item (single root)</td><td>Concatenated lines (multi-root)</td></tr>
<tr><td><strong>Item Delimitation</strong></td><td>Implicit (self-delimiting)</td><td>Explicit (<code>0xFF</code> break marker)</td><td>Explicit (newline <code>\n</code>)</td></tr>
<tr><td><strong>Overhead</strong></td><td>None (beyond items)</td><td>2 bytes (<code>0x9F</code>/<code>0xBF</code> + <code>0xFF</code>)</td><td>1 byte per item (<code>\n</code>)</td></tr>
<tr><td><strong>Processing</strong></td><td>Item-by-item (native streaming)</td><td>Element-by-element streaming</td><td>Line-by-line (native streaming)</td></tr>
<tr><td><strong>Readability</strong></td><td>Low (requires tools)</td><td>Low (requires tools)</td><td>High (text editor-friendly)</td></tr>
<tr><td><strong>Binary Data</strong></td><td>Native (byte strings)</td><td>Native (byte strings)</td><td>Requires Base64 encoding</td></tr>
<tr><td><strong>Error Recovery</strong></td><td>Difficult (malformed item breaks stream)</td><td>Difficult (malformed element)</td><td>Easier (can skip bad lines)</td></tr>
<tr><td><strong>Standard</strong></td><td>RFC 8742</td><td>RFC 8949</td><td>Informal spec (ndjson.org)</td></tr>
</tbody></table>
</div>
<p>This comparison highlights that CBOR Sequences offer a high-performance, low-overhead binary format for streaming independent items, trading off some error recovery robustness and human readability compared to text-based alternatives like NDJSON, and differing structurally from CBOR arrays.</p>
<h2 id="practical-advice-for-engineers"><a class="header" href="#practical-advice-for-engineers">Practical Advice for Engineers</a></h2>
<p>When considering or implementing CBOR Sequences, several practical aspects require attention to ensure correct and robust behavior.</p>
<ul>
<li>
<p><strong>Guidance: When to Choose Sequences Over Arrays:</strong></p>
<ul>
<li><strong>Favor Sequences when:</strong>
<ul>
<li>The data naturally represents a stream of independent records, events, or messages.</li>
<li>The total number of items is unknown upfront or potentially unbounded.</li>
<li>Minimizing encoding overhead is a primary concern (e.g., for high-frequency, small items).</li>
<li>Incremental, item-by-item processing is the desired model for both producer and consumer.</li>
<li>The simplicity of direct concatenation aligns with the application logic (e.g., merging streams).</li>
</ul>
</li>
<li><strong>Favor Arrays (Definite or Indefinite) when:</strong>
<ul>
<li>The data represents a single, semantically coherent collection or list.</li>
<li>The overall structure of the collection itself is meaningful.</li>
<li>The total count of items is known (definite) or will eventually be known (indefinite).</li>
<li>An explicit end marker within the CBOR data stream itself is required (indefinite arrays provide <code>0xFF</code>).</li>
<li>Compatibility with systems expecting a single top-level CBOR item is necessary.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Transport Layer Considerations (Framing):</strong></p>
<ul>
<li>A critical point often overlooked is that <strong>CBOR Sequence format does not inherently solve message framing over stream-based transports like TCP</strong>. TCP provides a reliable byte stream, but it does not preserve message boundaries. Sending a raw CBOR Sequence (concatenated items) over TCP means the receiver might receive partial items, multiple items, or parts of multiple items in a single <code>read()</code> call. The receiver cannot reliably identify item boundaries just by looking at TCP packet arrivals.</li>
<li>To handle this, a framing mechanism must be implemented <em>above</em> TCP but <em>below</em> or <em>as part of</em> the application logic utilizing CBOR Sequences:
<ul>
<li><strong>Length Prefixing:</strong> Before sending each CBOR item, transmit its length as a fixed-size integer (e.g., 4 bytes network order) or a variable-length integer (like Protobuf varints). The receiver first reads the length, then reads exactly that many bytes to get the complete CBOR item. This is a common pattern but reintroduces framing overhead.</li>
<li><strong>Delimiter-Based Framing:</strong> Use a specific byte sequence (chosen carefully to avoid collision with valid CBOR data) to mark the end of one CBOR item and the start of the next. This is generally less robust and less common than length prefixing.</li>
<li><strong>Higher-Level Protocols:</strong> Utilize protocols that provide built-in message framing. WebSockets, for instance, delivers data in discrete messages; each WebSocket message could contain exactly one CBOR item from the sequence.15 HTTP/2 streams or QUIC streams also offer framing capabilities.</li>
<li><strong>Self-Contained Items:</strong> If each item in the sequence is itself a complex structure like a COSE object 11, it might be possible (though potentially complex) to parse partially received data to determine if a complete object has arrived. This relies heavily on the internal structure of each item.</li>
<li><strong>Connection Lifecycle:</strong> For simple request-response or single-shot transfers, closing the TCP connection can signal the end of the sequence or item. This is inefficient for continuous streams.</li>
</ul>
</li>
<li>The essential takeaway is that the application or protocol designer must explicitly choose and implement a framing strategy when using CBOR Sequences over raw stream transports.</li>
</ul>
</li>
<li>
<p><strong>Implementation Notes &amp; Common Patterns:</strong></p>
<ul>
<li><strong>Library Support:</strong> Check if the CBOR library being used offers specific support for sequences. For example, the Go <code>fxamacker/cbor</code> library provides <code>UnmarshalFirst</code> and <code>DiagnoseFirst</code> functions that decode only the first item from a byte slice and return the remaining bytes, facilitating iterative processing of a sequence. Standard <code>Unmarshal</code> functions in many libraries might error if trailing bytes exist after the first item, as per <a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a> for single items.</li>
<li><strong>Buffering:</strong> When reading from a network stream or file, employ appropriate buffering. Read data chunks into a buffer, attempt to decode one or more complete CBOR items from the buffer, consume the bytes corresponding to successfully decoded items, and handle cases where an item might be split across buffer boundaries (requiring more data to be read).</li>
<li><strong>Generators/Iterators:</strong> In programming languages offering generator functions or iterators (like Python, JavaScript, C#), these constructs provide an idiomatic way to implement a CBOR Sequence decoder. The decoder function can yield each successfully decoded item one at a time, naturally supporting the incremental processing model.</li>
</ul>
</li>
<li>
<p><strong>Potential Pitfalls:</strong></p>
<ul>
<li><strong>Framing Neglect:</strong> The most common pitfall is assuming CBOR Sequences provide message framing over TCP or similar streams. Always implement explicit framing.</li>
<li><strong>Error Handling Brittleness:</strong> Underestimating the consequence that a single malformed item can halt the processing of the rest of the sequence. Implement input validation or accept the potential for data loss on errors.</li>
<li><strong>Security Gaps:</strong> Remember that CBOR Sequences themselves offer no cryptographic protection. If integrity, authenticity, or confidentiality are required, each item (or potentially batches of items) must be individually protected using mechanisms like COSE. Securing the sequential relationship (preventing reordering, deletion, or insertion) often requires additional application-level mechanisms like sequence numbers or chained signatures.</li>
<li><strong>Resource Exhaustion:</strong> While sequences facilitate streaming, a naive decoder implementation that buffers all decoded items in memory before processing can still lead to memory exhaustion. Ensure that processing keeps pace with decoding in a truly incremental fashion.</li>
<li><strong>Ambiguity/Compatibility:</strong> Ensure both communicating parties understand that a CBOR Sequence is being used. Employing the <code>application/cbor-seq</code> media type or the <code>+cbor-seq</code> structured syntax suffix in protocols that support content types (like HTTP, CoAP) can help avoid ambiguity.</li>
</ul>
</li>
</ul>
<p>Understanding these points requires recognizing the layered nature of communication protocols. CBOR Sequence (RFC 8742) operates at the data representation layer, defining how to encode the <em>content</em> of a stream. Framing mechanisms (length prefixing, WebSocket messages) operate at the transport or session layer to define message <em>boundaries</em>. Security mechanisms like COSE operate at the application layer to protect the <em>content</em>. File system metadata or magic numbers provide context at the storage layer. Engineers must address requirements at each relevant layer; expecting the CBOR Sequence format alone to solve framing or security problems will lead to incomplete or flawed implementations.</p>
<h2 id="conclusion-sequences-in-the-cbor-ecosystem"><a class="header" href="#conclusion-sequences-in-the-cbor-ecosystem">Conclusion: Sequences in the CBOR Ecosystem</a></h2>
<p>CBOR Sequences should be viewed as a specific tool within the broader CBOR toolkit, complementing definite-length items, indefinite-length items (including arrays and maps), and semantic tags. They are the appropriate choice when the primary goal is to stream or serialize a sequence of independent CBOR items with minimal overhead, particularly when the total count is unknown. When data represents a single logical collection, or when explicit framing within the CBOR structure itself is desired, CBOR arrays remain the more suitable option.</p>
<p>Looking ahead, understanding CBOR Sequences provides context for related concepts:</p>
<ul>
<li><strong>CDDL (Concise Data Definition Language):</strong> While CDDL (<a href="https://datatracker.ietf.org/doc/html/rfc8610">RFC-8610</a>) is primarily used to define the structure of single CBOR data items, conventions exist to describe the expected content of items within a sequence. This often involves defining an array structure in CDDL and adding explanatory text stating that the elements represent the items in a sequence, or using the <code>.cborseq</code> control operator for sequences embedded within byte strings.6</li>
<li><strong>Deterministic Encoding:</strong> Rules for deterministic encoding, such as Core Deterministic Encoding defined in (<a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a>), apply to <em>each individual CBOR item</em> within a sequence if a canonical byte representation is required for those items.41 The sequence structure (concatenation) is itself inherently deterministic.</li>
</ul>
<p>By understanding the mechanics, motivations, and practical considerations of CBOR Sequences, engineers can effectively leverage this format for efficient data streaming and serialization in appropriate contexts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbor-schemas-with-cddl"><a class="header" href="#cbor-schemas-with-cddl">CBOR Schemas with CDDL</a></h1>
<h2 id="defining-structure-amidst-flexibility"><a class="header" href="#defining-structure-amidst-flexibility">Defining Structure Amidst Flexibility</a></h2>
<p>In previous chapters, we explored the fundamental mechanics of CBOR encoding, learning how basic data types like integers, strings, arrays, and maps are represented in binary. We saw how CBOR's structure, based on Major Types and Additional Information, allows for a self-describing format that is efficient, especially in constrained environments. However, while CBOR itself defines <em>how</em> individual data items are encoded, it doesn't inherently restrict the <em>overall structure</em> of the data exchanged between systems. An application might expect a map with specific keys and value types, or an array containing a precise sequence of elements. Without a way to formally define these expectations, interoperability relies solely on human-readable documentation and the diligence of implementers – a scenario prone to errors and ambiguity.</p>
<p>While CBOR itself is a schemaless and self-describing format, there are many times a formal schema can be helpful to define the structure of the data being exchanged. This is especially true in cases where the data is complex, or when multiple systems need to interoperate. A schema can help ensure that all parties agree on the expected structure and types of data, reducing the risk of errors and misunderstandings.</p>
<p>This is where the Concise Data Definition Language (CDDL) comes in. Standardized by the IETF in <a href="https://datatracker.ietf.org/doc/html/rfc8610">RFC-8610</a> (and updated by <a href="https://datatracker.ietf.org/doc/html/rfc9682">RFC-9682</a>), CDDL provides a formal, unambiguous, and human-readable notation specifically designed to express the structure of data formats that use CBOR (and, conveniently, JSON, due to its data model being a subset of CBOR's). Its primary goal is to make defining protocol messages and data formats easy and clear.  </p>
<p>Having understood <em>how</em> individual CBOR items are built, we now turn to specifying <em>what</em> structure those items should collectively form. This chapter introduces the essentials of CDDL, focusing on equipping engineers with the practical knowledge needed to define and understand CBOR schemas. We will cover:</p>
<ul>
<li>The core concepts and syntax of CDDL.</li>
<li>How to represent standard CBOR types and literal values.</li>
<li>Defining arrays, maps, and the crucial concept of CDDL <em>groups</em> for sequences.</li>
<li>Using operators to control occurrences, choices, and value constraints.</li>
<li>Building complex schemas by composing simpler, reusable rules.</li>
<li>The role of CDDL in data validation and the tooling ecosystem.</li>
</ul>
<p>A key focus will be understanding how CDDL models sequences of CBOR items using <em>groups</em>, a concept distinct from CBOR arrays or maps, and how this directly relates to the sequential nature of CBOR encoding. By the end of this chapter, you should be able to read and write basic CDDL schemas to define the structure of your CBOR data, laying the foundation for more robust and interoperable systems. We will prioritize practical application over exhaustive coverage of every CDDL feature, aiming for a solid working understanding rather than covering every detail of the full specification.</p>
<h2 id="validating-cddl-interactively"><a class="header" href="#validating-cddl-interactively">Validating CDDL Interactively</a></h2>
<p>Before diving into the details of CDDL, it's helpful to have a way to validate and experiment with CDDL schemas interactively. <a href="https://cddl.anweiss.tech/">cddl.anweiss.tech</a> provides a convenient online tool for this purpose.</p>
<h2 id="core-concepts-rules-assignments-and-types"><a class="header" href="#core-concepts-rules-assignments-and-types">Core Concepts: Rules, Assignments, and Types</a></h2>
<p>CDDL achieves its goal of unambiguous structure definition through a relatively simple grammar, inspired by Augmented Backus-Naur Form (ABNF) but tailored for CBOR/JSON data models. At its heart, a CDDL specification consists of one or more <em>rules</em>.  </p>
<h3 id="rules-and-assignments"><a class="header" href="#rules-and-assignments">Rules and Assignments</a></h3>
<p>A rule defines a name for a specific data structure or type constraint. The most basic assignment operator is <code>=</code>, which assigns a name (the <em>rule name</em>) on the left to a <em>type definition</em> on the right. Rule names are typically lowercase identifiers, potentially containing hyphens or underscores.</p>
<p>CDDL:</p>
<pre><code class="language-cddl">; This is a comment. Comments start with a semicolon and run to end-of-line.

my-first-rule = int  ; Assigns the name "my-first-rule" to the CBOR integer type.

device_id = uint     ; Assigns the name "device_id" to the CBOR unsigned integer type.
</code></pre>
<p>CDDL is whitespace-insensitive, except within literal strings. Comments are essential for documenting the schema and explaining the intent behind rules.</p>
<p>Besides the basic assignment <code>=</code>, CDDL provides two other assignment operators for extending existing rules:</p>
<ul>
<li><code>/=</code> Appends alternative choices to an existing rule. So a specification for an integer <em>or</em> a text string can be defined as:</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">my-rule = int / tstr
</code></pre>
<p>or alternatively:</p>
<p>CDDL:</p>
<pre><code class="language-cddl">my-rule = int
my-rule /= tstr
</code></pre>
<ul>
<li><code>//=</code> Appends alternative group choices to an existing rule. This is used for adding choices between sequences, which we'll explore when discussing groups.</li>
</ul>
<h3 id="the-prelude-standard-definitions"><a class="header" href="#the-prelude-standard-definitions">The Prelude: Standard Definitions</a></h3>
<p>Every CDDL specification implicitly includes a set of predefined rules known as the <em>prelude</em>. This prelude defines convenient names for common CBOR types and some basic constraints. You don't need to define these yourself; they are always available:  </p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>Basic Types</td><td><code>bool</code></td><td>Boolean value</td></tr>
<tr><td></td><td><code>uint</code></td><td>Unsigned integer (technically, a non-negative integer)</td></tr>
<tr><td></td><td><code>nint</code></td><td>Negative integer</td></tr>
<tr><td></td><td><code>int</code></td><td>Unsigned or negative integer</td></tr>
<tr><td></td><td><code>float16</code></td><td>16-bit floating point</td></tr>
<tr><td></td><td><code>float32</code></td><td>32-bit floating point</td></tr>
<tr><td></td><td><code>float64</code></td><td>64-bit floating point</td></tr>
<tr><td></td><td><code>float</code></td><td>Any floating point</td></tr>
<tr><td></td><td><code>bstr</code></td><td>Byte string</td></tr>
<tr><td></td><td><code>tstr</code></td><td>Text string</td></tr>
<tr><td></td><td><code>any</code></td><td>Any single CBOR data item</td></tr>
<tr><td>Constants</td><td><code>null</code></td><td>Null value</td></tr>
<tr><td></td><td><code>true</code></td><td>Boolean true</td></tr>
<tr><td></td><td><code>false</code></td><td>Boolean false</td></tr>
<tr><td></td><td><code>undefined</code></td><td>Undefined value</td></tr>
<tr><td>Aliases</td><td><code>nil</code></td><td>Alias for <code>null</code></td></tr>
<tr><td></td><td><code>bytes</code></td><td>Alias for <code>bstr</code></td></tr>
<tr><td></td><td><code>text</code></td><td>Alias for <code>tstr</code></td></tr>
</tbody></table>
</div>
<p>These prelude types form the building blocks for more complex definitions. For instance, instead of just saying <code>int</code>, you can often be more specific using <code>uint</code> or <code>nint</code> if the sign is known. Alternatively, a way to think about the definition of <code>int</code> is that it is a union of <code>uint</code> and <code>nint</code>, but the prelude provides a more convenient shorthand:</p>
<p>CDDL:</p>
<pre><code class="language-cddl">int = uint / nint
float = float16 / float32 / float64
</code></pre>
<h2 id="representing-basic-cbor-types-and-literals"><a class="header" href="#representing-basic-cbor-types-and-literals">Representing Basic CBOR Types and Literals</a></h2>
<p>CDDL provides direct ways to refer to the fundamental CBOR data types, largely leveraging the names defined in the prelude. It also allows specifying literal values that must appear exactly as written.</p>
<h3 id="standard-types"><a class="header" href="#standard-types">Standard Types</a></h3>
<p>As seen above, the prelude provides names for most standard CBOR types:</p>
<ul>
<li><strong>Integers</strong>: <code>uint</code>, <code>nint</code>, <code>int</code>.</li>
<li><strong>Floating-Point</strong>: <code>float16</code>, <code>float32</code>, <code>float64</code>, <code>float</code>. These correspond to the IEEE 754 half-, single-, and double-precision formats supported by CBOR's Major Type 7.</li>
<li><strong>Simple Values</strong>: <code>bool</code>, <code>true</code>, <code>false</code>, <code>null</code>, <code>undefined</code>. These map directly to the specific simple values in Major Type 7.</li>
<li><strong>Strings</strong>: <code>tstr</code> (UTF-8 text string, Major Type 3), <code>bstr</code> (byte string, Major Type 2).</li>
<li><strong>Catch-all</strong>: <code>any</code> represents any single, well-formed CBOR data item.</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">; Examples using standard types
message-counter = uint
temperature = float
is-active = bool
user-name = tstr
raw-payload = bstr
any-value = any ; Allows any CBOR item including `null`.
</code></pre>
<h3 id="literal-values"><a class="header" href="#literal-values">Literal Values</a></h3>
<p>CDDL allows you to specify that a data item must be a specific literal value:</p>
<ul>
<li><strong>Integers</strong>: <code>10</code>, <code>0</code>, <code>-1</code>, <code>42</code>.</li>
<li><strong>Floats</strong>: <code>1.5</code>, <code>-0.0</code>, <code>3.14159</code>.</li>
<li><strong>Text Strings</strong>: <code>"hello"</code>, <code>""</code>, <code>"a specific key"</code>. Text strings are enclosed in double quotes. Escaping rules similar to JSON apply within the CDDL source (e.g., <code>"\"quoted\""</code>) but the resulting CBOR string itself contains the literal characters without CDDL escapes.</li>
<li><strong>Byte Strings</strong>: <code>h'010203'</code>, <code>h''</code>. Byte strings are represented using hexadecimal notation prefixed with <code>h</code> and enclosed in single quotes.</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">; Examples using literal values
message-type = 1                 ; The value must be the integer 1
protocol-version = "1.0"         ; The value must be the text string "1.0"
fixed-header = h'cafef00d'       ; The value must be these specific four bytes
status-code = 200 / 404 / 500    ; The value must be one of these integers
</code></pre>
<p>Literal values are often used as discriminators in choices or as fixed keys in maps.</p>
<h2 id="defining-collections-arrays-maps-and-groups"><a class="header" href="#defining-collections-arrays-maps-and-groups">Defining Collections: Arrays, Maps, and Groups</a></h2>
<p>Beyond simple scalar types, CDDL provides syntax for defining the structure of CBOR arrays (Major Type 4) and maps (Major Type 5). Crucially, it also introduces the concept of <em>groups</em> delimited by parentheses (<code>()</code>) to define sequences of items that are <em>not</em> enclosed within a CBOR array or map structure. Understanding the distinction between these is vital for correctly modeling CBOR data.</p>
<h3 id="arrays-"><a class="header" href="#arrays-">Arrays (<code>[]</code>)</a></h3>
<p>CDDL uses square brackets <code>[]</code> to define CBOR arrays. Inside the brackets, you specify the type(s) of the elements that the array should contain.</p>
<p>CDDL:</p>
<pre><code class="language-cddl">; An array containing exactly three unsigned integers
triplet = [uint, uint, uint]

; An array containing a text string followed by any CBOR item
labelled-item = [tstr, any]

; An empty array
empty-array = []

; An array where the first element is a boolean, and the second is either an int or null
mixed-array = [bool, int / null]
</code></pre>
<p>Occurrence indicators (covered later) can be used to specify variable numbers of elements. The definition within the brackets describes the sequence of CBOR items expected <em>within</em> the CBOR array structure itself.</p>
<h3 id="maps-"><a class="header" href="#maps-">Maps (<code>{}</code>)</a></h3>
<p>CDDL uses curly braces <code>{}</code> to define CBOR maps. Inside the braces, you define the expected key-value pairs. A key difference from JSON is that CBOR map keys can be <em>any</em> CBOR data type, not just strings. CDDL reflects this flexibility.  </p>
<p>There are two primary ways to specify map members:</p>
<ol>
<li><strong><code>key: type</code></strong>: This form requires the key to be a literal <code>tstr</code> or <code>int</code>, or a <code>tstr</code> or <code>int</code> type that has a single literal value constraint. It's a shorthand commonly used when keys are simple strings or integers.</li>
<li><strong><code>keytype =&gt; valuetype</code></strong>: This is the more general form. <code>keytype</code> can be any CDDL type definition (e.g., <code>tstr</code>, <code>uint</code>, <code>my-custom-rule</code>, a literal value), and <code>valuetype</code> defines the type of the corresponding value.</li>
</ol>
<p>CDDL:</p>
<pre><code class="language-cddl">; A map with specific string keys
simple-object = {
  "name": tstr,
  "age": uint,
  is-verified: bool  ; Bare words are shorthand for "is-verified": bool
}

; A map using integer keys and the =&gt; syntax
indexed-data = {
  1 =&gt; tstr,         ; Key is integer 1, value is text string
  2 =&gt; bstr,         ; Key is integer 2, value is byte string
 ? 3 =&gt; float       ; Key 3 is optional (using '?')
}

; A map where keys must be unsigned integers and values are text strings
; The '*' indicates zero or more occurrences of this key/value pattern
lookup-table = {
  * uint =&gt; tstr
}

; An empty map
empty-map = {}
</code></pre>
<p><strong>Important Considerations for Maps:</strong></p>
<ul>
<li>
<p><strong>Key Types</strong>: Remember that CBOR allows non-string keys. CDDL fully supports defining maps with integer, byte string, or even complex keys.</p>
</li>
<li>
<p><strong>Order</strong>: Although key-value pairs must be serialized in <em>some</em> order in the CBOR encoding, CDDL map definitions, like CBOR maps themselves, are generally considered <em>orderless</em>. Validation typically checks for the presence of required keys and type correctness, not the specific order in the encoded bytes. Deterministic encoding profiles, discussed later in this book, impose strict ordering rules.  </p>
</li>
<li>
<p><strong>Uniqueness</strong>: The core CBOR specification doesn't strictly require map keys to be unique. However, most applications assume unique keys, and CDDL validation tools often enforce uniqueness by default or provide options to control this behavior. Relying on duplicate keys is generally discouraged.</p>
</li>
</ul>
<h3 id="groups----defining-sequences"><a class="header" href="#groups----defining-sequences">Groups (<code>()</code>) - Defining Sequences</a></h3>
<p>Perhaps the most distinctive structural element in CDDL compared to JSON-centric schema languages is the <em>group</em>, denoted by parentheses <code>()</code>. A group defines an ordered sequence of one or more CBOR data items <em>without</em> implying an enclosing CBOR array or map structure.</p>
<p>This concept directly mirrors how CBOR works: data items are encoded sequentially one after another. A group in CDDL allows you to name and constrain such a sequence.</p>
<p>CDDL:</p>
<pre><code class="language-cddl">; A group containing an unsigned integer followed by a text string
record-header = (uint, tstr)

; A group containing two floats
point-2d = (float, float)
</code></pre>
<p>At first glance, <code>point-2d = (float, float)</code> might look similar to <code>point-array = [float, float]</code>. However, they define fundamentally different structures:</p>
<ul>
<li><code>point-array</code> defines a CBOR <strong>array</strong> (e.g., <code>[1.0, 2.5]</code>, encoded starting with <code>0x82</code>) containing two floats.</li>
<li><code>point-2d</code> defines a <strong>sequence</strong> of two CBOR floats (e.g., <code>1.0</code> followed by <code>2.5</code>, encoded as <code>0xf93c00</code> followed by <code>0xfa40200000</code>, assuming preferred serialization).</li>
</ul>
<p><strong>Why are groups useful?</strong></p>
<ol>
<li><strong>Partial Arrays</strong>: Groups can be used to define partial arrays or sequences of items without needing to wrap them in a sub-array structure. For example, a <code>key</code> type that is an array of three items, where the first is a text string and the second and third are byte strings, could be defined as:</li>
</ol>
<p>CDDL:</p>
<pre><code class="language-cddl">key = [key-info, bstr, bstr]
key-info = tstr
</code></pre>
<p>But if the two byte strings are the key's conceptual "body", how would we use CDDL to make that clear? Using groups! The following definition is equivalent to the above, but it makes the relationship between the key and its body clear:</p>
<p>CDDL:</p>
<pre><code class="language-cddl">key = [key-info, key-body]
key-info = tstr
key-body = (bstr, bstr)
</code></pre>
<ol start="2">
<li><strong>Structuring Map Members</strong>: Groups can structure related members within a map without requiring a nested map.</li>
</ol>
<p>CDDL:</p>
<pre><code class="language-cddl">person = {
    name: tstr,
    address
}

; Group defines the address structure
address = (
    street: tstr,
    city: tstr,
    zip: uint
)
</code></pre>
<p>This defines that the <code>street</code>, <code>city</code>, and <code>zip</code> keys are logically related and should appear (conceptually) together, but they remain direct members of the <code>person</code> map, the above definition being equivalent to:</p>
<p>CDDL:</p>
<pre><code class="language-cddl">person = {
    name: tstr,
    street: tstr,
    city: tstr,
    zip: uint
}
</code></pre>
<p>This makes <code>address</code> a reusable group that can be referenced in multiple places, enhancing modularity and readability.</p>
<ol start="3">
<li><strong>Defining Choices Between Sequences (Group Choice <code>//</code>)</strong>: Allows choosing between different sequences of items.</li>
</ol>
<p>CDDL:</p>
<pre><code class="language-cddl">message = {
    header,
    payload // error-report
}
header = (version: uint, msg_id: uint)
payload = (data: bstr)
error-report = (code: int, reason: tstr)
</code></pre>
<p>Groups are powerful because they leverage the fundamental sequential nature of CBOR encoding. While JSON schema languages might struggle to represent bare sequences outside of arrays, CDDL embraces them, providing a precise way to model structures common in binary protocols where items follow each other without explicit delimiters.</p>
<h3 id="defining-cardinality"><a class="header" href="#defining-cardinality">Defining Cardinality</a></h3>
<p>CDDL provides several operators to control the cardinality of elements within arrays, maps, and groups. These operators specify how many times a given type or group can occur in a sequence.</p>
<ul>
<li><code>?</code>: <strong>Optional</strong> (zero or one time).</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">optional-id = [ ?uint ]      ; Array with 0 or 1 uint
config = ( tstr, ?bool )     ; Group: tstr, optionally followed by bool
</code></pre>
<ul>
<li><code>*</code>: <strong>Zero or more</strong> times.</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">int-list = [ *int ]          ; Array with any number of ints (including zero)
byte-chunks = ( *bstr )      ; Group: sequence of zero or more byte strings
</code></pre>
<ul>
<li><code>+</code>: <strong>One or more</strong> times.</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">non-empty-list = [ +tstr ]   ; Array with at least one text string
data-record = ( uint, +float ) ; Group: uint followed by one or more floats
</code></pre>
<ul>
<li><code>n*m</code>: <strong>Specific range</strong> (<code>n</code> to <code>m</code> times, inclusive). If <code>n</code> is omitted, it defaults to 0. If <code>m</code> is omitted, it defaults to infinity.</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">rgb-color = [ 3*3 uint ]      ; Array with exactly 3 uints
short-ids = [ 1*5 int ]       ; Array with 1 to 5 ints
max-10-items = [ *10 any ]    ; Array with 0 to 10 items of any type
at-least-2 = [ 2* bstr ]      ; Array with 2 or more byte strings
</code></pre>
<p>These indicators provide fine-grained control over the cardinality of elements within sequences and arrays.</p>
<h3 id="choices"><a class="header" href="#choices">Choices</a></h3>
<p>CDDL offers two ways to define alternatives:</p>
<ol>
<li><strong>Type Choice (<code>/</code>)</strong>: Allows choosing between different <em>types</em> for a single data item slot.</li>
</ol>
<p>CDDL:</p>
<pre><code class="language-cddl">identifier = tstr / uint       ; An identifier is either a text string or a uint
config-value = bool / int / tstr / null
measurement = [ tstr, int / float ] ; Array: string followed by an int OR a float
</code></pre>
<ol start="2">
<li><strong>Group Choice (<code>//</code>)</strong>: Allows choosing between different <em>groups</em> (sequences) of items. This is used when the choice affects multiple items or map members.</li>
</ol>
<p>CDDL:</p>
<pre><code class="language-cddl">contact-method = {
    (email: tstr) //
    (phone: tstr) //
    postal-address
}
postal-address = (street: tstr, city: tstr)

response = {
    (status: 200, body: bstr) // (status: 500, error: tstr)
}
</code></pre>
<p>In the <code>response</code> example, the choice affects both the <code>status</code> value and the subsequent item (<code>body</code> or <code>error</code>).</p>
<h3 id="value-constraints-and-control-operators"><a class="header" href="#value-constraints-and-control-operators">Value Constraints and Control Operators</a></h3>
<p>Beyond type and occurrence, CDDL allows constraints on the actual values or properties of data items using literal value ranges and <em>control operators</em> (often called "dot operators"). Control operators act as extensions to the core grammar, providing hooks for more sophisticated validation. The prelude defines several useful ones, and others can be defined by specific CDDL profiles or applications.  </p>
<ul>
<li><strong>Ranges (<code>..</code>)</strong>: Defines an inclusive range for numerical types or literal values.</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">age = uint .le 120             ; Using prelude.le (less than or equal)
percentage = 0..100            ; Value must be int between 0 and 100 inclusive
temperature = -40..50          ; Value must be int between -40 and 50
http-status-ok = 200..299      ; Integer range for successful HTTP status
first-byte = 0x00..0xFF        ; Integer range using hex literals
</code></pre>
<p>Range checks can also be combined with prelude operators like <code>.lt</code> (less than), <code>.le</code> (less than or equal), <code>.gt</code> (greater than), <code>.ge</code> (greater than or equal), <code>.eq</code> (equal), <code>.ne</code> (not equal).</p>
<ul>
<li>
<p><strong>Common Control Operators</strong>:</p>
</li>
<li>
<p><code>.size uint</code> / <code>.size (min..max)</code>: Constrains the size (length). For <code>bstr</code> and <code>tstr</code>, it's the number of bytes. For arrays, it's the number of elements. For maps, it's the number of key-value pairs.</p>
</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">short-string = tstr .size (1..64)
sha256-hash = bstr .size 32
coordinate = [ float ] .size 2  ; Array must have exactly 2 floats
simple-map = { * tstr =&gt; any } .size (1..5) ; Map with 1 to 5 pairs
</code></pre>
<blockquote>
<p><strong>⚠️ NOTE</strong>: The whitespace before "dot operator" is significant. If you get errors, check for missing whitespace.</p>
</blockquote>
<ul>
<li><code>.regexp tstr</code>: Validates that a <code>tstr</code> matches a given regular expression pattern (syntax follows XML Schema Definition Language (XSD) style regular expressions, as per <a href="https://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#regexs">XSD Appendix F</a>).</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">email = tstr .regexp "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
iso-date = tstr .regexp "\d{4}-\d{2}-\d{2}"
</code></pre>
<ul>
<li><code>.cbor type</code> / <code>.cborseq type</code>: Validates that a <code>bstr</code> contains bytes that are a valid CBOR encoding of the specified <code>type</code> or a sequence (<code>.cborseq</code>) of items matching <code>type</code>. This is useful for embedding CBOR within CBOR.</li>
</ul>
<p>CDDL:</p>
<pre><code class="language-cddl">signed-data = {
    payload: bstr .cbor any, ; Payload is bytes that decode to some CBOR item
    signature: bstr
}
message-stream = bstr .cborseq log-entry ; Bytes contain a sequence of log entries
log-entry = [timestamp, tstr] ; Assuming log-entry is defined elsewhere
timestamp = uint
</code></pre>
<p>These operators allow schema authors to declaratively state constraints without needing to specify the validation logic itself. CDDL tools interpret these declarations to perform the checks.  </p>
<blockquote>
<p><strong>✅ TIP:</strong> dCBOR, which we will discuss later in this book, also defines two additional operators, <code>.dcbor</code> and <code>.dcborseq</code>, which are exactly like <code>.cbor</code> and <code>.cborseq</code> except that they also require the encoded data item(s) be valid dCBOR.</p>
</blockquote>
<p>The following table summarizes the most frequently used operators for controlling structure and content:</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Name</th><th>Meaning</th><th>Example Usage</th></tr></thead><tbody>
<tr><td><code>?</code></td><td>Optional</td><td>Zero or one occurrence</td><td><code>? int</code></td></tr>
<tr><td><code>*</code></td><td>Zero or More</td><td>Zero or more occurrences</td><td><code>* tstr</code></td></tr>
<tr><td><code>+</code></td><td>One or More</td><td>One or more occurrences</td><td><code>+ bool</code></td></tr>
<tr><td><code>n*m</code></td><td>Range Occurrence</td><td>n to m occurrences</td><td><code>2*4 float</code></td></tr>
<tr><td><code>/</code></td><td>Type Choice</td><td>Choose between listed types</td><td><code>int / tstr</code></td></tr>
<tr><td><code>//</code></td><td>Group Choice</td><td>Choose between listed groups</td><td><code>(int) // (tstr, bool)</code></td></tr>
<tr><td><code>..</code></td><td>Value Range</td><td>Value within numerical range</td><td><code>0..100</code></td></tr>
<tr><td><code>.size</code></td><td>Size Control</td><td>Constrain byte/element/pair count</td><td><code>tstr.size (1..10)</code></td></tr>
<tr><td><code>.regexp</code></td><td>Regex Control</td><td>Match text string pattern</td><td><code>tstr.regexp "..."</code></td></tr>
<tr><td><code>.cbor</code></td><td>Embedded CBOR</td><td>Byte string is valid CBOR of type</td><td><code>bstr.cbor my_type</code></td></tr>
<tr><td><code>.cborseq</code></td><td>Embedded CBOR Sequence</td><td>Byte string is valid CBOR sequence</td><td><code>bstr.cborseq my_type</code></td></tr>
</tbody></table>
</div>
<h2 id="building-and-reusing-definitions"><a class="header" href="#building-and-reusing-definitions">Building and Reusing Definitions</a></h2>
<p>While the basic types and operators are powerful, the real strength of CDDL for defining complex data structures lies in its ability to build definitions compositionally by referencing other rules.</p>
<h3 id="rule-referencing"><a class="header" href="#rule-referencing">Rule Referencing</a></h3>
<p>Once a rule is defined with a name, that name can be used anywhere a type definition is expected in another rule. This allows breaking down complex structures into smaller, manageable, named components.</p>
<p>CDDL:</p>
<pre><code class="language-cddl">; Define a structure for a person's name
name-structure = {
  first: tstr .size (1..50),
  last: tstr .size (1..50),
  ? middle: tstr .size (1..50) ; Optional middle name
}

; Define contact information choices
contact-info = email-address / phone-number

email-address = tstr .regexp "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
phone-number = tstr .regexp "\+?[1-9]\d{1,14}" ; Simple E.164 regex example

; Define the main person structure, referencing other rules
person = {
  name: name-structure,       ; Use the name-structure rule here
  age: uint .le 120,          ; Updated to include whitespace before .le
  ? contact: contact-info     ; Optional contact info, using the choice rule
}
</code></pre>
<p>In this example, the <code>person</code> rule is defined using references to <code>name-structure</code> and <code>contact-info</code>. This makes the <code>person</code> definition concise and readable. If the structure of a name or contact information needs to change, the modification only needs to happen in one place (the <code>name-structure</code> or <code>contact-info</code> rules), improving maintainability.</p>
<h3 id="modularity-and-readability"><a class="header" href="#modularity-and-readability">Modularity and Readability</a></h3>
<p>This compositional approach is key to managing complexity in large data format specifications. By breaking down the overall structure into logical, named sub-components (rules and groups), CDDL schemas become:</p>
<ul>
<li><strong>More Readable</strong>: Each rule focuses on a specific part of the data structure.</li>
<li><strong>More Maintainable</strong>: Changes to a shared structure are localized.</li>
<li><strong>More Reusable</strong>: Common structures (like timestamps, identifiers, addresses) can be defined once and referenced wherever needed.</li>
</ul>
<p>This mirrors good software engineering practices, applying principles of modularity and abstraction to data definition. This compositional design aids in creating the unambiguous descriptions that are a primary goal of CDDL.  </p>
<h3 id="practical-example-the-gadget-revisited"><a class="header" href="#practical-example-the-gadget-revisited">Practical Example: The "Gadget" Revisited</a></h3>
<p>Let's revisit the nested JSON/CBOR example from a previous chapter and define its structure using CDDL:</p>
<p><strong>JSON/CBOR Diagnostic:</strong></p>
<pre><code>{
  "name": "Gadget",
  "id": 12345,
  "enabled": true,
  "parts": [ "bolt", "nut" ],
  "spec": { "size": 10.5, "data": h'010000ff' }
}
</code></pre>
<p><strong>CDDL Definition:</strong></p>
<p>CDDL:</p>
<pre><code class="language-cddl">; Define the top-level type for validation (often the first rule)
top-level = gadget

; Define the main gadget structure
gadget = {
  "name": tstr .size 1.., ; Name must be at least 1 byte
  "id": uint,
  "enabled": bool,
  "parts": [ + tstr ],      ; Array of one or more text strings
  "spec": gadget-spec       ; Reference the gadget-spec rule
}

; Define the structure for the specification sub-object
gadget-spec = {
  "size": float,       ; Allows float16, float32, or float64
  "data": bstr         ; The raw binary data
}
</code></pre>
<p>This CDDL schema precisely defines the expected structure:</p>
<ul>
<li>A map (<code>gadget</code>) with five required keys: <code>"name"</code>, <code>"id"</code>, <code>"enabled"</code>, <code>"parts"</code>, and <code>"spec"</code>.</li>
<li><code>"name"</code> must be a non-empty text string.</li>
<li><code>"id"</code> must be an unsigned integer.</li>
<li><code>"enabled"</code> must be a boolean.</li>
<li><code>"parts"</code> must be an array containing one or more text strings.</li>
<li><code>"spec"</code> must be a map conforming to the <code>gadget-spec</code> rule.</li>
<li>The <code>gadget-spec</code> map requires keys <code>"size"</code> (a float) and <code>"data"</code> (a byte string).</li>
</ul>
<p>Notice how the CDDL directly defines the <code>data</code> field as <code>bstr</code>, reflecting CBOR's native handling of binary data, unlike the base64 encoding necessary in the JSON representation. This schema clearly communicates the expected format for any system processing "gadget" data.</p>
<h2 id="validation-and-the-tooling-ecosystem"><a class="header" href="#validation-and-the-tooling-ecosystem">Validation and the Tooling Ecosystem</a></h2>
<p>Defining a schema is only part of the story. A major practical benefit of using CDDL is the ability to automatically validate CBOR data against a schema.  </p>
<h3 id="the-concept-of-validation"><a class="header" href="#the-concept-of-validation">The Concept of Validation</a></h3>
<p>Validation is the process of checking whether a given CBOR data instance conforms to the rules specified in a CDDL schema. Conceptually, a CDDL validator tool takes two inputs:</p>
<ol>
<li>The CDDL schema definition (e.g., a <code>.cddl</code> file).</li>
<li>The CBOR data instance (usually as raw bytes).</li>
</ol>
<p>The validator then processes the CBOR data according to the rules defined in the schema, starting from a designated root rule (often the first rule in the file, or explicitly specified). It outputs whether the data is valid according to the schema, often providing details about any discrepancies if validation fails.  </p>
<h3 id="benefits-of-validation"><a class="header" href="#benefits-of-validation">Benefits of Validation</a></h3>
<p>Automated validation provides significant benefits:</p>
<ul>
<li><strong>Error Detection</strong>: Catch malformed data early, whether from external sources or internal bugs.</li>
<li><strong>Interoperability</strong>: Ensure that systems exchanging CBOR data adhere to the agreed-upon structure.</li>
<li><strong>API Contract Enforcement</strong>: Use CDDL schemas as machine-readable contracts for APIs that consume or produce CBOR.</li>
<li><strong>Security</strong>: Validate that incoming data conforms to expected structural constraints, preventing certain classes of injection or processing errors. While not a substitute for comprehensive security analysis, structural validation is a valuable defense layer.  </li>
</ul>
<h3 id="tooling-ecosystem"><a class="header" href="#tooling-ecosystem">Tooling Ecosystem</a></h3>
<p>A growing ecosystem of tools and libraries supports working with CDDL. While this book won't provide tutorials for specific tools, it's important to be aware of their existence:  </p>
<ul>
<li>
<p><strong>Implementations</strong>: Libraries for parsing CDDL and validating CBOR/JSON data are available in various languages, including Rust (<code>cddl-rs</code> ), Node.js (<code>cddl</code>), and potentially others like Python, Go, or Java (e.g., via wrappers like <code>cddl2java</code> mentioned in ).  </p>
</li>
<li>
<p><strong>Functionality</strong>: Common features include:</p>
<ul>
<li>Parsing CDDL schemas into an Abstract Syntax Tree (AST).  </li>
<li>Validating CBOR data against a CDDL schema.  </li>
<li>Validating JSON data against a CDDL schema.  </li>
<li>Checking CDDL syntax conformance.  </li>
<li>Some tools might offer experimental features like generating documentation or code stubs, though code generation is not a primary design goal of CDDL itself.  </li>
</ul>
</li>
<li>
<p><strong>Online Tools</strong>: Resources like <a href="https://cddl.anweiss.tech/">cddl.anweiss.tech</a> offer CDDL validation, allowing interactive experimentation.</p>
</li>
</ul>
<p>The availability of these tools enables a <em>schema-driven development</em> workflow. The CDDL schema can serve as a central artifact for documentation, automated testing (validation), runtime checks, and ensuring consistency across different parts of a system or between collaborating teams. This elevates CDDL from merely a descriptive language to an active component in building robust CBOR-based applications.  </p>
<h2 id="conclusion-laying-the-schema-foundation"><a class="header" href="#conclusion-laying-the-schema-foundation">Conclusion: Laying the Schema Foundation</a></h2>
<p>This chapter has introduced the Concise Data Definition Language (CDDL) as the standard way to define the structure of CBOR data. We've moved from understanding <em>how</em> individual CBOR items are encoded to specifying <em>what</em> overall structure those items should form in a given application or protocol.</p>
<p>We covered the core concepts: rules defined using assignments (<code>=</code>, <code>/=</code>, <code>//=</code>), the use of standard types from the prelude (<code>uint</code>, <code>tstr</code>, <code>bool</code>, etc.), and the specification of literal values. We explored how CDDL defines CBOR arrays (<code>[]</code>) and maps (<code>{}</code>), noting the flexibility of map keys in CBOR. Crucially, we delved into CDDL groups (<code>()</code>) and their role in defining sequences of items without explicit CBOR delimiters, highlighting how this feature directly maps to CBOR's sequential encoding and distinguishes CDDL from JSON-centric schema languages. We also learned how to control structure using occurrence indicators (<code>?</code>, <code>*</code>, <code>+</code>, <code>n*m</code>), define choices (<code>/</code>, <code>//</code>), and apply constraints using value ranges (<code>..</code>) and practical control operators like <code>.size</code>, <code>.regexp</code>, and <code>.cbor</code>. Finally, we saw how rule referencing enables modular, readable, and reusable schema design, and how the existence of validation tools makes CDDL a practical asset for development.</p>
<p><strong>Best Practices for Writing CDDL:</strong></p>
<p>As you start defining your own CBOR structures with CDDL, keep these practices in mind:</p>
<ul>
<li><strong>Clarity over Brevity</strong>: Prioritize making the schema easy to understand. Use comments (<code>;</code>) liberally to explain intent and choices.</li>
<li><strong>Meaningful Names</strong>: Choose descriptive names for rules that reflect their purpose.</li>
<li><strong>Modularity</strong>: Break down complex structures into smaller, well-named rules. This improves readability, maintainability, and reuse.</li>
<li><strong>Start Specific, Generalize Carefully</strong>: Define the expected structure as precisely as possible initially. Use broad types like <code>any</code> or wide occurrence ranges (<code>*</code>) only when truly necessary, as overly permissive schemas offer less validation value.</li>
<li><strong>Consider the CBOR Data Model</strong>: Think about how your CDDL definition maps to the underlying CBOR types and encoding, especially regarding the distinction between groups (<code>()</code>) and container types like arrays (<code>[]</code>) and maps (<code>{}</code>).</li>
</ul>
<p>With the fundamentals covered here, you are equipped to use CDDL to bring clarity and rigor to your CBOR-based data formats. This foundation is essential as we move forward to explore more advanced CBOR topics. CDDL schemas are instrumental in understanding and validating the structures used within CBOR Tags, ensuring the correctness of data before applying deterministic encoding rules (dCBOR), and understanding the precise layout of nested structures like Gordian Envelope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="determinism-why-consistent-encodings-matter"><a class="header" href="#determinism-why-consistent-encodings-matter">Determinism: Why Consistent Encodings Matter</a></h1>
<h2 id="11-introduction-the-illusion-of-sameness"><a class="header" href="#11-introduction-the-illusion-of-sameness">1.1 Introduction: The Illusion of Sameness</a></h2>
<p>Consider a common scenario in software engineering: comparing two data structures that represent the same logical information. Perhaps they are configuration objects loaded from different sources, snapshots of system state taken at different times but believed to be identical, or messages exchanged between distributed components. A developer might reasonably expect that if these structures hold the same values—field for field, element for element—a simple byte-wise comparison of their serialized forms would confirm their equality. Yet, surprisingly often, this comparison fails. Two objects, logically identical, produce different sequences of bytes when serialized.</p>
<p>This discrepancy arises because many common data serialization formats, including text-based ones like JSON and even efficient binary formats like Protocol Buffers or CBOR itself, allow flexibility in how data is represented. The same logical map might have its keys ordered differently; the same number might be encoded with varying precision or length; the same string might have subtle variations in character encoding or normalization. While these variations are often <em>semantically irrelevant</em> at the data model level, they result in distinct byte sequences.</p>
<p>This phenomenon, where serialization yields inconsistent byte outputs for logically equivalent inputs, can be deeply problematic. Processes downstream that rely on these byte representations—such as cryptographic hashing, digital signature verification, distributed consensus mechanisms, or simple data comparison—may behave unpredictably or fail entirely. This variability acts much like a hidden, uncontrolled input, introducing non-determinism into systems that are otherwise expected to be predictable, leading to bugs that are notoriously difficult to diagnose and fix, akin to issues stemming from uninitialized memory or thread race conditions. Understanding and controlling this variability through deterministic encoding is therefore not merely an academic exercise but a practical necessity for building robust, secure, and interoperable systems. This chapter explores the fundamental need for deterministic encoding, the challenges involved, and the landscape of previous efforts to achieve it.</p>
<h2 id="12-defining-deterministic-encoding"><a class="header" href="#12-defining-deterministic-encoding">1.2 Defining Deterministic Encoding</a></h2>
<p>At its core, <strong>Deterministic Encoding</strong> is an encoding process designed to eliminate ambiguity. It employs specific rules and makes deliberate choices during serialization to ensure that logically equivalent inputs at the data model level <em>always</em> produce the exact same sequence of encoded bytes. This is distinct from the general term <strong>Serialization</strong>, which simply refers to the process of representing data model items (like numbers, strings, arrays, maps) as encoded data items, potentially allowing for multiple valid representations.</p>
<p>The term <strong>Canonicalization</strong> is often used synonymously with deterministic encoding, emphasizing the goal of producing a single, standard, or "canonical" form for any given piece of data. Several systems aim for this canonical property, where the serialization guarantees byte consistency for the same in-memory data structure, regardless of the implementation or environment.</p>
<p>Within the CBOR ecosystem (RFC 8949), related concepts exist that represent steps towards reducing variability, though they don't necessarily guarantee full cross-implementation determinism on their own:</p>
<ul>
<li><strong>Preferred Serialization:</strong> A recommendation aiming for the shortest possible encoding for a data item's head (the initial bytes indicating type and length/value), without expending extra effort like sorting map keys.</li>
<li><strong>Basic Serialization:</strong> Builds on Preferred Serialization by adding the constraint that indefinite-length encoding (where the total length isn't known upfront) must not be used for strings, arrays, or maps.</li>
</ul>
<p>While Preferred and Basic Serialization reduce encoding variability, true Deterministic Encoding, such as <a href="https://datatracker.ietf.org/doc/draft-ietf-cbor-cde/">CBOR Common Deterministic Encoding (CDE)</a>, imposes stricter rules, like mandatory map key sorting, to achieve the goal of a unique byte sequence for equivalent data.</p>
<p>Understanding why these stricter rules are necessary requires examining the common sources of non-determinism in data serialization:</p>
<ul>
<li>
<p><strong>Map/Object Key Order:</strong> In data models like JSON objects or CBOR maps, the order of key-value pairs is generally considered semantically insignificant. <code>{"name": "Alice", "id": 123}</code> is logically the same as <code>{"id": 123, "name": "Alice"}</code>. However, without a rule mandating a specific order (e.g., sorting keys alphabetically), serializers might output these pairs in different orders, leading to different byte sequences. This is a major source of non-determinism in formats like JSON, Protobuf, and basic CBOR. Deterministic schemes typically mandate sorting keys based on a well-defined comparison, such as lexicographical sorting of the UTF-16 key strings (as in <a href="https://www.rfc-editor.org/rfc/rfc8785">JCS</a>) or byte-wise lexicographical sorting of the <em>encoded</em> keys (as in CBOR CDE).</p>
</li>
<li>
<p><strong>Number Representation:</strong> Numbers can often be encoded in multiple ways:</p>
<ul>
<li><em>Integers:</em> Small integers might fit into short forms, but longer encodings could technically be valid in some formats. Varint encodings (used in Protobuf) can sometimes represent the same number using different byte lengths, especially if leading zeros aren't strictly prohibited. CBOR's Preferred Serialization aims for the shortest form, but deterministic rules make this mandatory. Arbitrary-precision integers (bignums) also need clear rules to avoid ambiguity with standard integer types.</li>
<li><em>Floating-Point Numbers:</em> These present significant challenges. <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> allows multiple binary representations (e.g., half, single, double precision), and the same value might be representable in several. Special values like NaN (Not a Number) can have different binary payloads, and positive zero (+0) and negative zero (−0) have distinct representations. Deterministic schemes must specify canonical forms, such as always using the shortest valid representation and defining a single canonical NaN.</li>
</ul>
</li>
<li>
<p><strong>String Encoding &amp; Unicode:</strong> While UTF-8 is the dominant encoding today, subtleties remain. The most significant is Unicode normalization. A single character with an accent (like 'é') can often be represented either as a single precomposed character (U+00E9) or as a base character ('e', U+0065) followed by a combining accent mark (U+0301). These result in different byte sequences but represent the same visual character. Some canonicalization schemes require normalizing strings to a specific form (like NFC or NFD) before encoding, while others, like JCS and CBOR CDE, explicitly <em>avoid</em> this step, considering it an application-level concern due to complexity and potential information loss.</p>
</li>
<li>
<p><strong>Indefinite Lengths:</strong> Formats like CBOR allow encoding arrays, maps, and strings without specifying their length upfront, using a special "break" marker to signal the end. This "indefinite-length" encoding is useful for streaming but introduces non-determinism, as the same data could be encoded with either a definite or indefinite length. Deterministic schemes like CBOR CDE typically disallow indefinite-length items.</p>
</li>
<li>
<p><strong>Default Values / Optional Fields:</strong> In formats like Protobuf, if a field is set to its default value (e.g., an integer field to 0), it might be omitted entirely during serialization, or it might be explicitly included. Since the deserialized result is the same in either case (the field has the default value), this creates representational ambiguity. Deterministic schemes often require omitting default values, similar to how <a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">ASN. DER</a> forbids encoding default values.</p>
</li>
<li>
<p><strong>Extensibility Issues (Tags/Unknown Fields):</strong> How a format handles data not explicitly defined in its schema can impact determinism. Protobuf preserves "unknown fields" encountered during parsing, which aids forward/backward compatibility but significantly hinders canonicalization because the type (and thus canonical representation) of these fields isn't known. CBOR uses tags for extensibility; while the content <em>within</em> a tag might be canonicalized according to standard rules, ensuring that application-level data is consistently mapped <em>to</em> specific tags and representations might require additional application-specific rules (sometimes called Application-Level Deterministic Representation or ALDR).</p>
</li>
</ul>
<p>It becomes clear that achieving deterministic encoding involves navigating a spectrum of choices. At one end lies basic, potentially non-deterministic serialization. Moving along the spectrum, we encounter implementation-specific determinism (where a single library might be deterministic but not interoperable), recommended practices like CBOR's Preferred or Basic Serialization, and finally, fully specified canonical forms like ASN.1 DER, JCS, BCS, or CBOR CDE, which aim for a single, universally verifiable representation. The choice of where to be on this spectrum depends heavily on the application's requirements for consistency, interoperability, and security.</p>
<h2 id="13-the-motivation-why-determinism-is-crucial"><a class="header" href="#13-the-motivation-why-determinism-is-crucial">1.3 The Motivation: Why Determinism is Crucial</a></h2>
<p>The quest for deterministic encoding is driven by the significant problems that arise from its absence. When the same logical data can manifest as different byte sequences unpredictably, it introduces a subtle but pervasive form of non-determinism into computing systems, leading to a range of issues that can be difficult for engineers to anticipate and resolve.</p>
<p>One major consequence is the emergence of <strong>hard-to-diagnose bugs</strong>. Systems relying on byte-wise comparisons or hashing of serialized data may fail intermittently or produce inconsistent results depending on factors like which library version is used, the internal state of the serializer (e.g., hash table iteration order affecting map key output), or even timing variations. Debugging such issues is challenging because the root cause lies not in the application logic itself, but in the seemingly innocuous step of data serialization. Failures might appear non-reproducible until the underlying serialization variability is understood and controlled.</p>
<p>Furthermore, non-deterministic serialization can <strong>undermine security guarantees</strong>. Digital signatures, for instance, rely on the verifier being able to compute the exact same hash of the message data as the signer. If the data is re-serialized between signing and verification, and the serialization is non-deterministic, the hashes will mismatch, causing valid signatures to fail verification. This not only breaks functionality but could potentially be exploited in certain scenarios. Similarly, consensus protocols in distributed systems depend on nodes agreeing on the state based on identical data representations; non-determinism breaks this agreement.</p>
<p><strong>Inefficiency</strong> is another consequence. Caching mechanisms often use hashes of data as keys. If logically identical data produces different serialized forms (and thus different hashes), caches will suffer unnecessary misses, leading to redundant computation or data transfer. Content-addressable storage systems lose their deduplication benefits if identical content doesn't serialize identically.</p>
<p>Finally, non-determinism severely <strong>hinders interoperability</strong>. If different systems, or even different versions of the same software, serialize the same data differently, they may be unable to reliably communicate or agree on shared state. This is particularly problematic in heterogeneous environments or long-lived systems where components evolve independently. Protocol Buffers' documentation explicitly warns that its default "deterministic" mode is not canonical across languages or versions precisely for these reasons.</p>
<p>These diverse problems highlight a fundamental point: non-determinism in serialization erodes the foundation of trust in computational processes. Digital systems rely on predictable, repeatable behavior to function correctly and securely. When the basic representation of data—its byte sequence—becomes unpredictable for the same logical content, the operations built upon that representation (comparison, hashing, verification, agreement) become inherently unreliable. This variability undermines the integrity and dependability required for critical applications, from secure communication and financial transactions to distributed databases and verifiable records. Achieving deterministic, canonical encoding is therefore essential for building systems where computational results can be consistently verified and trusted. The need for deterministic processes is not unique to serialization; it's a recurring theme in diverse fields like coding theory, machine learning, and state machine design, reflecting a general need for predictable and reliable computation.</p>
<h2 id="14-key-use-cases-demanding-determinism"><a class="header" href="#14-key-use-cases-demanding-determinism">1.4 Key Use Cases Demanding Determinism</a></h2>
<p>The need for deterministic encoding is not theoretical; it is driven by the practical requirements of numerous critical computing applications. Several key use cases fundamentally depend on the ability to produce a consistent, predictable byte representation for data.</p>
<h3 id="141-distributed-consensus"><a class="header" href="#141-distributed-consensus">1.4.1 Distributed Consensus</a></h3>
<p>Distributed systems, ranging from replicated databases to modern blockchain networks, rely on consensus algorithms (such as Paxos, Raft, or variants of Byzantine Fault Tolerance (BFT)) to ensure that multiple independent nodes agree on a single, consistent state or order of operations. This agreement process frequently involves nodes proposing, validating, and replicating data structures like transaction logs, state updates, or proposed blocks.</p>
<p>A core requirement for these algorithms is that all non-faulty nodes must reach the same decision based on the same information. Often, this involves nodes independently processing received data, serializing it (or parts of it), and then hashing the result to compare with hashes received from other nodes or to include in subsequent proposals. If the serialization process is non-deterministic, two nodes processing the <em>exact same logical transaction or block data</em> could generate different byte sequences. These different sequences would produce different cryptographic hashes, leading the nodes to disagree, even though they started with identical information. This disagreement prevents the system from reaching consensus, potentially halting progress or leading to inconsistent states across nodes.</p>
<p>Blockchains are a prominent example where this is critical. In a decentralized network without a central authority, nodes must independently verify transactions and agree on the contents of new blocks to add to the chain. This verification relies heavily on cryptographic hashing and consistent data representation. Deterministic serialization ensures that all nodes compute the same hashes for the same transactions and blocks, enabling the consensus mechanism (whether Proof-of-Work, Proof-of-Stake, or BFT-based) to function correctly and maintain the integrity of the shared ledger. Formats like Binary Canonical Serialization (BCS) were explicitly designed with this use case in mind, providing guaranteed byte consistency for consensus in blockchain environments.</p>
<p>In essence, for decentralized systems that establish trust algorithmically through consensus protocols, deterministic encoding is not merely a technical optimization but a foundational requirement. It ensures that all participants operate on verifiably identical representations of shared data, making algorithmic agreement possible and enabling trust in the absence of a central coordinator. Without it, the entire model of decentralized consensus breaks down.</p>
<h3 id="142-verifiable-data-and-digital-signatures"><a class="header" href="#142-verifiable-data-and-digital-signatures">1.4.2 Verifiable Data and Digital Signatures</a></h3>
<p>Digital signatures are a cornerstone of modern digital security, providing three key properties:</p>
<ul>
<li><strong>Authenticity:</strong> Verifying the identity of the signer.</li>
<li><strong>Integrity:</strong> Ensuring the data has not been altered since it was signed.</li>
<li><strong>Non-repudiation:</strong> Preventing the signer from later denying that they signed the data.</li>
</ul>
<p>The process typically involves creating a cryptographic hash (a fixed-size digest) of the data to be signed, and then encrypting this hash using the signer's private key. To verify the signature, a recipient recalculates the hash of the received data using the same hash algorithm, decrypts the received signature using the signer's public key, and compares the recalculated hash with the decrypted hash. If they match, the signature is valid.</p>
<p>This entire process hinges on one critical assumption: both the signer and the verifier must be able to produce the <em>exact same hash</em> from the <em>same logical data</em>. Since cryptographic hashes are extremely sensitive to input changes (a single bit flip drastically changes the output), the byte sequence fed into the hash function must be identical for both parties.</p>
<p>If the data is serialized non-deterministically, the signer might serialize the data one way, calculate a hash, and sign it. The verifier might receive the same logical data, but upon re-serializing it (perhaps using a different library or version), obtain a different byte sequence. This different byte sequence will produce a different hash, causing the signature verification to fail, even though the data's integrity was never compromised and the signature itself is cryptographically sound. This necessitates a deterministic, canonical representation of the data <em>before</em> hashing and signing.</p>
<p>This requirement is crucial for applications like Verifiable Credentials (VCs), where data integrity proofs (often digital signatures) are used to ensure the authenticity and tamper-evidence of claims. Standards like the <a href="https://www.w3.org/TR/vc-data-integrity/">W3C Data Integrity specification</a> explicitly involve transforming data into a canonical form before hashing and signing/proving.</p>
<p>An important advantage of using canonicalization in this context is that it decouples the format used for signing from the format used for transmission or storage. Data can be signed based on its canonical form, but then transmitted or displayed in a more convenient, possibly non-canonical format (e.g., pretty-printed JSON for readability). The verifier simply needs to re-canonicalize the received data according to the agreed-upon rules before performing the verification step. This avoids forcing systems to use potentially inefficient or human-unfriendly formats solely for the purpose of signing, offering flexibility without sacrificing security.</p>
<h3 id="143-content-addressable-systems-and-caching"><a class="header" href="#143-content-addressable-systems-and-caching">1.4.3 Content-Addressable Systems and Caching</a></h3>
<p><strong>Content-Addressable Storage (CAS)</strong> is a storage paradigm where data is identified and retrieved based on a cryptographic hash of its content, rather than a user-assigned name or location (like a file path). The hash acts as the unique address for the data. This approach inherently relies on deterministic encoding: the same content must always produce the same hash to be reliably stored and retrieved.</p>
<p>CAS offers several significant advantages:</p>
<ul>
<li><strong>Automatic Deduplication:</strong> If the same piece of content is stored multiple times, it will always generate the same hash. CAS systems recognize this and store the actual data only once, simply adding references to the existing content. This can lead to substantial storage savings, especially in backup systems or large datasets with redundant information.</li>
<li><strong>Data Integrity Verification:</strong> The content hash serves as a built-in checksum. When data is retrieved, its hash can be recalculated and compared to the requested address (hash). A mismatch immediately indicates data corruption.</li>
<li><strong>Suitability for Distributed Systems:</strong> Content addressing works well in distributed or decentralized environments (like <a href="https://ipfs.tech/">IPFS</a> or <a href="https://git-scm.com/">Git</a>) because data can be located and retrieved based solely on its hash, without needing a central directory or knowledge of specific server locations.</li>
</ul>
<p>Deterministic encoding underpins the reliability of CAS. If serialization were non-deterministic, identical logical content could produce different hashes, defeating deduplication and potentially causing data retrieval issues. Furthermore, trustworthy deduplication relies on the guarantee that only truly identical data maps to the same hash. While cryptographic hash collisions are extremely rare with strong functions, non-deterministic serialization could theoretically create attack vectors if an adversary could manipulate the serialization process to force a hash collision between different logical data, potentially tricking a system into retrieving incorrect information. Deterministic encoding ensures that the hash reliably represents the logical content, making deduplication both efficient and secure.</p>
<p>Similarly, <strong>caching mechanisms</strong> benefit greatly from deterministic encoding. Hashes derived from canonical representations of data serve as excellent cache keys. When a system needs to check if a piece of data (e.g., a database query result, a complex object, a web resource bundle) is already in the cache, it can compute the canonical hash of the data and look it up. If the serialization were non-deterministic, logically identical data might produce different hashes upon subsequent requests, leading to cache misses and forcing redundant computations or data fetches. <a href="https://adlrocha.substack.com/p/adlrocha-webbundles-are-built-for">Content-addressable web bundles</a>, for example, leverage this principle to improve browser cache efficiency by ensuring that a bundle's content hash only changes if the content itself changes. Deterministic behavior is also a sought-after property in lower-level caching systems within hardware and operating systems to ensure predictable performance.</p>
<h3 id="144-other-applications"><a class="header" href="#144-other-applications">1.4.4 Other Applications</a></h3>
<p>Beyond these major areas, deterministic encoding provides benefits in several other contexts:</p>
<ul>
<li><strong>Secure Comparison and Fingerprinting:</strong> Comparing large datasets or complex objects for equality can be done efficiently and securely by comparing the hashes of their canonical representations. This avoids transmitting the full data and ensures that only truly identical data matches. This is useful for verifying configuration consistency, detecting changes in stored records, or fingerprinting data for various tracking purposes.</li>
<li><strong>Testing and Diagnostics:</strong> In automated testing, ensuring that a given input always produces the exact same byte output simplifies verification, allowing for simple byte-wise comparisons of expected versus actual results. For diagnostics, presenting logged data or system states in a canonical form minimizes inconsequential differences (like map key order), making it easier for humans or tools to spot meaningful changes. It can also help in reproducing bugs that might otherwise seem non-deterministic due to variations introduced by serialization.</li>
<li><strong>Object Hashing:</strong> Creating consistent, cross-language hash values for complex, nested data structures (often represented as combinations of lists, maps, and primitive types in memory) requires a canonical representation strategy. This is essential for using such objects reliably in hash tables or other contexts requiring stable identifiers derived from the object's state. Naive approaches like hashing the default string representation often fail due to non-determinism.</li>
</ul>
<h2 id="15-the-challenges-of-achieving-determinism"><a class="header" href="#15-the-challenges-of-achieving-determinism">1.5 The Challenges of Achieving Determinism</a></h2>
<p>While the need for deterministic encoding is clear, achieving it presents several non-trivial technical challenges. These stem from the inherent ambiguities in data representation and the need to impose strict, unambiguous rules across diverse platforms and implementations. Overcoming the sources of non-determinism identified earlier requires careful algorithmic design and often involves trade-offs.</p>
<ul>
<li>
<p><strong>Map Key Sorting:</strong> Defining a consistent order for map keys requires specifying a stable sorting algorithm that works identically everywhere. Lexicographical sorting is a common choice. However, the details matter: should the sort operate on the raw key strings (e.g., based on UTF-16 code units, as in JCS) or on the encoded byte representation of the keys (as in CBOR CDE)? Each choice has implications for implementation complexity and performance. Furthermore, sorting adds computational overhead compared to simply iterating through a map's elements in whatever order the underlying implementation provides.</p>
</li>
<li>
<p><strong>Floating-Point Representation:</strong> The complexities of IEEE 754 floating-point arithmetic make canonicalization difficult. Rules must precisely define how to handle different precisions (half, single, double), ensuring the shortest valid representation is chosen. Canonical forms must be defined for special values like <code>NaN</code> (potentially collapsing different <code>NaN</code> payloads into one) and distinguishing <code>+0</code> from <code>−0</code>. An additional complication is that floating-point calculations themselves can sometimes yield slightly different results across different hardware platforms or compiler optimizations, meaning the values <em>input</em> to the serializer might differ even before encoding rules are applied.</p>
</li>
<li>
<p><strong>Number Representation Ambiguity:</strong> A value like '42' could potentially be represented as a standard integer, a floating-point number, or even a bignum in some formats. A canonical scheme must provide unambiguous rules for choosing the representation, such as always preferring the simplest integer type if the value fits.</p>
</li>
<li>
<p><strong>Unicode Normalization:</strong> Deciding how to handle different Unicode representations of the same visual character is a significant challenge. Enforcing a specific Normalization Form (like NFC or NFD) ensures that visually identical strings have the same canonical byte sequence, but it adds a potentially costly processing step and might not be desirable in all applications (e.g., if preserving the exact original byte sequence is important). Schemes like JCS and CBOR CDE deliberately omit mandatory Unicode normalization, pushing the responsibility to the application layer if needed. This simplifies the canonicalization protocol but means that <code>{"café": 1}</code> and <code>{"cafe\u0301": 1}</code> might have different canonical forms despite looking identical.</p>
</li>
<li>
<p><strong>Handling Extensibility:</strong> Integrating extensibility mechanisms (like Protobuf's unknown fields or CBOR's tags) with canonicalization is difficult. Preserving unknown fields, crucial for Protobuf's compatibility story, fundamentally conflicts with canonicalization because their type and structure aren't known. For CBOR tags, while the tag's content can often be canonicalized using standard rules, ensuring the consistent use and representation of the tags themselves often requires application-level agreements (ALDR) beyond the scope of the core canonical encoding specification. A truly universal canonical format might need to restrict or disallow unknown data or require extensions to define their own canonicalization rules.</p>
</li>
<li>
<p><strong>Performance Overhead:</strong> Implementing the rules required for canonicalization—sorting keys, normalizing numbers, checking for shortest forms, potentially normalizing Unicode—inevitably adds computational cost compared to simpler serialization methods that don't enforce these constraints. This overhead might be negligible in many applications but can be significant in high-throughput or resource-constrained environments.</p>
</li>
</ul>
<p>This inherent trade-off between the robustness offered by canonicalization and the potential performance impact is a key consideration. Systems must carefully evaluate their specific needs. The desire for performance often leads developers to use simpler, potentially non-deterministic serialization methods by default. This explains why canonical encoding isn't universally applied and why formats like CBOR offer different levels of determinism (Preferred, Basic, CDE), allowing applications to choose the appropriate balance between strictness and speed.</p>
<h2 id="16-surveying-the-landscape-previous-efforts"><a class="header" href="#16-surveying-the-landscape-previous-efforts">1.6 Surveying the Landscape: Previous Efforts</a></h2>
<p>Over the years, various efforts have been made to address the need for deterministic or canonical representations, particularly for common data formats used in distributed systems and security protocols. Examining these provides valuable context and highlights recurring patterns and challenges.</p>
<h3 id="161-jsons-canonicalization-conundrum"><a class="header" href="#161-jsons-canonicalization-conundrum">1.6.1 JSON's Canonicalization Conundrum</a></h3>
<p>JSON (JavaScript Object Notation), despite its ubiquity, lacks a built-in canonical representation defined in its base specification (<a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259</a>). This omission means that naive serialization of JSON objects can easily lead to non-deterministic output due to varying property order and potential whitespace differences.</p>
<p>Several approaches have emerged to fill this gap:</p>
<ul>
<li>
<p><strong>RFC 8785: JSON Canonicalization Scheme (JCS):</strong> This is arguably the most prominent standard for JSON canonicalization. JCS achieves determinism by defining a strict set of rules:</p>
<ul>
<li><strong>Data Subset:</strong> Input JSON must conform to the I-JSON profile (<a href="https://datatracker.ietf.org/doc/html/rfc7493">RFC 7493</a>), which disallows duplicate object keys and imposes limits on number precision.</li>
<li><strong>Primitive Serialization:</strong> Relies on the well-defined serialization of primitives (strings, numbers, booleans, null) specified by ECMAScript. Whitespace between tokens is forbidden.</li>
<li><strong>String Handling:</strong> Specifies precise escaping rules for control characters and special characters like backslash and double-quote. Notably, it does <em>not</em> mandate Unicode normalization.</li>
<li><strong>Number Handling:</strong> Numbers are serialized according to ECMAScript rules, effectively using IEEE 754 double-precision representation.</li>
<li><strong>Object Key Sorting:</strong> Object properties MUST be sorted recursively based on the lexicographical order of their keys, comparing the keys as sequences of UTF-16 code units.</li>
<li><strong>Array Element Order:</strong> The order of elements within JSON arrays is preserved.</li>
<li><strong>Encoding:</strong> The final output must be UTF-8 encoded.</li>
</ul>
<p>JCS is published as an Informational RFC, meaning it's not an IETF standard but represents a community consensus. It has seen adoption in specific contexts, such as for JSON Web Key (JWK) Thumbprints (<a href="https://www.rfc-editor.org/rfc/rfc7638.html">RFC 7638</a>) and systems like Keybase, and libraries exist in multiple languages. However, it is not universally adopted across the JSON ecosystem, leading to a degree of fragmentation where applications might implement their own ad-hoc canonicalization or use different schemes.</p>
</li>
<li>
<p><strong>ObjectHash:</strong> This represents a different philosophy. Instead of producing a canonical <em>text</em> representation, <a href="https://github.com/benlaurie/objecthash">ObjectHash</a> computes a cryptographic hash directly from the semantic structure of a JSON-like object (lists, dictionaries, primitives). It defines specific hashing procedures for each type, including sorting dictionary keys before hashing. A key feature is its support for redaction: parts of a structure can be replaced by the hash of the redacted part, allowing verification of the overall structure even with hidden data. This approach avoids intermediate text serialization altogether.</p>
</li>
<li>
<p><strong>Other Ad-hoc Methods:</strong> Many systems implement simpler, non-standardized canonicalization, often just involving sorting object keys alphabetically before using a standard JSON serializer. While better than no canonicalization, these methods lack the precise rules for primitive serialization found in JCS and may not be interoperable.</p>
</li>
</ul>
<p>The situation for JSON highlights the difficulty of retrofitting canonicalization onto a widely adopted, flexible format without a single, mandated standard.</p>
<p><strong>Comparison of Selected JSON Canonicalization Approaches</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>RFC 8785 JCS</th><th>ObjectHash</th><th>Ad-hoc Sorting + JSON.stringify</th></tr></thead><tbody>
<tr><td><strong>Approach</strong></td><td>Canonical Text Serialization</td><td>Direct Cryptographic Hashing of Structure</td><td>Text Serialization after Key Sort</td></tr>
<tr><td><strong>Output</strong></td><td>UTF-8 JSON Text</td><td>Cryptographic Hash (e.g., SHA-256)</td><td>JSON Text (often UTF-8)</td></tr>
<tr><td><strong>Basis</strong></td><td>RFC 8785 (Informational)</td><td>Custom Specification</td><td>Application-specific</td></tr>
<tr><td><strong>Object/Map Key Ordering</strong></td><td>Mandatory Lexicographical Sort (UTF-16 units)</td><td>Mandatory Lexicographical Sort (before hashing)</td><td>Typically Lexicographical Sort (implementation varies)</td></tr>
<tr><td><strong>Number Handling</strong></td><td>ECMAScript standard (IEEE 754 double)</td><td>Specific hashing rule for numbers</td><td>Depends on underlying JSON serializer</td></tr>
<tr><td><strong>String Handling</strong></td><td>ECMAScript standard; No Unicode Normalization</td><td>Specific hashing rule; No Unicode Normalization</td><td>Depends on underlying JSON serializer</td></tr>
<tr><td><strong>Extensibility/Unknowns</strong></td><td>Constrained by I-JSON; No explicit unknown handling</td><td>Handles basic JSON types; Redaction mechanism</td><td>Depends on underlying JSON serializer</td></tr>
<tr><td><strong>Key Features</strong></td><td>Interoperable text form, Cryptographic use</td><td>Redactability, Avoids text intermediate</td><td>Simplicity (potentially fragile)</td></tr>
<tr><td><strong>Adoption Notes</strong></td><td>Used in JWK Thumbprint, Keybase; Libraries exist</td><td>Used in specific projects (e.g., Certificate Transparency logs)</td><td>Common but non-standardized</td></tr>
</tbody></table>
</div>
<h3 id="162-asn1-distinguished-encoding-rules-der"><a class="header" href="#162-asn1-distinguished-encoding-rules-der">1.6.2 ASN.1 Distinguished Encoding Rules (DER)</a></h3>
<p>Abstract Syntax Notation One (<a href="https://en.wikipedia.org/wiki/ASN.1">ASN.1</a>) is a mature standard from the ITU-T for defining data structures, widely used in telecommunications and security protocols. Associated with ASN.1 are several encoding rule sets that specify how to serialize data structures into bytes. The most relevant for canonicalization is the <strong>Distinguished Encoding Rules (DER)</strong>, specified in ITU-T X.690.</p>
<p>DER is a specialized subset of the more flexible Basic Encoding Rules (BER). While BER allows multiple ways to encode the same value (e.g., different length specifications, constructed vs. primitive string forms), DER restricts these choices to ensure that any given ASN.1 value has exactly one valid DER encoding. This canonical property is achieved primarily through restriction: DER mandates specific choices where BER offers flexibility:</p>
<ul>
<li><strong>Length Encoding:</strong> Length fields must use the definite form and the minimum possible number of octets. Indefinite lengths (allowed in BER) are prohibited.</li>
<li><strong>String Types:</strong> Primitive encoding must be used for string types like OCTET STRING and BIT STRING (BER allows constructed forms). Unused bits in the final octet of a BIT STRING must be zero.</li>
<li><strong>Boolean Values:</strong> FALSE must be encoded as a single byte <code>0x00</code>, and TRUE as a single byte <code>0xFF</code>.</li>
<li><strong>Set Ordering:</strong> Elements within a SET OF construct must be sorted according to their tag value and encoded bytes.</li>
<li><strong>Default Values:</strong> Fields with default values defined in the ASN.1 schema must NOT be encoded if they hold the default value.</li>
</ul>
<p>The primary application of DER is in Public Key Infrastructure (PKI), particularly for encoding <strong>X.509 digital certificates</strong> and Certificate Revocation Lists (CRLs). The unambiguous nature of DER is critical for ensuring that certificates can be parsed and validated consistently across different systems and that digital signatures covering certificate contents are reliable.</p>
<p>DER's success lies in its long-standing use and effectiveness within its specific domain (PKI). It demonstrates that canonicalization can be achieved and maintained over decades. However, ASN.1 and DER are often perceived as complex and potentially verbose compared to more modern formats like JSON or CBOR, which has limited their adoption in web-centric APIs and applications.</p>
<h3 id="163-hashing-and-signing-strategies"><a class="header" href="#163-hashing-and-signing-strategies">1.6.3 Hashing and Signing Strategies</a></h3>
<p>The interaction between data serialization and cryptographic operations like hashing and digital signing is a critical area where determinism is paramount. The overwhelmingly standard practice is to <strong>canonicalize the data first, then apply the cryptographic operation (hash or signature) to the resulting canonical byte stream</strong>.</p>
<p>Signing non-canonical data introduces significant risks. A signature created over one specific byte representation might be valid only for that exact sequence. If the recipient re-serializes the data differently (due to non-deterministic rules), the signature verification will fail, even if the logical data is unchanged. This can lead to false integrity failures or, in more complex scenarios, potentially allow an attacker to craft a different serialization of the same logical data that bypasses certain checks while still matching the original signature under lenient verification rules. Canonicalization before signing ensures that the signature is bound to the <em>semantic content</em> rather than a specific, potentially fragile, byte layout.</p>
<p>It is important to distinguish the canonicalization of the <em>message</em> input from the determinism of the <em>signature algorithm</em> itself. Some signature algorithms, like DSA and ECDSA, traditionally required a random number (nonce) for each signature. Flaws in the random number generation process have historically led to catastrophic private key compromises. To mitigate this, <strong>deterministic signature generation</strong> schemes have been developed, such as RFC 6979 for DSA/ECDSA and the inherent design of algorithms like Ed25519. These schemes derive the necessary nonce deterministically from the private key and the message hash, eliminating the need for external randomness during signing.</p>
<p>Therefore, achieving robust and reliable digital signatures often involves ensuring determinism at two distinct layers:</p>
<ol>
<li><strong>Deterministic Message Representation:</strong> Using canonicalization to ensure the input to the hash function is consistent.</li>
<li><strong>Deterministic Signature Computation:</strong> Using algorithms that derive internal randomness (like nonces) deterministically to avoid reliance on potentially flawed external random sources. Both layers address different potential failure points and contribute to the overall security and reliability of the signing process.</li>
</ol>
<h3 id="164-other-binary-formats-brief-mention"><a class="header" href="#164-other-binary-formats-brief-mention">1.6.4 Other Binary Formats (Brief Mention)</a></h3>
<p>While JSON and ASN.1/DER represent major text and schema-driven binary approaches, other binary formats also grapple with determinism:</p>
<ul>
<li>
<p><strong>Protocol Buffers (Protobuf):</strong> As mentioned earlier, Protobuf offers a "deterministic serialization" mode. However, the documentation clearly states this is <em>not</em> canonical. It guarantees byte consistency only for a specific binary build and schema version, but not across different language implementations, library versions, or even schema evolution (due to the handling of unknown fields). Its design prioritizes compatibility and efficiency over strict canonicalization. Specific deterministic schemes have been layered on top for specific use cases, like Cosmos SDK's ADR-027, which adds rules for field ordering, varint encoding, and default value handling.</p>
</li>
<li>
<p><strong>Binary Canonical Serialization (BCS):</strong> In contrast to Protobuf, <a href="https://move-book.com/programmability/bcs.html">BCS</a> was explicitly designed from the ground up with canonicalization as a primary goal. Originating in the Diem blockchain project (defunct) and now used widely in the Move language ecosystem (Sui, Aptos), BCS aims for simplicity, efficiency, and a guaranteed one-to-one mapping between in-memory values and byte representations. It defines strict rules for encoding primitives (little-endian integers, ULEB128 for lengths), sequences, maps (implicitly requiring ordered keys for canonicalization, though the base spec focuses more on structs), and structs (fields serialized in definition order). Its primary motivation is to support cryptographic hashing and consensus mechanisms in blockchains.</p>
</li>
</ul>
<h2 id="17-lessons-learned-successes-shortcomings-and-the-path-forward"><a class="header" href="#17-lessons-learned-successes-shortcomings-and-the-path-forward">1.7 Lessons Learned: Successes, Shortcomings, and the Path Forward</a></h2>
<p>The survey of deterministic and canonical encoding efforts reveals valuable lessons about what has worked, what challenges persist, and what properties are desirable in future solutions.</p>
<p><strong>Successes:</strong></p>
<ul>
<li><strong>Domain-Specific Stability:</strong> ASN.1 DER demonstrates that a strict canonical encoding standard can achieve long-term stability and interoperability within a well-defined domain like PKI, serving as the foundation for X.509 certificates for decades.</li>
<li><strong>Addressing Common Formats:</strong> Efforts like JCS (RFC 8785) provide a viable, albeit not universally adopted, solution for canonicalizing JSON, leveraging existing widespread technologies like ECMAScript for primitive serialization.</li>
<li><strong>Purpose-Built Solutions:</strong> Formats like BCS show that when canonicalization is a primary design goal, especially for demanding use cases like blockchain consensus, efficient and effective binary formats can be created.</li>
<li><strong>Enabling Critical Patterns:</strong> Canonicalization is demonstrably essential for enabling robust digital signatures, reliable distributed consensus, and efficient content-addressable storage and caching.</li>
</ul>
<p><strong>Shortcomings and Persistent Challenges:</strong></p>
<ul>
<li><strong>Fragmentation:</strong> For popular, flexible formats like JSON, the lack of a single, universally mandated canonicalization standard leads to fragmentation, with multiple competing schemes or ad-hoc solutions.</li>
<li><strong>Design Conflicts:</strong> Some formats, like Protocol Buffers, have core design features (e.g., handling of unknown fields for compatibility) that inherently conflict with the requirements for true canonicalization across different contexts.</li>
<li><strong>Complexity and Overhead:</strong> Achieving canonicalization often introduces complexity in implementation and runtime overhead due to steps like sorting or normalization, creating a trade-off against performance. This can make canonical forms less appealing for performance-critical applications if the benefits are not strictly required. ASN.1/DER, while successful, is often perceived as overly complex for simpler web-based use cases.</li>
<li><strong>Handling Nuances:</strong> Accurately and consistently handling the subtleties of floating-point arithmetic and Unicode across all platforms remains a persistent challenge requiring explicit and careful rule definition.</li>
<li><strong>Extensibility:</strong> Integrating extensibility mechanisms (like tags or user-defined types) into a canonical framework without requiring constant updates to the core specification or relying heavily on application-level agreements remains difficult.</li>
</ul>
<p>A recurring theme emerges from these observations: the inherent tension between designing a data format for maximum flexibility and extensibility, and achieving strict, simple canonicalization. Features enhancing flexibility—multiple number encodings, optional fields, variable map ordering, mechanisms for unknown data—often introduce the very ambiguities that canonicalization seeks to eliminate. Consequently, canonical formats frequently achieve their goal by <em>restricting</em> the flexibility of the underlying data model or base encoding rules (DER restricts BER, CDE restricts CBOR, JCS restricts JSON via I-JSON). Designing a format that balances flexibility with ease of canonicalization requires careful consideration from the outset.</p>
<p>The Path Forward:</p>
<p>The increasing prevalence of distributed systems, the demand for verifiable data (like VCs), and the constant need for robust security mechanisms ensure that the need for reliable deterministic and canonical encoding will only grow. An ideal solution, building on the lessons learned, should strive for:</p>
<ul>
<li><strong>Unambiguity:</strong> Clear, precise rules that leave no room for interpretation and lead to a single, verifiable canonical form.</li>
<li><strong>Efficiency:</strong> Minimize computational overhead compared to non-canonical serialization, making it practical for a wider range of applications.</li>
<li><strong>Simplicity:</strong> Easy to understand and implement correctly, reducing the likelihood of errors (a key goal of CBOR itself).</li>
<li><strong>Robustness:</strong> Handle common data types, including integers, floating-point numbers, and strings (with clear rules regarding Unicode), effectively.</li>
<li><strong>Well-Defined Extensibility:</strong> Provide a clear path for extending the format without breaking canonical properties or requiring constant core specification updates.</li>
</ul>
<p>These desirable properties set the stage for exploring more advanced solutions designed to meet these needs within the context of modern data formats. The subsequent chapters will delve into how dCBOR aims to provide such a solution within the CBOR ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-cbor-to-cde-to-dcbor"><a class="header" href="#from-cbor-to-cde-to-dcbor">From CBOR, to CDE, to dCBOR</a></h1>
<h2 id="21-introduction-the-need-for-stronger-guarantees"><a class="header" href="#21-introduction-the-need-for-stronger-guarantees">2.1 Introduction: The Need for Stronger Guarantees</a></h2>
<p>The previous chapter established a fundamental challenge in modern software engineering: the attainment of "sameness" at the byte level. Logically identical data structures, when serialized, often yield different byte sequences due to flexibilities inherent in many common encoding formats. This variability, while sometimes semantically irrelevant at the data model level, introduces a pernicious form of non-determinism into systems. Processes relying on byte-wise comparison, cryptographic hashing, digital signature verification, or distributed consensus can fail unpredictably, leading to hard-to-diagnose bugs and undermining security guarantees.</p>
<p>The Concise Binary Object Representation (CBOR), standardized as <a href="https://www.rfc-editor.org/rfc/rfc8949.html">RFC 8949 (STD 94)</a>, was designed with goals including efficiency, small code size, and extensibility. Recognizing the importance of consistency, the base CBOR specification itself incorporates mechanisms aimed at reducing encoding variability. Section 4.1 of RFC 8949 introduces <strong>Preferred Serialization</strong>, which provides recommendations for choosing the most efficient encoding, particularly the shortest form for the initial bytes (head) indicating an item's type and length/value, and specific representations for floating-point numbers. Building upon this, Section 4.2.2 defines <strong>Basic Serialization</strong>, which mandates the use of preferred serialization and adds the strict requirement that indefinite-length encodings (where the total length is not known upfront) must not be used for strings, arrays, or maps.</p>
<p>These built-in features represent valuable steps toward consistency. However, they deliberately stop short of guaranteeing strict, cross-implementation deterministic encoding. Preferred Serialization, for instance, is largely a set of <em>recommendations</em>, not absolute requirements for a CBOR document to be considered valid. Even Basic Serialization, while stricter by disallowing indefinite lengths, leaves significant sources of variability unaddressed. Key limitations remain:</p>
<ul>
<li><strong>Map Key Order:</strong> The order of key-value pairs in CBOR maps (major type 5) is explicitly considered semantically insignificant in the data model, similar to JSON objects. RFC 8949, therefore, does not mandate any specific order for serialization. Consequently, different CBOR libraries, or even different executions of the same library (depending on internal hash table implementations), might output the keys of a logically identical map in different orders, resulting in different byte sequences.</li>
<li><strong>Number Representation Choices:</strong> While Preferred Serialization aims for the shortest forms, potential ambiguities can persist without stricter enforcement, particularly around floating-point edge cases (like NaN or signed zeros) or how integers near the boundaries of different encoding lengths are handled.</li>
<li><strong>Implementation Variance:</strong> Most critically, the section in RFC 8949 titled "Deterministically Encoded CBOR" (Section 4.2) explicitly acknowledges that achieving deterministic encoding may involve application-specific decisions, providing flexibility rather than a single, universal set of rules. This inherent flexibility means that different CBOR encoders, even when attempting to produce "deterministic" output according to the base standard's guidelines, might make slightly different choices, leading to byte-level inconsistencies across platforms, languages, or library versions.</li>
</ul>
<p>This deliberate balance in RFC 8949 reflects a common approach in standards development: providing flexibility for broad applicability while offering guidance for common needs. Mandating full canonicalization, including potentially costly operations like map key sorting, for all CBOR use cases might impose unnecessary overhead. Preferred and Basic Serialization offer levels of consistency suitable for many applications. However, the remaining ambiguities highlighted the need for more rigorous, standardized rules for applications where absolute, interoperable byte consistency is not just desirable but essential – use cases like cryptographic verification, consensus protocols, and content-addressable storage. This gap set the stage for the development of CBOR Common Deterministic Encoding (CDE) and, subsequently, dCBOR.</p>
<h2 id="22-stepping-up-cbor-common-deterministic-encoding-cde"><a class="header" href="#22-stepping-up-cbor-common-deterministic-encoding-cde">2.2 Stepping Up: CBOR Common Deterministic Encoding (CDE)</a></h2>
<p>Recognizing the limitations of base CBOR's determinism guidelines for critical applications, the IETF CBOR Working Group initiated work on the CBOR Common Deterministic Encoding (CDE) specification (draft-ietf-cbor-cde). CDE represents a community effort to define a standardized, stricter set of encoding rules built upon CBOR, aiming to provide a reliable baseline for deterministic output that can be shared across diverse applications and implemented as a selectable feature in generic CBOR encoders. Its purpose is to systematically eliminate the ambiguities left open by RFC 8949's Section 4.2, thereby facilitating interoperable deterministic encoding.</p>
<p>CDE achieves this by mandating specific choices where base CBOR (even with Basic Serialization) offered flexibility. Conceptually, the key rules introduced by CDE include:</p>
<ul>
<li><strong>Mandatory Map Key Sorting:</strong> CDE decisively addresses the map key ordering problem. It <em>requires</em> that the key-value pairs in a CBOR map (major type 5) be sorted based on the byte-wise lexicographical order of the <em>encoded representation</em> of each key. This means the raw bytes of the encoded key determine the sort order, not the semantic value of the key itself. This choice represents a pragmatic approach, favoring implementation simplicity and unambiguousness over potentially more complex semantic sorting (e.g., Unicode collation for text keys). While perhaps counter-intuitive in edge cases (like numerically equivalent keys encoded differently), sorting by encoded bytes provides a clear, efficient, and universally applicable rule, eliminating a major source of non-determinism.</li>
<li><strong>Strict Number Representations:</strong> CDE tightens the rules for number encoding beyond Preferred Serialization:
<ul>
<li><strong>Integers:</strong> Positive integers from <code>0</code> up to <code>2⁶⁴−1</code> MUST be encoded using unsigned integer types (major type 0). Negative integers from <code>−1</code> down to <code>−(2⁶⁴)</code> MUST be encoded using negative integer types (major type 1). For integers outside this 64-bit range, CBOR tags 2 (positive bignum) and 3 (negative bignum) MUST be used, following preferred serialization rules, and crucially, the byte string content of these tags MUST NOT contain leading zero bytes.</li>
<li><strong>Floating-Point Numbers:</strong> All floating-point values MUST use their preferred serialization (typically the shortest IEEE 754 representation that accurately represents the value). CDE clarifies specific handling:
<ul>
<li>Positive zero (<code>+0</code>) and negative zero (<code>-0</code>) are encoded using their distinct IEEE 754 representations (e.g., negative zero as <code>0xf98000</code> for half-precision) without further special action.</li>
<li><code>NaN</code> (Not a Number) values follow preferred serialization, using the canonical NaN encoding from IEEE 754. This often involves using the shortest form by removing trailing zeros in the payload and ensuring quiet NaNs have the leading significand bit set to 1.</li>
<li>Importantly, CDE explicitly <em>prohibits</em> mixing integer and floating-point types based on mathematical value. A value represented as a float in the data model MUST be encoded as a float, even if it is mathematically equivalent to an integer (e.g., 10.0 is encoded as a float, not the integer 10). This maintains a clear separation between types at the encoding level.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Disallowing Indefinite Lengths:</strong> CDE fully incorporates the rule from Basic Serialization, prohibiting the use of indefinite-length encodings for text strings (major type 3), byte strings (major type 2), arrays (major type 4), and maps (major type 5). Length must always be specified definitively.</li>
<li><strong>Requiring Basic Validity:</strong> CDE mandates that encoders MUST produce CBOR that meets the "Basic Validity" requirements of RFC 8949 (Section 5.3.1). This includes ensuring that map keys are unique and that text strings contain valid UTF-8 sequences. Furthermore, CDE decoders MUST check for these validity conditions.</li>
</ul>
<p>CDE, therefore, establishes a significantly more constrained profile of CBOR compared to Basic Serialization. It provides a robust foundation for achieving interoperable deterministic encoding suitable for many applications. However, the CDE specification also acknowledges that some applications might have even more specific requirements regarding the deterministic representation of application-level data. It introduces the concept of <strong>Application-Level Deterministic Representation (ALDR)</strong> rules, which operate on top of CDE to handle application-specific semantics, such as defining equivalence between different numeric types (e.g., integer 10 vs float 10.0) if needed by the application. By focusing on canonicalization <em>within</em> CBOR's type system and leaving cross-type semantics to the application layer, CDE maintains a manageable scope and broad applicability, serving as a common denominator for deterministic needs.</p>
<h2 id="23-the-vision-and-the-need-enter-dcbor"><a class="header" href="#23-the-vision-and-the-need-enter-dcbor">2.3 The Vision and the Need: Enter dCBOR</a></h2>
<p>While CDE represented a significant advancement towards standardized deterministic encoding, the impetus for an even stricter set of rules emerged from a specific vision and a pressing practical need. This vision was largely articulated by Christopher Allen and pursued through the work of Blockchain Commons, focusing on enabling a new generation of secure, private, and user-controlled digital interactions. Central to this vision is the concept of the <strong>Gordian Envelope</strong>, designed as a format for "smart documents" capable of handling complex, hierarchical data while prioritizing user privacy and control.</p>
<p>The Gordian vision emphasizes several key principles, including independence, privacy, resilience, and openness. Gordian Envelope aims to embody these principles by being:</p>
<ul>
<li><strong>Structure-Ready:</strong> Capable of reliably encoding and storing diverse information structures, ranging from simple data items to semantic triples and property graphs, allowing for the creation of rich, interoperable "smart documents".</li>
<li><strong>Privacy-Ready:</strong> Designed to protect user privacy through mechanisms supporting progressive trust and minimal disclosure. A core feature is <strong>elision</strong>, which allows the holder of an Envelope (not just the original issuer) to selectively redact or hide specific parts of the data before sharing it, revealing only what is necessary for a given interaction.</li>
<li><strong>Verifiable:</strong> Built upon a foundation of cryptographic integrity. Envelopes incorporate a built-in, Merkle-like digest tree, where components of the Envelope are cryptographically hashed. This structure allows for verification of data integrity and authenticity, even after parts have been elided, through Merkle proofs.</li>
</ul>
<p>Part III of this book will explore the Gordian Envelope in detail, including its structure, use cases, and the cryptographic mechanisms that underpin its functionality.</p>
<p>Translating this vision into a working system created a concrete technical requirement for Blockchain Commons. The functionality of Gordian Envelope, particularly its reliance on cryptographic hashing for the Merkle structure and elision mechanisms, demanded a serialization format with <em>absolute</em>, unambiguous byte-level consistency. CBOR was selected as the underlying format due to its inherent advantages: conciseness, binary efficiency, extensibility, and its status as an IETF standard.</p>
<p>However, any variability in the serialization of Envelope components would lead to different cryptographic hashes. This would break the integrity of the Merkle tree, render elision proofs invalid, and undermine the entire system's security and verifiability guarantees. The features enabling privacy and verification in Gordian Envelope are thus directly dependent on the deterministic nature of the underlying data representation. While base CBOR offered some guidance, and CDE was emerging as a stronger baseline, neither provided the specific, rigorous, and unwavering guarantees required for the core mechanics of Gordian Envelope. Blockchain Commons identified this gap and recognized the need to define and implement a stricter profile of CBOR deterministic encoding – the profile that became known as dCBOR.</p>
<h2 id="24-a-tale-of-two-standards-the-emergence-of-cde-and-dcbor"><a class="header" href="#24-a-tale-of-two-standards-the-emergence-of-cde-and-dcbor">2.4 A Tale of Two Standards: The Emergence of CDE and dCBOR</a></h2>
<p>The path to standardized, highly deterministic CBOR involved parallel development and subsequent harmonization between the specific needs driving dCBOR and the broader goals of the IETF CBOR Working Group. The initial impetus and definition for the stricter rules required by Gordian Envelope originated within Blockchain Commons, spearheaded by Lead Researcher Wolf McNally. This internal effort focused on creating a CBOR encoding profile that eliminated ambiguities left unaddressed even by CBOR's preferred and basic serialization modes, ensuring the absolute byte consistency needed for Envelope's hash-based structures. Early implementations and specifications for this stricter profile were developed to meet these internal requirements.</p>
<p>Recognizing the potential value of this work for the wider community and the importance of standardization, Blockchain Commons brought their findings and proposals to the IETF CBOR Working Group. This engagement included presentations, active participation in mailing list discussions (starting around February 2023), and the submission of individual Internet-Drafts detailing their proposed deterministic CBOR profile, <a href="https://datatracker.ietf.org/doc/draft-mcnally-deterministic-cbor/">draft-mcnally-deterministic-cbor</a>.</p>
<p>This input, alongside other potential use cases for deterministic encoding, influenced the direction of the CBOR Working Group. The WG recognized the need for a standardized <em>common</em> baseline for deterministic encoding that could serve a wide range of applications. This led to the development of the CBOR Common Deterministic Encoding (CDE) specification (<a href="https://datatracker.ietf.org/doc/draft-ietf-cbor-cde/">draft-ietf-cbor-cde</a>), primarily edited by Carsten Bormann, a key figure in the CBOR community. CDE was designed to capture the essential requirements for achieving interoperable determinism, such as map key sorting and canonical number representations, establishing an intermediate layer between base CBOR and more specialized needs.</p>
<p>Through discussion and collaboration within the working group, a clear relationship between CDE and the Blockchain Commons proposal emerged. CDE solidified its position as the official IETF WG effort defining the <em>common</em> deterministic encoding profile. The stricter set of rules developed by Blockchain Commons, initially conceived to meet Gordian Envelope's needs, was then positioned as <strong>dCBOR</strong>: a specific <em>application profile</em> built <em>on top of</em> CDE. This layering allows applications requiring the baseline determinism of CDE to use it directly, while applications with more stringent requirements, like Gordian Envelope, can adopt the dCBOR profile, which incorporates all CDE rules plus additional constraints.</p>
<p>This collaborative process is reflected in the co-authorship of later versions of the dCBOR Internet-Draft, which includes Wolf McNally, Christopher Allen, Carsten Bormann, and Laurence Lundblade, representing both the originators of the dCBOR requirements and key contributors to the broader CBOR and CDE standardization efforts. This convergence signifies a successful harmonization, ensuring that dCBOR exists as a well-defined extension within the CDE framework, rather than a divergent standard. The development also highlights the iterative nature of IETF work, with ongoing discussions and potential refinements, and illustrates a common pattern in standards development: a specific, implementation-driven need catalyzes a broader standardization effort, often resulting in layered specifications that cater to both general and specialized requirements.</p>
<h2 id="25-understanding-profiles-layering-constraints"><a class="header" href="#25-understanding-profiles-layering-constraints">2.5 Understanding Profiles: Layering Constraints</a></h2>
<p>The relationship between CBOR, CDE, and dCBOR is best understood through the concept of a "profile," a common mechanism used within the IETF and other standards bodies to manage the evolution and specialization of technical specifications. <a href="https://datatracker.ietf.org/doc/html/rfc6906">RFC 6906</a>, which defines the 'profile' link relation type, provides a useful definition: a profile allows resource representations (or, by extension, data formats) to indicate that they follow additional semantics – such as constraints, conventions, or extensions – beyond those defined by the base specification (like a media type or, in this case, the base CBOR standard).</p>
<p>Crucially, a profile is defined <em>not</em> to alter the fundamental semantics of the base specification for consumers unaware of the profile. This means a generic CBOR parser should still be able to process data encoded according to a CBOR profile like CDE or dCBOR, even if it cannot validate the profile-specific constraints. Profiles allow different communities or applications to tailor a base standard for their specific needs, promoting interoperability within that community without requiring changes to the underlying, more general standard.</p>
<p>Applying this concept:</p>
<ul>
<li><strong>CDE is a Profile of CBOR:</strong> The CDE specification explicitly defines itself as a profile that builds upon the Core Deterministic Encoding Requirements of RFC 8949. It selects specific encoding options permitted by base CBOR (like preferred number representations) and mandates them. It also adds new constraints not present in the base standard, most notably the requirement to sort map keys lexicographically based on their encoded bytes. These rules constrain the flexibility of base CBOR to achieve a common level of determinism.</li>
<li><strong>dCBOR is a Profile of CDE:</strong> The dCBOR specification, in turn, explicitly defines itself as an <em>application profile</em> that conforms to, and further constrains, CDE. It inherits all the rules mandated by CDE (including map key sorting, canonical number forms, no indefinite lengths) and then adds its own, stricter requirements. These additional dCBOR-specific constraints include numeric reduction (treating certain floats and integers as equivalent), mandatory Unicode NFC normalization for strings, and limitations on allowed simple values.</li>
</ul>
<p>This layered profiling approach offers significant advantages. It allows standardization to occur at different levels of granularity, catering to both general needs (CDE) and highly specific application requirements (dCBOR). It promotes interoperability because the profiles build upon each other hierarchically, ensuring that dCBOR data is also valid CDE data, which is also valid CBOR data. This avoids "forking" the standard, where incompatible versions might arise, and instead anchors specialized requirements within the established ecosystem. The use of profiles is thus a key tool enabling standards like CBOR to remain stable at their core while adapting to new and demanding use cases through well-defined, constrained profiles.</p>
<h2 id="26-the-hierarchy-cbor-cde-and-dcbor"><a class="header" href="#26-the-hierarchy-cbor-cde-and-dcbor">2.6 The Hierarchy: CBOR, CDE, and dCBOR</a></h2>
<p>The relationship established through profiling creates a clear hierarchy: dCBOR is a specialized subset of CDE, which is itself a specialized subset of the possible encodings allowed by the base CBOR specification. This can be represented as:</p>
<p><code>dCBOR ⊆ CDE ⊆ CBOR</code></p>
<p>This subset relationship has a crucial practical implication known as the <strong>validity chain</strong>:</p>
<ul>
<li>Any sequence of bytes that constitutes a valid dCBOR encoding is, by definition, also a valid CDE encoding.</li>
<li>Any sequence of bytes that constitutes a valid CDE encoding is, by definition, also a valid CBOR encoding (specifically, one that conforms to Basic Serialization plus map sorting and other CDE rules).</li>
</ul>
<p>The reverse, however, is not true. A generic CBOR document may violate CDE rules (e.g., use indefinite lengths or unsorted map keys), and a CDE document may violate dCBOR rules (e.g., contain a float like 10.0 instead of the integer 10, or use non-NFC strings).</p>
<p>This hierarchy means that basic parsing compatibility is maintained. A generic CBOR decoder can parse the structure of CDE or dCBOR data. A CDE-aware decoder can parse dCBOR data and validate its conformance to CDE rules. However, only a dCBOR-aware decoder can fully validate all the specific constraints imposed by the dCBOR profile, such as numeric reduction or NFC string normalization. This ensures that dCBOR can be integrated into existing CBOR/CDE workflows without breaking basic interoperability, while still allowing for stricter validation where required.</p>
<p>The key differences introduced at each level, representing progressively tighter constraints on the encoding process, can be summarized as follows:</p>
<ul>
<li><strong>CBOR (Basic Serialization) → CDE:</strong>
<ul>
<li><strong>Map Key Order:</strong> Becomes mandatory; keys MUST be sorted lexicographically based on their encoded byte representation.</li>
<li><strong>Number Encoding:</strong> Preferred/shortest forms become mandatory, with specific canonical rules for floats (including NaN) and large integers (tags 2/3 without leading zeros). Mixing integer/float types for mathematically equivalent values is prohibited.</li>
<li><strong>Basic Validity:</strong> Explicitly required (no duplicate map keys, valid UTF-8).</li>
</ul>
</li>
<li><strong>CDE → dCBOR:</strong>
<ul>
<li><strong>Numeric Reduction:</strong> Mandatory; floating-point numbers that are numerically equal to integers within the range [−2⁶³,2⁶⁴−1] MUST be encoded as integers. All <code>NaN</code> values MUST be reduced to a single canonical half-precision quiet NaN (<code>0xf97e00</code>).</li>
<li><strong>Simple Values:</strong> Restricted; only <code>false</code>, <code>true</code>, <code>null</code>, and floating-point values (major type 7, subtypes 20-27) are permitted. Other simple values (subtypes 0-19, 28-255) are disallowed.</li>
<li><strong>String Normalization:</strong> Mandatory; all text strings MUST be encoded in <a href="https://unicode.org/reports/tr15/">Unicode Normalization Form C (NFC)</a>.</li>
<li><strong>Duplicate Map Keys:</strong> Explicitly rejected by decoders (building on CDE's requirement for encoders not to emit them).</li>
<li><strong>Validity Checking by Decoders:</strong> Decoders MUST reject any data that does not conform to dCBOR rules, including CDE rules.</li>
</ul>
</li>
</ul>
<p>The following table provides a comparative overview of how key sources of non-determinism are handled at each level:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>CBOR (Basic Serialization)</th><th>CDE (CBOR Common Deterministic Encoding)</th><th>dCBOR (Application Profile)</th></tr></thead><tbody>
<tr><td><strong>Map Key Order</strong></td><td>Not specified (any order allowed)</td><td>Mandatory: Lexicographical sort of <em>encoded</em> key bytes</td><td>Mandatory: Lexicographical sort of <em>encoded</em> key bytes</td></tr>
<tr><td><strong>Integer Encoding</strong></td><td>Preferred (shortest head) mandatory; No indefinite length</td><td>Preferred mandatory; Strict rules for 64-bit range &amp; tags 2/3 (no leading zeros)</td><td>Inherits CDE rules</td></tr>
<tr><td><strong>Float Encoding</strong></td><td>Preferred (shortest IEEE 754) mandatory; No indefinite length</td><td>Preferred mandatory; Canonical NaN; No int/float mixing</td><td>Inherits CDE rules; Canonical NaN reduced to <code>0xf97e00</code></td></tr>
<tr><td><strong>Numeric Reduction</strong></td><td>Not applicable</td><td>Not specified (handled by ALDR if needed)</td><td>Mandatory: Float-to-int reduction; Canonical NaN reduction</td></tr>
<tr><td><strong>Indefinite Lengths</strong></td><td>Disallowed (for strings, arrays, maps)</td><td>Disallowed</td><td>Disallowed</td></tr>
<tr><td><strong>Allowed Simple Values</strong></td><td>All simple values (0-255) potentially allowed</td><td>All simple values potentially allowed</td><td>Restricted: Only <code>false</code>, <code>true</code>, <code>null</code>, floats allowed</td></tr>
<tr><td><strong>String Normalization</strong></td><td>Not specified</td><td>Not specified</td><td>Mandatory: Unicode NFC</td></tr>
<tr><td><strong>Duplicate Map Keys</strong></td><td>Invalid CBOR (handling not mandated)</td><td>Encoder MUST NOT emit; Decoder MUST check basic validity</td><td>Encoder MUST NOT emit; Decoder MUST reject</td></tr>
<tr><td><strong>Validity Checking by Decoders</strong></td><td>Not specified</td><td>Decoder MUST check basic validity</td><td>Decoder MUST reject any data that does not conform to dCBOR rules</td></tr>
</tbody></table>
</div>
<p>These differences highlight how dCBOR makes specific, opinionated choices about semantic equivalence that go beyond the more generic baseline of CDE. For example, the numeric reduction rule embeds the semantic decision that, within the dCBOR profile, the integer <code>2</code> and the float <code>2.0</code> should produce identical byte sequences. Similarly, mandating NFC strings embeds the decision that different Unicode representations of the same visual character should yield the same bytes. While these choices might not be suitable for all applications, they are crucial for use cases like Gordian Envelope where achieving unambiguous byte-level representation for semantically equivalent data is paramount for hash-based verification.</p>
<h2 id="27-laying-the-foundation-why-dcbor-for-gordian-envelope"><a class="header" href="#27-laying-the-foundation-why-dcbor-for-gordian-envelope">2.7 Laying the Foundation: Why dCBOR for Gordian Envelope</a></h2>
<p>The rigorous constraints imposed by the dCBOR profile are not arbitrary; they directly enable the core functionality and security goals of the Gordian Envelope system. Revisiting the requirements outlined in Section 2.3, the necessity of dCBOR becomes clear:</p>
<ul>
<li><strong>Merkle Tree Integrity:</strong> Gordian Envelope's structure relies on a Merkle-like tree where the digest (cryptographic hash) of each component contributes to the digests of its parent components, culminating in a single root hash for the entire Envelope. This structure allows for efficient verification of the Envelope's integrity. This mechanism is critically dependent on the absolute byte consistency provided by dCBOR. Any variation in the serialization of a sub-envelope – whether due to map key order, number representation choices, or string normalization differences – would result in a different hash. This differing hash would propagate up the tree, changing the root hash and invalidating any integrity proofs. dCBOR's strict rules ensure that the same logical Envelope content <em>always</em> produces the exact same byte sequence, guaranteeing stable and reproducible hashes across different systems, libraries, and time.</li>
<li><strong>Elision Reliability:</strong> The privacy-enhancing feature of elision allows a holder to redact parts of an Envelope while proving that the redacted parts were originally present. This is achieved by replacing the elided sub-envelope with its pre-computed digest. For a recipient to verify the integrity of the partially elided Envelope, they must be able to trust that the provided digests accurately represent the original, now-hidden content. This trust relies entirely on the guarantee that the hash of any given sub-envelope is unique and unchanging. dCBOR provides this guarantee. If the serialization were non-deterministic, the hash computed by the issuer might differ from a hash computed later (e.g., by the holder before elision or by the verifier on a similar structure), rendering the elision mechanism unreliable.</li>
<li><strong>Content Addressing:</strong> Envelopes, identified by their root hash, can be used in content-addressable systems. dCBOR ensures that two Envelopes containing the exact same logical information will always produce the identical root hash, enabling reliable storage, retrieval, and deduplication based on content.</li>
</ul>
<p>While CDE provides a strong baseline for determinism, its rules alone might not suffice for the specific semantic requirements of Gordian Envelope. Consider these examples:</p>
<ul>
<li><strong>Numeric Equivalence:</strong> An application using Gordian Envelope might consider the integer <code>2</code> and the floating-point number <code>2.0</code> to be semantically identical within its data model. In fact, this is common in extremely popular environments like JavaScript, which do not distinguish between integer and floating point types. CDE, however, explicitly encodes these differently, and requires that users select whether they are encoding an integer or floating point type. If both representations were allowed in an Envelope, they would produce different hashes, breaking comparisons and potentially invalidating Merkle proofs if one form were substituted for the other. dCBOR's mandatory numeric reduction rule addresses this directly by forcing <code>2.0</code> to be encoded as the integer <code>2</code>, ensuring a single, canonical byte representation for these semantically equivalent values.</li>
<li><strong>String Equivalence:</strong> Similarly, if an application treats precomposed <code>é</code> (U+00E9) and decomposed <code>e</code> + combining accent <code>´</code> (U+0065 U+0301) as identical, CDE's lack of mandatory normalization could lead to different byte sequences and different hashes for otherwise identical data. dCBOR's requirement for NFC normalization ensures that such visually identical strings produce the same canonical byte sequence, preserving hash consistency.</li>
</ul>
<p>Therefore, dCBOR is more than just a stricter version of CDE; it is the specifically tailored, rigorously deterministic foundation upon which the advanced security, privacy, and verifiability features of Gordian Envelope are constructed. The decision to use dCBOR reflects a design philosophy where the demanding requirements of the application layer directly informed the choice and definition of the underlying serialization layer, ensuring the necessary properties were available rather than compromising the application's goals.</p>
<p>Another less obvious, but no less important goal of dCBOR is to minimize the semantic burden placed on users and application developers. Determinism at the highest application level is not easy to achieve, with applications needing to define their own Application Level Deterministic Rules (ALDRs). Having to also think about low-level encoding issues is a challenge, especially when it's mostly re-inventing the wheel. By enforcing strict, unambiguous encoding rules at the serialization layer, dCBOR ensures that all data conforming to its profile is represented in a single, canonical byte form. This means that higher-level abstractions—such as application logic, cryptographic protocols, or data modeling frameworks—can operate with the assurance that the underlying data representation is always consistent and deterministic. Developers do not need to implement their own normalization, canonicalization, or equivalence checks for common sources of ambiguity like numeric types or Unicode strings. Instead, they can rely on dCBOR's guarantees, simplifying application code and reducing the risk of subtle bugs or security vulnerabilities arising from inconsistent data encoding. This separation of concerns enables robust, verifiable systems to be built atop dCBOR, confident that the foundational layer will always provide the determinism required for reliable operation.</p>
<h2 id="28-conclusion-a-path-to-verifiable-data"><a class="header" href="#28-conclusion-a-path-to-verifiable-data">2.8 Conclusion: A Path to Verifiable Data</a></h2>
<p>The journey from base CBOR's initial determinism guidelines to the rigorous specification of dCBOR illustrates a common pattern in the evolution of technical standards: as applications become more sophisticated, the need for stronger guarantees from underlying protocols increases. Base CBOR (RFC 8949), with its Preferred and Basic Serialization options, provided foundational steps towards encoding consistency, balancing flexibility with efficiency. However, for applications demanding absolute, interoperable byte-level agreement, these steps proved insufficient.</p>
<p>The IETF CBOR Working Group addressed this gap by developing the CBOR Common Deterministic Encoding (CDE) profile, establishing a standardized baseline that mandates key rules like map key sorting and canonical number representations. CDE offers a significant improvement for many use cases requiring reliable data comparison or hashing.</p>
<p>Yet, driven by the specific, demanding requirements of systems like Gordian Envelope – systems built on verifiable data structures, cryptographic hashing, and privacy-preserving techniques like elision – an even stricter level of determinism was necessary. This led to the definition of dCBOR, an application profile layered on top of CDE, which introduces additional constraints such as numeric reduction and mandatory string normalization.</p>
<p>This progression – CBOR → CDE → dCBOR – is a response to the growing need for trustworthy digital systems. The subtle issues arising from serialization non-determinism can have profound impacts on the reliability and security of applications involving digital signatures, distributed consensus, content-addressable storage, and verifiable credentials. dCBOR, by providing an unambiguous, canonical byte representation for logical data according to its specific rules, serves as a critical enabling technology. It lays the necessary foundation for building robust, secure, and interoperable systems like Gordian Envelope, paving the way for a future where digital data can be more reliably verified, shared, and controlled by its users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-dcbor"><a class="header" href="#using-dcbor">Using dCBOR</a></h1>
<p>So after all that discussion of the motivation for dCBOR, let's just recap its rules all in one place, and specifically how they differ from basic CBOR:</p>
<ul>
<li><strong>Map Keys</strong>: No duplicates. Must be serialized sorted lexicographically by the serialized key.</li>
<li><strong>Numeric Values</strong>: "Preferred Serialization" isn't just preferred, it's required.</li>
<li><strong>Numeric Reducation</strong>: Floating point values that can accurately be represented as integers must be serialized as integers.</li>
<li><strong>Indefinite Length</strong>: Indefinite length values are not allowed.</li>
<li><strong>Simple Values</strong>: Only <code>false</code>, <code>true</code>, and <code>null</code> are allowed.</li>
<li><strong>Strings</strong>: Must be encoded in Unicode Normalization Form C (NFC).</li>
<li><strong>Decoders</strong>: Must check all the rules above and reject any serialization that doesn't conform to them.</li>
</ul>
<p>Pretty simple, right?</p>
<p>It gets even simpler when you use a CBOR library that supports dCBOR, as the implemenation should take care of all the details for you. In fact, a good API will even make it <em>impossible</em> to create invalid dCBOR serializations.</p>
<p>The <a href="https://crates.io/crates/dcbor"><code>dcbor</code></a> crate is the Rust reference implementation of dCBOR from Blockchain Commons, and in this chapter we'll show you how easy it is to use.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>This will add the latest version of the <code>dcbor</code> crate to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-bash">cargo add dcbor
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p><code>dcbor</code> includes a <code>prelude</code> module that re-exports all the types and traits you need to use dCBOR:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span>// This is all you need to import to use the library.
use dcbor::prelude::*;

#[rustfmt::skip]
pub fn main() {
    // Encode the integer 42
    let i = 42;
    let cbor = i.to_cbor();

    // Check the diagnostic representation
    assert_eq!(cbor.diagnostic(), "42");

    // Check the hex representation
    assert_eq!(cbor.hex(), "1a002a");

    // Check the CBOR data
    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Many common types are directly convertable into dCBOR. Thanks to dCBOR's numeric reduction, you don't even need to specify whether common numeric types should be serialized as integers or floating point: the <code>dcbor</code> library will automatically choose the best representation for you.</p>
<p>Note that when you use <code>value.to_cbor()</code> or <code>CBOR::from(value)</code>, you're not <em>actually</em> encoding the CBOR serialization in that moment. You're actually creating an intermediate representation of the data (an instance of <code>CBOR</code>) that can be serialized later, when you call a method like <code>to_cbor_data</code>.</p>
<p>Converting back from CBOR is also easy: you simply specify the type you want to convert to, and the <code>dcbor</code> library will do the rest. You use the <code>try_from</code> method to convert from CBOR to a Rust type, which will succeed if the CBOR can be accurately converted to that type. If the conversion fails, it will return an error:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span>let a = 42;
let cbor = a.to_cbor();
let b = i32::try_from(cbor)?;
assert_eq!(a, b);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>In the following example we use <code>try_from</code> to convert from CBOR to both a <code>u8</code> type and an <code>f64</code> type. Both succeed, because the value <code>42</code> can be represented as both an 8-bit unsigned integer and a 64-bit floating point number:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span>let a = 42;
let cbor = a.to_cbor();

// Decode as a u8
let b = u8::try_from(cbor.clone())?;
assert_eq!(a as u8, b);

// Decode as an f64
let c = f64::try_from(cbor)?;
assert_eq!(a as f64, c);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<blockquote>
<p><strong>✅ NOTE:</strong> Observe the call to <code>clone()</code> above, which we need because the <code>try_from</code> method consumes the <code>CBOR</code> value, and we still need an instance for the second <code>try_from</code> call. Instances of <code>CBOR</code> are immutable, and the <code>dcbor</code> library implments structure sharing, so cloning is always cheap.</p>
</blockquote>
<p>Below we encode a floating point value with a non-zero fractional part, which succeeds in being decoded back to floating point, but fails to decode back to an integer, because precision would be lost:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span>let a = 1.23456;
let cbor = a.to_cbor();

// Decode as an f64
let b = f64::try_from(cbor.clone())?;
assert_eq!(a, b);

// Cannot decode as a i32
assert!(u8::try_from(cbor).is_err());
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>The nice thing about this idiom is it's not just for numeric types. You can use it for any type that implements the <code>TryFrom&lt;CBOR&gt;</code>, like <code>String</code>:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span>let a = "Hello, dCBOR!";
let cbor = a.to_cbor();

// Decode as an f64 fails
assert!(f64::try_from(cbor.clone()).is_err());

// Decode as a String succeeds
let b = String::try_from(cbor)?;
assert_eq!(a, b);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>It even works for vectors:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span>// Encode a vector of 8-bit unsigned integers
let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
let cbor = a.to_cbor();

// Decode as Vec of a compatible type: 32-bit signed integers
let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
assert_eq!(b, vec![1, 2, 3, 4, 5]);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="byte-strings"><a class="header" href="#byte-strings">Byte Strings</a></h2>
<p>But the last example raises an interesting question: is our <code>Vec&lt;u8&gt;</code> being serialized as a CBOR <em>array</em> or a CBOR <em>byte string</em>? Let's check:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span>// Encode a vector of 8-bit unsigned integers
let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
let cbor = a.to_cbor();

let hex = cbor.hex_annotated();
let expected_hex = r#"

85      # array(5)
    01  # unsigned(1)
    02  # unsigned(2)
    03  # unsigned(3)
    04  # unsigned(4)
    05  # unsigned(5)

"#.trim();

assert_eq!(hex, expected_hex);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>As you can see, the header byte specifies an array of five elements, followed by five CBOR data items for the integers <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>. So the <code>Vec&lt;u8&gt;</code> is being serialized as a CBOR array, not a byte string.</p>
<p>In Rust, <code>Vec&lt;u8&gt;</code> is often used to represent a string or buffer of bytes, but in CBOR, a byte string is a different type distinct from a vector or an array. The <code>CBOR</code> type provides a static method <code>CBOR::to_byte_string</code> that will convert a <code>Vec&lt;u8&gt;</code> into a CBOR byte string:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span>// Encode a vector of 8-bit unsigned integers
let a = vec![1, 2, 3, 4, 5];
let byte_string = CBOR::to_byte_string(a);
let cbor = byte_string.to_cbor();

let hex = cbor.hex_annotated();
let expected_hex = r#"

45              # bytes(5)
    0102030405

"#.trim();

assert_eq!(hex, expected_hex);

let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
assert_eq!(b, vec![1, 2, 3, 4, 5]);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Everything in the serialization in this example is the same as the last, <em>except</em> the header byte, which was <code>0x85</code> for a 5-element array, and <code>0x45</code> for a byte string of length 5.</p>
<p>Notice that recovering the byte string is also different. Since a byte string is not an array, we can't extract it as a <code>Vec&lt;u8&gt;</code>. Instead, we extract it as the type <code>ByteString</code>, and then convert <em>that</em> to a <code>Vec&lt;u8&gt;</code> using <code>.into()</code>.</p>
<p><code>ByteString</code> is just a wrapper around <code>Vec&lt;u8&gt;</code>, and it has most of the same capabilities, but the <code>dcbor</code> library treats it as a CBOR byte string, not a CBOR array.</p>
<h2 id="simple-values-false-true-and-null"><a class="header" href="#simple-values-false-true-and-null">Simple Values: <code>false</code>, <code>true</code>, and <code>null</code></a></h2>
<p>dCBOR only allows three simple values: <code>false</code>, <code>true</code>, and <code>null</code>, and the <code>dcbor</code> library provides a set of conveniences for working with them. In the example below we create a CBOR array containing <code>[true, false, null]</code>, and then test its CBOR diagnostic notation and annotated hex serialization:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span>let v: Vec&lt;CBOR&gt; = vec![
    true.into(),
    false.into(),
    CBOR::null(),
];
let cbor = v.to_cbor();

let diagnostic = cbor.diagnostic();
let expected_diagnostic = "[true, false, null]";
assert_eq!(diagnostic, expected_diagnostic);

let hex = cbor.hex_annotated();
let expected_hex = r#"

83      # array(3)
    f5  # true
    f4  # false
    f6  # null

"#.trim();

assert_eq!(hex, expected_hex);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Something interesting is going on here: our array has three values, two of which are booleans and the third is its own type: <code>null</code>. CBOR is designed to handle such <em>heterogenous arrays</em> with no problem. But Rust (unlike some languages like JavaScript) doesn't have a <code>null</code> value (preferring <code>Option&lt;T&gt;</code> for values which may not be present). Rust also doesn't natively support <code>Vec</code>s containing mixed types. So how does the <code>dcbor</code> library handle this?</p>
<p>First, note that our array is not declared as a <code>Vec&lt;bool&gt;</code> but as a <code>Vec&lt;CBOR&gt;</code>. The CBOR type can hold <em>any</em> cbor value, including complex values like nested arrays and maps. In the context of the <code>vec!</code> macro composing a <code>Vec&lt;CBOR&gt;</code>, the Rust boolean values <code>true</code> and <code>false</code> can just be converted directly using <code>.into()</code>, and that's what we're doing here.</p>
<p>Rust has no <code>null</code> value, so the <code>dcbor</code> library provides a <code>CBOR::null()</code> method that returns a <code>CBOR</code> instance representing the <code>null</code> value.</p>
<p>And since all three elements of the array are being converted directly into CBOR, there is no problem constructing the heterogenous array.</p>
<blockquote>
<p><strong>✅ NOTE:</strong> Of course, dCBOR doesn't support CBOR <code>undefined</code> or any of the other simple values, so the <code>dcbor</code> API doesn't have ways to let you construct them!</p>
</blockquote>
<h2 id="extracting-from-a-heterogenous-array"><a class="header" href="#extracting-from-a-heterogenous-array">Extracting from a Heterogenous Array</a></h2>
<p>So now that we've gotten ourselves into this situation, how do we get the values back out? The <code>dcbor</code> library provides a set of methods for testing and extracting the CBOR major types, as well as unique values like <code>true</code>, <code>false</code>, and <code>null</code>.</p>
<p>In the example below we first begin by extracting our CBOR array from the composed <code>CBOR</code> instance. We then demonstrate several methods to either extract values or test them against expected values.</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span>// Compose an array of CBOR values
let v: Vec&lt;CBOR&gt; = vec![
    true.into(),
    false.into(),
    CBOR::null(),
];
// Convert the array to a single CBOR object, which would
// be serialized to CBOR data or recovered from it.
let cbor: CBOR = v.to_cbor();

// Recover the array from the CBOR object
let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;

// Check the length of the array
assert_eq!(v2.len(), 3);

// For the first value (`true`), extract it so it could be saved for later.
let t = v2[0].clone().try_into_bool()?;
assert!(t);

// For the second value (`false`), just assert that it is false.
assert!(v2[1].is_false());

// For the third value (`null`), assert that it is null.
assert!(v2[2].is_null());

<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<p>As long as all the types contained in a Rust <code>HashMap</code> or <code>BTreeMap</code> are supported by CBOR (we'll discuss how to make your own types CBOR-compatible in a later chapter), then converting them to CBOR and back is straightforward.</p>
<p>In the example below we round-trip a Rust <code>HashMap</code> with <code>String</code> keys and <code>Vec&lt;String&gt;</code> values all the way to serialized CBOR data and back again:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span>// Create a HashMap with String keys and Vec&lt;String&gt; values
let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);

// Convert the HashMap to a CBOR object
let cbor = h.to_cbor();

// Check the representation in CBOR diagnostic notation
let diagnostic = cbor.diagnostic();
let expected_diagnostic = r#"

{
    "colors":
    ["red", "green", "blue"],
    "animals":
    ["cat", "dog", "horse"]
}

"#.trim();
assert_eq!(diagnostic, expected_diagnostic);

// Serialize the CBOR to binary data
let data: Vec&lt;u8&gt; = cbor.to_cbor_data();

// Check the hex representation of the serialized data
let hex = hex::encode(&amp;data);
let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
assert_eq!(hex, expected_hex);

// Deserialize the data back into a CBOR object
let cbor2: CBOR = CBOR::try_from_data(data)?;

// Convert the CBOR object back into a HashMap
let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;

// Check that the original and deserialized HashMaps are equal
assert_eq!(h, h2);
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic_flat();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Those familiar with JSON know that it only supports string keys, but CBOR supports any type of CBOR value as a key, and it's a common pattern to use integers as keys, which are much more compact:</p>
<pre><code class="language-rust"><span class="boring">use anyhow::Result;
</span><span class="boring">use std::{collections::HashMap, vec};
</span><span class="boring">
</span><span class="boring">// This is all you need to import to use the library.
</span><span class="boring">use dcbor::prelude::*;
</span><span class="boring">
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">pub fn main() {
</span><span class="boring">    // Encode the integer 42
</span><span class="boring">    let i = 42;
</span><span class="boring">    let cbor = i.to_cbor();
</span><span class="boring">
</span><span class="boring">    // Check the diagnostic representation
</span><span class="boring">    assert_eq!(cbor.diagnostic(), "42");
</span><span class="boring">
</span><span class="boring">    // Check the hex representation
</span><span class="boring">    assert_eq!(cbor.hex(), "1a002a");
</span><span class="boring">
</span><span class="boring">    // Check the CBOR data
</span><span class="boring">    assert_eq!(cbor.to_cbor_data(), vec![0x1a, 0x00, 0x2a]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_2() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">let b = i32::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_3() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 42;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as a u8
</span><span class="boring">let b = u8::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a as u8, b);
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let c = f64::try_from(cbor)?;
</span><span class="boring">assert_eq!(a as f64, c);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_4() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = 1.23456;
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64
</span><span class="boring">let b = f64::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">
</span><span class="boring">// Cannot decode as a i32
</span><span class="boring">assert!(u8::try_from(cbor).is_err());
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_5() -&gt; Result&lt;()&gt; {
</span><span class="boring">let a = "Hello, dCBOR!";
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as an f64 fails
</span><span class="boring">assert!(f64::try_from(cbor.clone()).is_err());
</span><span class="boring">
</span><span class="boring">// Decode as a String succeeds
</span><span class="boring">let b = String::try_from(cbor)?;
</span><span class="boring">assert_eq!(a, b);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_6() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">// Decode as Vec of a compatible type: 32-bit signed integers
</span><span class="boring">let b: Vec&lt;i32&gt; = Vec::try_from(cbor.clone())?;
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_7() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a: Vec&lt;u8&gt; = vec![1, 2, 3, 4, 5];
</span><span class="boring">let cbor = a.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">85      # array(5)
</span><span class="boring">    01  # unsigned(1)
</span><span class="boring">    02  # unsigned(2)
</span><span class="boring">    03  # unsigned(3)
</span><span class="boring">    04  # unsigned(4)
</span><span class="boring">    05  # unsigned(5)
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_8() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Encode a vector of 8-bit unsigned integers
</span><span class="boring">let a = vec![1, 2, 3, 4, 5];
</span><span class="boring">let byte_string = CBOR::to_byte_string(a);
</span><span class="boring">let cbor = byte_string.to_cbor();
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">45              # bytes(5)
</span><span class="boring">    0102030405
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">let b: Vec&lt;u8&gt; = ByteString::try_from(cbor)?.into();
</span><span class="boring">assert_eq!(b, vec![1, 2, 3, 4, 5]);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_9() -&gt; Result&lt;()&gt; {
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">let cbor = v.to_cbor();
</span><span class="boring">
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = "[true, false, null]";
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">let hex = cbor.hex_annotated();
</span><span class="boring">let expected_hex = r#"
</span><span class="boring">
</span><span class="boring">83      # array(3)
</span><span class="boring">    f5  # true
</span><span class="boring">    f4  # false
</span><span class="boring">    f6  # null
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_10() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Compose an array of CBOR values
</span><span class="boring">let v: Vec&lt;CBOR&gt; = vec![
</span><span class="boring">    true.into(),
</span><span class="boring">    false.into(),
</span><span class="boring">    CBOR::null(),
</span><span class="boring">];
</span><span class="boring">// Convert the array to a single CBOR object, which would
</span><span class="boring">// be serialized to CBOR data or recovered from it.
</span><span class="boring">let cbor: CBOR = v.to_cbor();
</span><span class="boring">
</span><span class="boring">// Recover the array from the CBOR object
</span><span class="boring">let v2: Vec&lt;CBOR&gt; = cbor.try_into_array()?;
</span><span class="boring">
</span><span class="boring">// Check the length of the array
</span><span class="boring">assert_eq!(v2.len(), 3);
</span><span class="boring">
</span><span class="boring">// For the first value (`true`), extract it so it could be saved for later.
</span><span class="boring">let t = v2[0].clone().try_into_bool()?;
</span><span class="boring">assert!(t);
</span><span class="boring">
</span><span class="boring">// For the second value (`false`), just assert that it is false.
</span><span class="boring">assert!(v2[1].is_false());
</span><span class="boring">
</span><span class="boring">// For the third value (`null`), assert that it is null.
</span><span class="boring">assert!(v2[2].is_null());
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_11() -&gt; Result&lt;()&gt; {
</span><span class="boring">// Create a HashMap with String keys and Vec&lt;String&gt; values
</span><span class="boring">let mut h: HashMap&lt;String, Vec&lt;String&gt;&gt; = HashMap::new();
</span><span class="boring">h.insert("animals".into(), vec!("cat".into(), "dog".into(), "horse".into()));
</span><span class="boring">h.insert("colors".into(), vec!["red".into(), "green".into(), "blue".into()]);
</span><span class="boring">
</span><span class="boring">// Convert the HashMap to a CBOR object
</span><span class="boring">let cbor = h.to_cbor();
</span><span class="boring">
</span><span class="boring">// Check the representation in CBOR diagnostic notation
</span><span class="boring">let diagnostic = cbor.diagnostic();
</span><span class="boring">let expected_diagnostic = r#"
</span><span class="boring">
</span><span class="boring">{
</span><span class="boring">    "colors":
</span><span class="boring">    ["red", "green", "blue"],
</span><span class="boring">    "animals":
</span><span class="boring">    ["cat", "dog", "horse"]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">"#.trim();
</span><span class="boring">assert_eq!(diagnostic, expected_diagnostic);
</span><span class="boring">
</span><span class="boring">// Serialize the CBOR to binary data
</span><span class="boring">let data: Vec&lt;u8&gt; = cbor.to_cbor_data();
</span><span class="boring">
</span><span class="boring">// Check the hex representation of the serialized data
</span><span class="boring">let hex = hex::encode(&amp;data);
</span><span class="boring">let expected_hex = "a266636f6c6f7273836372656465677265656e64626c756567616e696d616c73836363617463646f6765686f727365";
</span><span class="boring">assert_eq!(hex, expected_hex);
</span><span class="boring">
</span><span class="boring">// Deserialize the data back into a CBOR object
</span><span class="boring">let cbor2: CBOR = CBOR::try_from_data(data)?;
</span><span class="boring">
</span><span class="boring">// Convert the CBOR object back into a HashMap
</span><span class="boring">let h2: HashMap&lt;String, Vec&lt;String&gt;&gt; = cbor2.try_into()?;
</span><span class="boring">
</span><span class="boring">// Check that the original and deserialized HashMaps are equal
</span><span class="boring">assert_eq!(h, h2);
</span><span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">#[rustfmt::skip]
</span><span class="boring">fn test_12() -&gt; Result&lt;()&gt; {
</span>// Create a HashMap with String keys and Vec&lt;String&gt; values
let mut h: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
h.insert(1, vec!("cat".into(), "dog".into(), "horse".into()));
h.insert(2, vec!["red".into(), "green".into(), "blue".into()]);

// Convert the HashMap to a CBOR object
let cbor = h.to_cbor();

// Check the representation in CBOR diagnostic notation
let diagnostic = cbor.diagnostic_flat();
let expected_diagnostic = r#"

{1: ["cat", "dog", "horse"], 2: ["red", "green", "blue"]}

"#.trim();
assert_eq!(diagnostic, expected_diagnostic);

// Convert the CBOR object back into a HashMap
let h2: HashMap&lt;usize, Vec&lt;String&gt;&gt; = cbor.try_into()?;

// Check that the original and deserialized HashMaps are equal
assert_eq!(h, h2);
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Note the use of <code>diagnostic_flat()</code> in this example, which returns the diagnostic notation with no line breaks or indentation. In previous examples we also used either <code>hex()</code> or <code>hex_annotated()</code> depending on the desired formatting.</p>
<blockquote>
<p>🚧 <strong>Work in Progress:</strong> <em>More in this chapter and more chapters forthcoming!</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-gordian-envelope"><a class="header" href="#introduction-to-gordian-envelope">Introduction to Gordian Envelope</a></h1>
<blockquote>
<p>🚧 <em>forthcoming...</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="envelope-semantics-and-structure"><a class="header" href="#envelope-semantics-and-structure">Envelope Semantics and Structure</a></h1>
<blockquote>
<p>🚧 <em>forthcoming...</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="envelope-encoding-and-processing"><a class="header" href="#envelope-encoding-and-processing">Envelope Encoding and Processing</a></h1>
<blockquote>
<p>🚧 <em>forthcoming...</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="practical-applications-and-patterns"><a class="header" href="#practical-applications-and-patterns">Practical Applications and Patterns</a></h1>
<blockquote>
<p>🚧 <em>forthcoming...</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling-and-libraries"><a class="header" href="#tooling-and-libraries">Tooling and Libraries</a></h1>
<blockquote>
<p>🚧 <em>forthcoming...</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<blockquote>
<p>🚧 <em>forthcoming...</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbor-header-bytes"><a class="header" href="#cbor-header-bytes">CBOR Header Bytes</a></h1>
<p>This table shows all possible CBOR header byte values and their meanings.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: right"><code>_0</code></th><th style="text-align: right"><code>_1</code></th><th style="text-align: right"><code>_2</code></th><th style="text-align: right"><code>_3</code></th><th style="text-align: right"><code>_4</code></th><th style="text-align: right"><code>_5</code></th><th style="text-align: right"><code>_6</code></th><th style="text-align: right"><code>_7</code></th><th style="text-align: right"><code>_8</code></th><th style="text-align: right"><code>_9</code></th><th style="text-align: right"><code>_a</code></th><th style="text-align: right"><code>_b</code></th><th style="text-align: right"><code>_c</code></th><th style="text-align: right"><code>_d</code></th><th style="text-align: right"><code>_e</code></th><th style="text-align: right"><code>_f</code></th></tr></thead><tbody>
<tr><td><code>0_</code></td><td style="text-align: right"><code>0</code></td><td style="text-align: right"><code>1</code></td><td style="text-align: right"><code>2</code></td><td style="text-align: right"><code>3</code></td><td style="text-align: right"><code>4</code></td><td style="text-align: right"><code>5</code></td><td style="text-align: right"><code>6</code></td><td style="text-align: right"><code>7</code></td><td style="text-align: right"><code>8</code></td><td style="text-align: right"><code>9</code></td><td style="text-align: right"><code>10</code></td><td style="text-align: right"><code>11</code></td><td style="text-align: right"><code>12</code></td><td style="text-align: right"><code>13</code></td><td style="text-align: right"><code>14</code></td><td style="text-align: right"><code>15</code></td></tr>
<tr><td><code>1_</code></td><td style="text-align: right"><code>16</code></td><td style="text-align: right"><code>17</code></td><td style="text-align: right"><code>18</code></td><td style="text-align: right"><code>19</code></td><td style="text-align: right"><code>20</code></td><td style="text-align: right"><code>21</code></td><td style="text-align: right"><code>22</code></td><td style="text-align: right"><code>23</code></td><td style="text-align: right"><code>int 1+1</code></td><td style="text-align: right"><code>int 1+2</code></td><td style="text-align: right"><code>int 1+4</code></td><td style="text-align: right"><code>int 1+8</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr>
<tr><td><code>2_</code></td><td style="text-align: right"><code>-1</code></td><td style="text-align: right"><code>-2</code></td><td style="text-align: right"><code>-3</code></td><td style="text-align: right"><code>-4</code></td><td style="text-align: right"><code>-5</code></td><td style="text-align: right"><code>-6</code></td><td style="text-align: right"><code>-7</code></td><td style="text-align: right"><code>-8</code></td><td style="text-align: right"><code>-9</code></td><td style="text-align: right"><code>-10</code></td><td style="text-align: right"><code>-11</code></td><td style="text-align: right"><code>-12</code></td><td style="text-align: right"><code>-13</code></td><td style="text-align: right"><code>-14</code></td><td style="text-align: right"><code>-15</code></td><td style="text-align: right"><code>-16</code></td></tr>
<tr><td><code>3_</code></td><td style="text-align: right"><code>-17</code></td><td style="text-align: right"><code>-18</code></td><td style="text-align: right"><code>-19</code></td><td style="text-align: right"><code>-20</code></td><td style="text-align: right"><code>-21</code></td><td style="text-align: right"><code>-22</code></td><td style="text-align: right"><code>-23</code></td><td style="text-align: right"><code>-24</code></td><td style="text-align: right"><code>neg 1+1</code></td><td style="text-align: right"><code>neg 1+2</code></td><td style="text-align: right"><code>neg 1+4</code></td><td style="text-align: right"><code>neg 1+8</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr>
<tr><td><code>4_</code></td><td style="text-align: right"><code>bstr 0</code></td><td style="text-align: right"><code>bstr 1</code></td><td style="text-align: right"><code>bstr 2</code></td><td style="text-align: right"><code>bstr 3</code></td><td style="text-align: right"><code>bstr 4</code></td><td style="text-align: right"><code>bstr 5</code></td><td style="text-align: right"><code>bstr 6</code></td><td style="text-align: right"><code>bstr 7</code></td><td style="text-align: right"><code>bstr 8</code></td><td style="text-align: right"><code>bstr 9</code></td><td style="text-align: right"><code>bstr 10</code></td><td style="text-align: right"><code>bstr 11</code></td><td style="text-align: right"><code>bstr 12</code></td><td style="text-align: right"><code>bstr 13</code></td><td style="text-align: right"><code>bstr 14</code></td><td style="text-align: right"><code>bstr 15</code></td></tr>
<tr><td><code>5_</code></td><td style="text-align: right"><code>bstr 16</code></td><td style="text-align: right"><code>bstr 17</code></td><td style="text-align: right"><code>bstr 18</code></td><td style="text-align: right"><code>bstr 19</code></td><td style="text-align: right"><code>bstr 20</code></td><td style="text-align: right"><code>bstr 21</code></td><td style="text-align: right"><code>bstr 22</code></td><td style="text-align: right"><code>bstr 23</code></td><td style="text-align: right"><code>bstr 1+1</code></td><td style="text-align: right"><code>bstr 1+2</code></td><td style="text-align: right"><code>bstr 1+4</code></td><td style="text-align: right"><code>bstr 1+8</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><code>bstr indef</code></td></tr>
<tr><td><code>6_</code></td><td style="text-align: right"><code>str 0</code></td><td style="text-align: right"><code>str 1</code></td><td style="text-align: right"><code>str 2</code></td><td style="text-align: right"><code>str 3</code></td><td style="text-align: right"><code>str 4</code></td><td style="text-align: right"><code>str 5</code></td><td style="text-align: right"><code>str 6</code></td><td style="text-align: right"><code>str 7</code></td><td style="text-align: right"><code>str 8</code></td><td style="text-align: right"><code>str 9</code></td><td style="text-align: right"><code>str 10</code></td><td style="text-align: right"><code>str 11</code></td><td style="text-align: right"><code>str 12</code></td><td style="text-align: right"><code>str 13</code></td><td style="text-align: right"><code>str 14</code></td><td style="text-align: right"><code>str 15</code></td></tr>
<tr><td><code>7_</code></td><td style="text-align: right"><code>str 16</code></td><td style="text-align: right"><code>str 17</code></td><td style="text-align: right"><code>str 18</code></td><td style="text-align: right"><code>str 19</code></td><td style="text-align: right"><code>str 20</code></td><td style="text-align: right"><code>str 21</code></td><td style="text-align: right"><code>str 22</code></td><td style="text-align: right"><code>str 23</code></td><td style="text-align: right"><code>str 1+1</code></td><td style="text-align: right"><code>str 1+2</code></td><td style="text-align: right"><code>str 1+4</code></td><td style="text-align: right"><code>str 1+8</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><code>str indef</code></td></tr>
<tr><td><code>8_</code></td><td style="text-align: right"><code>arr 0</code></td><td style="text-align: right"><code>arr 1</code></td><td style="text-align: right"><code>arr 2</code></td><td style="text-align: right"><code>arr 3</code></td><td style="text-align: right"><code>arr 4</code></td><td style="text-align: right"><code>arr 5</code></td><td style="text-align: right"><code>arr 6</code></td><td style="text-align: right"><code>arr 7</code></td><td style="text-align: right"><code>arr 8</code></td><td style="text-align: right"><code>arr 9</code></td><td style="text-align: right"><code>arr 10</code></td><td style="text-align: right"><code>arr 11</code></td><td style="text-align: right"><code>arr 12</code></td><td style="text-align: right"><code>arr 13</code></td><td style="text-align: right"><code>arr 14</code></td><td style="text-align: right"><code>arr 15</code></td></tr>
<tr><td><code>9_</code></td><td style="text-align: right"><code>arr 16</code></td><td style="text-align: right"><code>arr 17</code></td><td style="text-align: right"><code>arr 18</code></td><td style="text-align: right"><code>arr 19</code></td><td style="text-align: right"><code>arr 20</code></td><td style="text-align: right"><code>arr 21</code></td><td style="text-align: right"><code>arr 22</code></td><td style="text-align: right"><code>arr 23</code></td><td style="text-align: right"><code>arr 1+1</code></td><td style="text-align: right"><code>arr 1+2</code></td><td style="text-align: right"><code>arr 1+4</code></td><td style="text-align: right"><code>arr 1+8</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><code>arr indef</code></td></tr>
<tr><td><code>a_</code></td><td style="text-align: right"><code>map 0</code></td><td style="text-align: right"><code>map 1</code></td><td style="text-align: right"><code>map 2</code></td><td style="text-align: right"><code>map 3</code></td><td style="text-align: right"><code>map 4</code></td><td style="text-align: right"><code>map 5</code></td><td style="text-align: right"><code>map 6</code></td><td style="text-align: right"><code>map 7</code></td><td style="text-align: right"><code>map 8</code></td><td style="text-align: right"><code>map 9</code></td><td style="text-align: right"><code>map 10</code></td><td style="text-align: right"><code>map 11</code></td><td style="text-align: right"><code>map 12</code></td><td style="text-align: right"><code>map 13</code></td><td style="text-align: right"><code>map 14</code></td><td style="text-align: right"><code>map 15</code></td></tr>
<tr><td><code>b_</code></td><td style="text-align: right"><code>map 16</code></td><td style="text-align: right"><code>map 17</code></td><td style="text-align: right"><code>map 18</code></td><td style="text-align: right"><code>map 19</code></td><td style="text-align: right"><code>map 20</code></td><td style="text-align: right"><code>map 21</code></td><td style="text-align: right"><code>map 22</code></td><td style="text-align: right"><code>map 23</code></td><td style="text-align: right"><code>map 1+1</code></td><td style="text-align: right"><code>map 1+2</code></td><td style="text-align: right"><code>map 1+4</code></td><td style="text-align: right"><code>map 1+8</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><code>map indef</code></td></tr>
<tr><td><code>c_</code></td><td style="text-align: right"><code>tag 0</code></td><td style="text-align: right"><code>tag 1</code></td><td style="text-align: right"><code>tag 2</code></td><td style="text-align: right"><code>tag 3</code></td><td style="text-align: right"><code>tag 4</code></td><td style="text-align: right"><code>tag 5</code></td><td style="text-align: right"><code>tag 6</code></td><td style="text-align: right"><code>tag 7</code></td><td style="text-align: right"><code>tag 8</code></td><td style="text-align: right"><code>tag 9</code></td><td style="text-align: right"><code>tag 10</code></td><td style="text-align: right"><code>tag 11</code></td><td style="text-align: right"><code>tag 12</code></td><td style="text-align: right"><code>tag 13</code></td><td style="text-align: right"><code>tag 14</code></td><td style="text-align: right"><code>tag 15</code></td></tr>
<tr><td><code>d_</code></td><td style="text-align: right"><code>tag 16</code></td><td style="text-align: right"><code>tag 17</code></td><td style="text-align: right"><code>tag 18</code></td><td style="text-align: right"><code>tag 19</code></td><td style="text-align: right"><code>tag 20</code></td><td style="text-align: right"><code>tag 21</code></td><td style="text-align: right"><code>tag 22</code></td><td style="text-align: right"><code>tag 23</code></td><td style="text-align: right"><code>tag 1+1</code></td><td style="text-align: right"><code>tag 1+2</code></td><td style="text-align: right"><code>tag 1+4</code></td><td style="text-align: right"><code>tag 1+8</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr>
<tr><td><code>e_</code></td><td style="text-align: right"><code>val 0</code></td><td style="text-align: right"><code>val 1</code></td><td style="text-align: right"><code>val 2</code></td><td style="text-align: right"><code>val 3</code></td><td style="text-align: right"><code>val 4</code></td><td style="text-align: right"><code>val 5</code></td><td style="text-align: right"><code>val 6</code></td><td style="text-align: right"><code>val 7</code></td><td style="text-align: right"><code>val 8</code></td><td style="text-align: right"><code>val 9</code></td><td style="text-align: right"><code>val 10</code></td><td style="text-align: right"><code>val 11</code></td><td style="text-align: right"><code>val 12</code></td><td style="text-align: right"><code>val 13</code></td><td style="text-align: right"><code>val 14</code></td><td style="text-align: right"><code>val 15</code></td></tr>
<tr><td><code>f_</code></td><td style="text-align: right"><code>val 16</code></td><td style="text-align: right"><code>val 17</code></td><td style="text-align: right"><code>val 18</code></td><td style="text-align: right"><code>val 19</code></td><td style="text-align: right"><code>false</code></td><td style="text-align: right"><code>true</code></td><td style="text-align: right"><code>null</code></td><td style="text-align: right"><code>undef</code></td><td style="text-align: right"><code>val 1+1</code></td><td style="text-align: right"><code>float 16</code></td><td style="text-align: right"><code>float 32</code></td><td style="text-align: right"><code>float 64</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"><code>break</code></td></tr>
</tbody></table>
</div>
<p><strong>Legend:</strong></p>
<ul>
<li><code>1+1</code> = 1 header byte + 1 data byte (24...255)</li>
<li><code>1+2</code> = 1 header byte + 2 data bytes (256...65535)</li>
<li><code>1+4</code> = 1 header byte + 4 data bytes</li>
<li><code>1+8</code> = 1 header byte + 8 data bytes</li>
<li><code>int</code> = non-negative integer</li>
<li><code>neg</code> = negative integer</li>
<li><code>bstr</code> = byte string + length</li>
<li><code>str</code> = UTF-8 text string + length</li>
<li><code>arr</code> = array + length</li>
<li><code>map</code> = map + length</li>
<li><code>tag</code> = semantic tag + value</li>
<li><code>val</code> = simple value</li>
<li><code>false</code> = simple value 20</li>
<li><code>true</code> = simple value 21</li>
<li><code>null</code> = simple value 22</li>
<li><code>undef</code> = simple value 23</li>
<li><code>float 16/32/64</code> = half/single/double precision float</li>
<li><code>indef</code> = indefinite length</li>
<li><code>break</code> = stop code for indefinite items</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
