<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sequences: Streaming Independent Data Items - The CBOR, dCBOR, and Gordian Envelope Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The CBOR, dCBOR, and Gordian Envelope Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cbor-sequences-streaming-independent-data-items"><a class="header" href="#cbor-sequences-streaming-independent-data-items">CBOR Sequences: Streaming Independent Data Items</a></h1>
<h2 id="introduction-beyond-single-items"><a class="header" href="#introduction-beyond-single-items">Introduction: Beyond Single Items</a></h2>
<p>Previous chapters have explored the encoding of individual Concise Binary Object Representation (CBOR) data items, covering fundamental types like integers, strings, booleans, and null, as well as structured types like arrays and maps. We examined how definite-length and indefinite-length encodings work, and how semantic tags (Major Type 6) extend the basic data model. The focus thus far has been on representing self-contained, individual data structures, analogous to a single JSON document or a distinct object in memory.</p>
<p>However, many real-world applications involve data that doesn't naturally fit into a single, monolithic structure. Consider scenarios like generating log entries over time, receiving a continuous stream of sensor measurements, or exchanging a series of independent commands and responses between systems. While it's possible to wrap such sequences within a top-level CBOR array (Major Type 4), perhaps even an indefinite-length one, this approach can be inefficient or semantically awkward. It forces a collection structure onto items that might be fundamentally independent, and it requires either knowing the total count upfront (for definite-length arrays) or managing start and end markers (for indefinite-length arrays).</p>
<p>To address these scenarios more directly and efficiently, the IETF defined <strong>CBOR Sequences</strong> in (<a href="https://datatracker.ietf.org/doc/html/rfc8742">RFC-8742</a>). A CBOR Sequence provides a way to represent a stream or series of distinct CBOR data items without enclosing them in an overarching container like an array.</p>
<p>Formally, a CBOR Sequence is defined recursively as a sequence of bytes that is either:</p>
<ol>
<li>An empty (zero-length) sequence of bytes.</li>
<li>The sequence of bytes representing a single, well-formed encoded CBOR data item (as defined in (<a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a>)), immediately followed by another CBOR Sequence.</li>
</ol>
<p>In essence, a CBOR Sequence is generated by simply <strong>concatenating</strong> the binary encodings of zero or more individual CBOR data items. This concatenation is the core mechanism. Crucially, there are <strong>no explicit delimiters, framing bytes, or termination markers</strong> inserted between the constituent CBOR items within the sequence itself. This minimalist design is possible because standard CBOR data items are inherently self-delimiting; the initial byte(s) of any CBOR item contain information about its type and length (or value), allowing a parser to determine exactly where that item ends and the next one begins. This contrasts sharply with formats like JSON Text Sequences ((<a href="https://datatracker.ietf.org/doc/html/rfc7464">RFC-7464</a>)), which require explicit markers (like the ASCII Record Separator character followed by a newline) between JSON texts because JSON values themselves are not always self-delimiting when concatenated.</p>
<p>The official media type associated with this format is <code>application/cbor-seq</code>. Additionally, the structured syntax suffix <code>+cbor-seq</code> has been registered, allowing other media types to indicate that their underlying structure is a CBOR Sequence, analogous to how <code>+cbor</code> signifies a base of a single CBOR item.</p>
<p>This definition highlights the fundamental simplicity of CBOR Sequences – mere concatenation. The absence of sequence-level headers, item counts, or termination markers is a deliberate design choice rooted in CBOR's self-describing nature. Since each CBOR item encodes its own type and length, a parser can theoretically determine item boundaries without extra framing. Adding such framing would introduce overhead, running counter to CBOR's goal of conciseness, particularly for applications streaming many small items. However, this simplicity places the responsibility of determining the overall <em>end</em> of the sequence entirely on mechanisms external to the sequence format itself, such as the end of a file or the closure of a network connection. This characteristic has significant implications for how sequences are transported and how errors are handled, which will be explored later in this chapter.</p>
<h2 id="why-cbor-sequences-technical-motivations"><a class="header" href="#why-cbor-sequences-technical-motivations">Why CBOR Sequences? Technical Motivations</a></h2>
<p>The design of CBOR Sequences stems from specific technical requirements where traditional single-item encodings or array structures fall short. The primary motivations include enabling efficient streaming, facilitating incremental processing, offering potential efficiency gains over arrays, and leveraging the simplicity of concatenation.</p>
<ul>
<li>
<p><strong>Streaming Data:</strong> CBOR Sequences are particularly well-suited for scenarios where data is generated or consumed continuously over time, and the total volume or number of items is not known when the process begins. Common examples include streaming application logs, transmitting time-series sensor data from IoT devices, or handling real-time event feeds. In such cases, appending a new, independently encoded CBOR item to the end of an existing sequence is straightforward. This contrasts with definite-length CBOR arrays, which require the element count to be specified upfront, and indefinite-length arrays, which, while streamable, still represent a single logical collection that must eventually be terminated by a specific 'break' byte (<code>0xFF</code>). Sequences allow indefinite extension without modifying previously transmitted data.</p>
</li>
<li>
<p><strong>Incremental Processing:</strong> A key advantage is that sequences allow both producers and consumers to operate on discrete items one at a time. A producer can fully encode and transmit a single CBOR item. A consumer can receive the bytes for that item, decode it completely, and process it before the next item even begins to arrive. This model avoids the need for complex streaming parsers or encoders that must handle partially received or generated structures (like elements within a large array). This simplification is especially valuable for resource-constrained environments, such as IoT devices, where memory limitations might make buffering large, monolithic arrays impractical.</p>
</li>
<li>
<p><strong>Efficiency Compared to Arrays:</strong> When representing a list or sequence of items, CBOR arrays (Major Type 4) introduce a small amount of overhead. A definite-length array requires an initial byte (or potentially more for very large counts) to encode the number of elements it contains. An indefinite-length array requires an initial byte indicating the indefinite type (<code>0x9F</code> for arrays, <code>0xBF</code> for maps) and must be terminated by a final <code>0xFF</code> break byte. For a sequence containing <em>N</em> items, using a CBOR array introduces 1 to 9 bytes of structural overhead (for the count or start/end markers). In contrast, a CBOR Sequence adds <em>zero</em> bytes of overhead beyond the concatenated bytes of the items themselves. While this overhead is often negligible, it can become significant when dealing with a very large number of very small items, a common pattern in sensor data or event streams.</p>
</li>
<li>
<p><strong>Simplicity of Concatenation:</strong> The definition itself highlights this: generating a CBOR Sequence is achieved simply by concatenating the byte representations of individually encoded CBOR items. Furthermore, concatenating two valid CBOR Sequences always results in another valid CBOR Sequence. This property can simplify certain data aggregation pipelines or forwarding proxies where streams of CBOR items from different sources need to be merged.</p>
</li>
</ul>
<p>These motivations reveal a fundamental design choice: CBOR Sequences prioritize the representation of a <em>flow</em> of independent items over a <em>structured collection</em>. CBOR arrays and maps (Major Types 4 and 5) represent semantically coherent, single data items within the CBOR data model; they possess a defined structure and element/pair count. Sequences, lacking this inherent enclosing structure, are better suited for streams where items might be processed individually and may not form a single logical entity. The decision between using an array or a sequence often hinges on whether the data is conceptually viewed as "one large object containing parts" or "many small, sequential objects". If the application requires an explicit marker for the end of the sequence within the data stream itself, (<a href="https://datatracker.ietf.org/doc/html/rfc8742">RFC-8742</a>) suggests that encoding the items within a CBOR array might be the more appropriate representation. Choosing sequences implies a shift away from processing a single, potentially large, structure towards processing a series of smaller, independent units.</p>
<h2 id="encoding-simple-concatenation"><a class="header" href="#encoding-simple-concatenation">Encoding: Simple Concatenation</a></h2>
<p>The mechanism for encoding a CBOR Sequence is remarkably straightforward: individually encode each constituent data item according to the standard CBOR encoding rules defined in (<a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a>) (and detailed in a preceding chapter), and then simply concatenate the resulting byte strings in the desired order. No additional bytes, delimiters, or framing information are introduced between the encoded items as part of the sequence format itself.</p>
<p>Let's illustrate this with hexadecimal examples:</p>
<ul>
<li>
<p>Example 1: Simple Sequence</p>
<p>Consider encoding the sequence of values: 1, then "foo", then true.</p>
<ol>
<li>The integer <code>1</code> (Unsigned Integer, Major Type 0, Additional Information 1) encodes as a single byte: <code>01</code>.</li>
<li>The text string <code>"foo"</code> (Text String, Major Type 3, Additional Information 3 indicates length 3) encodes as the header byte <code>63</code> followed by the 3 UTF-8 bytes for "foo" (<code>66 6f 6f</code>): <code>63 666f6f</code>.</li>
<li>The boolean <code>true</code> (Simple Value, Major Type 7, Additional Information 21) encodes as a single byte: <code>f5</code>. The resulting CBOR Sequence is the direct concatenation: <code>01 63 666f6f f5</code>.</li>
</ol>
</li>
<li>
<p>Example 2: Sequence Containing Structured Items</p>
<p>Consider encoding the sequence: <code>[10, false]</code>, then <code>{"a": -1}</code>.</p>
<ol>
<li>The array <code>[10, false]</code> (Array, Major Type 4, Additional Information 2 indicates 2 elements) encodes as: <code>82</code> (header) followed by <code>0a</code> (encoding for 10) and <code>f4</code> (encoding for false): <code>82 0a f4</code>.</li>
<li>The map <code>{"a": -1}</code> (Map, Major Type 5, Additional Information 1 indicates 1 pair) encodes as: <code>a1</code> (header) followed by <code>61 61</code> (encoding for key "a") and <code>20</code> (encoding for value -1): <code>a1 61 61 20</code>. The resulting CBOR Sequence is the concatenation: <code>82 0a f4 a1 61 61 20</code>.</li>
</ol>
</li>
<li>
<p>Example 3: Empty Sequence</p>
<p>An empty CBOR Sequence, containing zero items, is represented by an empty (zero-length) sequence of bytes.</p>
</li>
</ul>
<p>It is instructive to contrast the CBOR Sequence encoding with CBOR array encodings for the same logical list of items. Taking the data from Example 1 (<code>1</code>, <code>"foo"</code>, <code>true</code>):</p>
<ul>
<li><strong>As a Definite-Length Array <code>[1, "foo", true]</code>:</strong> Encoded as <code>83 01 63 666f6f f5</code>. The initial byte <code>83</code> signifies Major Type 4 (Array) with Additional Information 3 (three elements follow).</li>
<li><strong>As an Indefinite-Length Array <code>[1, "foo", true]</code>:</strong> Encoded as <code>9f 01 63 666f6f f5 ff</code>. This starts with <code>9f</code> (Major Type 4, AI 31 - indefinite-length array), includes the encoded elements, and ends with the <code>ff</code> (Major Type 7, AI 31 - break code) marker.</li>
</ul>
<p>The following table summarizes these differences visually, including a comparison to JSON:</p>
<div class="table-wrapper"><table><thead><tr><th>Data Model</th><th>Representation</th><th>Hexadecimal Encoding</th><th>Overhead Bytes</th><th>Framing Mechanism</th></tr></thead><tbody>
<tr><td><code>[1, "foo", true]</code></td><td>JSON</td><td><code>[31, 2c, 22 66 6f 6f 22, 2c, 74 72 75 65]</code> (ASCII)</td><td>Variable</td><td>Text delimiters (<code>[</code>, <code>,</code>, <code>]</code>)</td></tr>
<tr><td><code>[1, "foo", true]</code></td><td>CBOR Definite Array</td><td><code>83 01 63 666f6f f5</code></td><td>1 (<code>83</code>)</td><td>Initial byte (Type 4 + Count 3)</td></tr>
<tr><td><code>[1, "foo", true]</code></td><td>CBOR Indefinite Array</td><td><code>9f 01 63 666f6f f5 ff</code></td><td>2 (<code>9f</code>, <code>ff</code>)</td><td>Start marker (<code>9f</code>) + Break (<code>ff</code>)</td></tr>
<tr><td><code>1, "foo", true</code></td><td>CBOR Sequence</td><td><code>01 63 666f6f f5</code></td><td>0</td><td>None (Self-delimiting items)</td></tr>
</tbody></table>
</div>
<p>This comparison clearly shows that CBOR Sequences eliminate the structural overhead associated with arrays by relying entirely on the self-delimiting nature of the constituent CBOR items. This byte-level difference underscores the efficiency motivation, especially for streams of numerous small items.</p>
<h2 id="decoding-reading-item-by-item"><a class="header" href="#decoding-reading-item-by-item">Decoding: Reading Item by Item</a></h2>
<p>Decoding a CBOR Sequence involves processing the input byte stream iteratively or recursively, extracting one complete CBOR data item at a time until the stream is exhausted. The fundamental process is:</p>
<ol>
<li><strong>Check for End:</strong> Determine if the input stream or remaining buffer is empty. If it is, the sequence decoding is complete.</li>
<li><strong>Decode Item:</strong> Attempt to decode a single, complete CBOR data item starting from the current position in the stream/buffer. This requires the decoder to correctly interpret the initial byte(s) to understand the item's major type, additional information, and any subsequent length or value bytes, thereby determining the total number of bytes constituting this single item.</li>
<li><strong>Yield and Consume:</strong> If decoding the item is successful, yield or otherwise process the resulting data model value. Advance the position in the stream/buffer by the number of bytes consumed by the decoded item.</li>
<li><strong>Repeat:</strong> Go back to Step 1 with the remainder of the stream/buffer.</li>
</ol>
<p>The self-delimiting property of standard CBOR items is the cornerstone of this process; the decoder must be able to precisely identify the boundaries of each item based solely on the CBOR encoding rules.</p>
<p><strong>Handling Stream Boundaries and Errors:</strong></p>
<ul>
<li><strong>Normal Termination:</strong> Successful decoding concludes when the input stream is fully consumed exactly after a complete CBOR item has been decoded.</li>
<li><strong>Truncation:</strong> If the input stream ends unexpectedly <em>while</em> decoding an item (i.e., the header indicates more bytes are needed than are available), this signifies truncation. A decoder designed for streaming data might pause at this point, waiting for more bytes to arrive before declaring an error. For file-based decoding, this typically indicates an incomplete file.</li>
<li><strong>Malformed Item:</strong> If the bytes encountered do not form a well-formed CBOR data item (e.g., invalid major type/additional information combination, inconsistent length information), the decoder loses its ability to determine where the erroneous item ends. Because there are no explicit delimiters between items in a sequence, the decoder cannot reliably find the beginning of the <em>next</em> potential item. Consequently, a single malformed item usually prevents the decoding of the remainder of the sequence. While sophisticated error recovery might be attempted in some implementations, it is not guaranteed by the specification.</li>
<li><strong>Missing Items:</strong> The CBOR Sequence format itself provides no way to detect if expected items are simply absent from the <em>end</em> of the sequence. If the stream terminates cleanly after the last item that was actually present, the decoder will report success. Detecting missing items requires application-level logic, such as checking expected counts, using timeouts in network protocols, or implementing specific acknowledgement mechanisms.</li>
</ul>
<p>The fragility in the face of malformed items is a direct consequence of the design choice to omit explicit delimiters for the sake of conciseness. Unlike newline-delimited formats like NDJSON, where a parser can often resynchronize by searching for the next newline character even after encountering invalid JSON, a CBOR Sequence parser relies entirely on the internal integrity of each item to navigate the byte stream. If an item's structure is compromised, the parser effectively becomes lost. This implies that applications relying on CBOR Sequences should prioritize robust data validation <em>before</em> or <em>during</em> sequence generation, or they must be prepared for the possibility that transmission errors affecting a single item could render a large portion of a sequence unusable. For applications demanding higher resilience against such errors, incorporating additional framing or error-checking mechanisms at a higher protocol layer might be necessary.</p>
<h2 id="cbor-sequences-in-diagnostic-notation"><a class="header" href="#cbor-sequences-in-diagnostic-notation">CBOR Sequences in Diagnostic Notation</a></h2>
<p>The current draft for <a href="https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-16.html">CBOR Extended Diagnostic Notation</a> (EDN) proposes a way to represent CBOR Sequences in a human-readable format using <code>&lt;&lt;</code> and <code>&gt;&gt;</code> as delimiters, with the items separated by commas:</p>
<pre><code>&lt;&lt; item1, item2, item3, ... &gt;&gt;
</code></pre>
<p>The sequence from the example given above would be represented as:</p>
<pre><code>&lt;&lt; 1, "foo", true &gt;&gt;
</code></pre>
<p>If you enter this into the <a href="https://cbor.me">CBOR Playground</a> and convert it to the serialized hexadecimal representation, you'll see that it converts the sequence to a CBOR byte string:</p>
<pre><code>46              # bytes(6)
   0163666F6FF5
</code></pre>
<p>If we manually parse this out, we can see that the first byte <code>0x46</code> indicates a byte string of length 6, followed by the bytes for the integer <code>1</code>, the string <code>"foo"</code>, and the boolean <code>true</code> with no other delimiters or framing:</p>
<pre><code>46              # bytes(6)
   01           # unsigned(1)
   63666F6F     # "foo"
   F5           # true
</code></pre>
<p>The fact that the byte string header <code>0x46</code> is included might be confusing, as it implies that the sequence is a single item.</p>
<p>When we convert the serialized sequence back into diagnostic notation, we just get the byte string representation, as we would expect:</p>
<pre><code>h'0163666F6FF5'
</code></pre>
<p>CBOR arrays begin with a header that specifies the array's fixed length, and indefinite-length arrays begin with the <em>indefinite array</em> item and end with the <em>break</em> item. But sequences do not themselves have delimiters or other framing.</p>
<p>The EDN notation is just a way to represent the sequence in a human-readable format, but it does not change the underlying encoding of the sequence itself. Sequences serialized this way are therefor not self-identifying. A CBOR decoder could be instructed to decode a byte string as a sequence, but the fact that it <em>is</em> a sequence cannot be determined by inspecting the byte string itself.</p>
<h2 id="practical-use-cases"><a class="header" href="#practical-use-cases">Practical Use Cases</a></h2>
<p>The characteristics of CBOR Sequences make them suitable for a variety of applications, particularly those involving streams or sequences of independent data units.</p>
<ul>
<li>
<p><strong>Streaming Applications:</strong> This is a primary motivator for CBOR Sequences.</p>
<ul>
<li><strong>Logs, Metrics, and Events:</strong> Systems generating continuous streams of structured log entries, performance metrics, or discrete events can encode each entry/event as an individual CBOR item and concatenate them into a sequence for transmission or storage. The low overhead is advantageous, and the independence of items aligns well with the nature of logs or events.</li>
<li><strong>Sensor Data Feeds:</strong> IoT devices often transmit time-series data from sensors. Using CBOR Sequences allows sending each reading or batch of readings as a separate item, benefiting from CBOR's general compactness and avoiding the per-sequence overhead of arrays, which can be significant for frequent, small readings.</li>
</ul>
</li>
<li>
<p><strong>Record Sequences (Binary NDJSON Equivalent):</strong> CBOR Sequences provide a binary alternative to text-based formats like Newline Delimited JSON (<a href="https://github.com/ndjson/ndjson-spec">NDJSON</a>) or JSON Lines (<a href="https://jsonlines.org/">JSONL</a>). They can be used for efficiently transferring large datasets as a sequence of records, such as rows from a database query or batches of results from an API, allowing for incremental processing on the receiving end. The key advantage over NDJSON is the potential for smaller size and faster parsing due to the binary encoding and native support for binary data types without base64 encoding.</p>
</li>
<li>
<p><strong>Message Delimitation in Protocols:</strong> In network protocols built on persistent connections (like TCP or WebSockets), where multiple distinct messages need to be exchanged, each message can be encoded as a single CBOR data item. A CBOR Sequence can represent the stream of these messages. For example, a sequence of Remote Procedure Call (RPC) requests or responses, or a stream of server-sent events, could be structured this way. However, a critical caveat applies: the CBOR Sequence format <em>itself</em> does not provide message framing over stream transports like raw TCP. The protocol implementation must rely on the transport layer (e.g., WebSocket message boundaries) or add its own framing mechanism (like length prefixing) to allow the receiver to distinguish individual messages within the stream.</p>
</li>
<li>
<p><strong>Sequential File Formats:</strong> Large datasets can be stored in files as a CBOR Sequence, allowing applications to read or write the file incrementally, processing one CBOR item at a time without loading the entire file into memory. This approach might be combined with proposed mechanisms for adding CBOR magic numbers or tags at the beginning of the file or sequence for identification purposes.</p>
</li>
</ul>
<p>Observing these use cases reveals a common underlying pattern: they often rely on an <em>external</em> mechanism to determine the boundaries of the sequence or the items within it, especially in streaming contexts. CBOR Sequence defines the <em>content</em> format (concatenated self-delimiting items) but not the <em>framing</em> for transport or storage. Streaming logs over TCP relies on the connection lifecycle or application-level protocols; WebSocket usage relies on WebSocket framing; file storage relies on the end-of-file marker. Therefore, while CBOR Sequences offer an efficient encoding for sequential data, engineers must consciously address how these sequences (or the individual items within them) are delimited and detected within the specific transport or storage context being used. Relying solely on the CBOR Sequence format definition without considering this framing aspect can lead to implementation pitfalls.</p>
<h2 id="comparison-with-alternatives"><a class="header" href="#comparison-with-alternatives">Comparison with Alternatives</a></h2>
<p>Choosing the right data representation format involves understanding the trade-offs. CBOR Sequences should be compared against other relevant CBOR structures (arrays) and common streaming formats (like NDJSON).</p>
<ul>
<li>
<p><strong>CBOR Sequences vs. CBOR Arrays (Definite and Indefinite):</strong></p>
<ul>
<li><strong>Structure:</strong> A fundamental difference lies in the data model. A CBOR Sequence represents multiple, independent top-level data items concatenated together. A CBOR Array (Major Type 4) is always a <em>single</em> top-level data item, whose content is an ordered list of elements.1</li>
<li><strong>Framing:</strong> Sequences have no internal framing; boundaries are implicit based on item self-delimitation. Definite-length arrays encode the element count in their header. Indefinite-length arrays use a specific start byte (<code>0x9F</code>) and require a terminating <code>0xFF</code> break byte.1</li>
<li><strong>Overhead:</strong> Sequences introduce zero framing overhead. Definite arrays add 1-9 bytes for the count. Indefinite arrays add exactly 2 bytes (<code>0x9F</code> + <code>0xFF</code>).</li>
<li><strong>Processing Model:</strong> Sequences naturally lend themselves to item-by-item streaming and processing. While indefinite-length arrays also allow streaming of their <em>elements</em>, they are still conceptually processed as a single array unit that is only complete upon encountering the <code>0xFF</code> marker. Definite-length arrays typically imply processing as a whole unit once all elements are received.</li>
<li><strong>Use Case Alignment:</strong> Sequences are ideal for streams of independent items, especially when the total count is unknown or potentially unbounded, and minimizing overhead is paramount. Arrays are better suited when the data represents a single, semantically coherent list, the structure of the collection itself is significant, and an explicit end marker (for indefinite) or count (for definite) is desirable within the CBOR structure itself.</li>
<li><strong>Error Handling:</strong> As discussed, a malformed item in a sequence can prevent decoding the rest of the stream. Errors within an array element might be more contained, although recovery, especially in indefinite arrays, can still be challenging.</li>
</ul>
</li>
<li>
<p><strong>CBOR Sequences vs. NDJSON / JSON Lines:</strong></p>
<ul>
<li><strong>Encoding:</strong> Sequences use CBOR's binary encoding, which is typically more compact and faster to parse than NDJSON's text-based JSON encoding for each line.</li>
<li><strong>Delimitation:</strong> Sequences rely on the self-delimiting nature of CBOR items. NDJSON uses an explicit newline character (<code>\n</code>) after each JSON text, making it line-oriented.</li>
<li><strong>Efficiency:</strong> CBOR Sequences generally offer better performance in terms of size and processing speed due to their binary nature.</li>
<li><strong>Error Handling:</strong> The explicit newline delimiter in NDJSON often makes it easier for parsers to skip over a malformed JSON line and attempt to process the next one. CBOR Sequences lack this explicit delimiter, making recovery from malformed items harder.</li>
<li><strong>Binary Data:</strong> CBOR has native support for byte strings (Major Type 2), allowing efficient embedding of binary data. NDJSON requires binary data to be encoded within JSON strings, typically using Base64, which adds significant size overhead (around 33%) and processing complexity.</li>
<li><strong>Human Readability:</strong> NDJSON, being text-based, is human-readable with standard text tools. CBOR Sequences require specialized tools for inspection.</li>
</ul>
</li>
</ul>
<p>The following table summarizes the key characteristics of these alternatives:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>CBOR Sequence</th><th>CBOR Indefinite Array</th><th>NDJSON / JSON Lines</th></tr></thead><tbody>
<tr><td><strong>Encoding</strong></td><td>Binary</td><td>Binary</td><td>Text (JSON per line)</td></tr>
<tr><td><strong>Structure</strong></td><td>Concatenated items (multi-root)</td><td>Single array item (single root)</td><td>Concatenated lines (multi-root)</td></tr>
<tr><td><strong>Item Delimitation</strong></td><td>Implicit (self-delimiting)</td><td>Explicit (<code>0xFF</code> break marker)</td><td>Explicit (newline <code>\n</code>)</td></tr>
<tr><td><strong>Overhead</strong></td><td>None (beyond items)</td><td>2 bytes (<code>0x9F</code>/<code>0xBF</code> + <code>0xFF</code>)</td><td>1 byte per item (<code>\n</code>)</td></tr>
<tr><td><strong>Processing</strong></td><td>Item-by-item (native streaming)</td><td>Element-by-element streaming</td><td>Line-by-line (native streaming)</td></tr>
<tr><td><strong>Readability</strong></td><td>Low (requires tools)</td><td>Low (requires tools)</td><td>High (text editor-friendly)</td></tr>
<tr><td><strong>Binary Data</strong></td><td>Native (byte strings)</td><td>Native (byte strings)</td><td>Requires Base64 encoding</td></tr>
<tr><td><strong>Error Recovery</strong></td><td>Difficult (malformed item breaks stream)</td><td>Difficult (malformed element)</td><td>Easier (can skip bad lines)</td></tr>
<tr><td><strong>Standard</strong></td><td>RFC 8742</td><td>RFC 8949</td><td>Informal spec (ndjson.org)</td></tr>
</tbody></table>
</div>
<p>This comparison highlights that CBOR Sequences offer a high-performance, low-overhead binary format for streaming independent items, trading off some error recovery robustness and human readability compared to text-based alternatives like NDJSON, and differing structurally from CBOR arrays.</p>
<h2 id="practical-advice-for-engineers"><a class="header" href="#practical-advice-for-engineers">Practical Advice for Engineers</a></h2>
<p>When considering or implementing CBOR Sequences, several practical aspects require attention to ensure correct and robust behavior.</p>
<ul>
<li>
<p><strong>Guidance: When to Choose Sequences Over Arrays:</strong></p>
<ul>
<li><strong>Favor Sequences when:</strong>
<ul>
<li>The data naturally represents a stream of independent records, events, or messages.</li>
<li>The total number of items is unknown upfront or potentially unbounded.</li>
<li>Minimizing encoding overhead is a primary concern (e.g., for high-frequency, small items).</li>
<li>Incremental, item-by-item processing is the desired model for both producer and consumer.</li>
<li>The simplicity of direct concatenation aligns with the application logic (e.g., merging streams).</li>
</ul>
</li>
<li><strong>Favor Arrays (Definite or Indefinite) when:</strong>
<ul>
<li>The data represents a single, semantically coherent collection or list.</li>
<li>The overall structure of the collection itself is meaningful.</li>
<li>The total count of items is known (definite) or will eventually be known (indefinite).</li>
<li>An explicit end marker within the CBOR data stream itself is required (indefinite arrays provide <code>0xFF</code>).</li>
<li>Compatibility with systems expecting a single top-level CBOR item is necessary.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Transport Layer Considerations (Framing):</strong></p>
<ul>
<li>A critical point often overlooked is that <strong>CBOR Sequence format does not inherently solve message framing over stream-based transports like TCP</strong>. TCP provides a reliable byte stream, but it does not preserve message boundaries. Sending a raw CBOR Sequence (concatenated items) over TCP means the receiver might receive partial items, multiple items, or parts of multiple items in a single <code>read()</code> call. The receiver cannot reliably identify item boundaries just by looking at TCP packet arrivals.</li>
<li>To handle this, a framing mechanism must be implemented <em>above</em> TCP but <em>below</em> or <em>as part of</em> the application logic utilizing CBOR Sequences:
<ul>
<li><strong>Length Prefixing:</strong> Before sending each CBOR item, transmit its length as a fixed-size integer (e.g., 4 bytes network order) or a variable-length integer (like Protobuf varints). The receiver first reads the length, then reads exactly that many bytes to get the complete CBOR item. This is a common pattern but reintroduces framing overhead.</li>
<li><strong>Delimiter-Based Framing:</strong> Use a specific byte sequence (chosen carefully to avoid collision with valid CBOR data) to mark the end of one CBOR item and the start of the next. This is generally less robust and less common than length prefixing.</li>
<li><strong>Higher-Level Protocols:</strong> Utilize protocols that provide built-in message framing. WebSockets, for instance, delivers data in discrete messages; each WebSocket message could contain exactly one CBOR item from the sequence.15 HTTP/2 streams or QUIC streams also offer framing capabilities.</li>
<li><strong>Self-Contained Items:</strong> If each item in the sequence is itself a complex structure like a COSE object 11, it might be possible (though potentially complex) to parse partially received data to determine if a complete object has arrived. This relies heavily on the internal structure of each item.</li>
<li><strong>Connection Lifecycle:</strong> For simple request-response or single-shot transfers, closing the TCP connection can signal the end of the sequence or item. This is inefficient for continuous streams.</li>
</ul>
</li>
<li>The essential takeaway is that the application or protocol designer must explicitly choose and implement a framing strategy when using CBOR Sequences over raw stream transports.</li>
</ul>
</li>
<li>
<p><strong>Implementation Notes &amp; Common Patterns:</strong></p>
<ul>
<li><strong>Library Support:</strong> Check if the CBOR library being used offers specific support for sequences. For example, the Go <code>fxamacker/cbor</code> library provides <code>UnmarshalFirst</code> and <code>DiagnoseFirst</code> functions that decode only the first item from a byte slice and return the remaining bytes, facilitating iterative processing of a sequence. Standard <code>Unmarshal</code> functions in many libraries might error if trailing bytes exist after the first item, as per <a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a> for single items.</li>
<li><strong>Buffering:</strong> When reading from a network stream or file, employ appropriate buffering. Read data chunks into a buffer, attempt to decode one or more complete CBOR items from the buffer, consume the bytes corresponding to successfully decoded items, and handle cases where an item might be split across buffer boundaries (requiring more data to be read).</li>
<li><strong>Generators/Iterators:</strong> In programming languages offering generator functions or iterators (like Python, JavaScript, C#), these constructs provide an idiomatic way to implement a CBOR Sequence decoder. The decoder function can yield each successfully decoded item one at a time, naturally supporting the incremental processing model.</li>
</ul>
</li>
<li>
<p><strong>Potential Pitfalls:</strong></p>
<ul>
<li><strong>Framing Neglect:</strong> The most common pitfall is assuming CBOR Sequences provide message framing over TCP or similar streams. Always implement explicit framing.</li>
<li><strong>Error Handling Brittleness:</strong> Underestimating the consequence that a single malformed item can halt the processing of the rest of the sequence. Implement input validation or accept the potential for data loss on errors.</li>
<li><strong>Security Gaps:</strong> Remember that CBOR Sequences themselves offer no cryptographic protection. If integrity, authenticity, or confidentiality are required, each item (or potentially batches of items) must be individually protected using mechanisms like COSE. Securing the sequential relationship (preventing reordering, deletion, or insertion) often requires additional application-level mechanisms like sequence numbers or chained signatures.</li>
<li><strong>Resource Exhaustion:</strong> While sequences facilitate streaming, a naive decoder implementation that buffers all decoded items in memory before processing can still lead to memory exhaustion. Ensure that processing keeps pace with decoding in a truly incremental fashion.</li>
<li><strong>Ambiguity/Compatibility:</strong> Ensure both communicating parties understand that a CBOR Sequence is being used. Employing the <code>application/cbor-seq</code> media type or the <code>+cbor-seq</code> structured syntax suffix in protocols that support content types (like HTTP, CoAP) can help avoid ambiguity.</li>
</ul>
</li>
</ul>
<p>Understanding these points requires recognizing the layered nature of communication protocols. CBOR Sequence (RFC 8742) operates at the data representation layer, defining how to encode the <em>content</em> of a stream. Framing mechanisms (length prefixing, WebSocket messages) operate at the transport or session layer to define message <em>boundaries</em>. Security mechanisms like COSE operate at the application layer to protect the <em>content</em>. File system metadata or magic numbers provide context at the storage layer. Engineers must address requirements at each relevant layer; expecting the CBOR Sequence format alone to solve framing or security problems will lead to incomplete or flawed implementations.</p>
<h2 id="conclusion-sequences-in-the-cbor-ecosystem"><a class="header" href="#conclusion-sequences-in-the-cbor-ecosystem">Conclusion: Sequences in the CBOR Ecosystem</a></h2>
<p>CBOR Sequences should be viewed as a specific tool within the broader CBOR toolkit, complementing definite-length items, indefinite-length items (including arrays and maps), and semantic tags. They are the appropriate choice when the primary goal is to stream or serialize a sequence of independent CBOR items with minimal overhead, particularly when the total count is unknown. When data represents a single logical collection, or when explicit framing within the CBOR structure itself is desired, CBOR arrays remain the more suitable option.</p>
<p>Looking ahead, understanding CBOR Sequences provides context for related concepts:</p>
<ul>
<li><strong>CDDL (Concise Data Definition Language):</strong> While CDDL (<a href="https://datatracker.ietf.org/doc/html/rfc8610">RFC-8610</a>) is primarily used to define the structure of single CBOR data items, conventions exist to describe the expected content of items within a sequence. This often involves defining an array structure in CDDL and adding explanatory text stating that the elements represent the items in a sequence, or using the <code>.cborseq</code> control operator for sequences embedded within byte strings.6</li>
<li><strong>Deterministic Encoding:</strong> Rules for deterministic encoding, such as Core Deterministic Encoding defined in (<a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC-8949</a>), apply to <em>each individual CBOR item</em> within a sequence if a canonical byte representation is required for those items.41 The sequence structure (concatenation) is itself inherently deterministic.</li>
</ul>
<p>By understanding the mechanics, motivations, and practical considerations of CBOR Sequences, engineers can effectively leverage this format for efficient data streaming and serialization in appropriate contexts.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part_1/indefinite_length_items.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part_1/cbor_schemas_with_cddl.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part_1/indefinite_length_items.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part_1/cbor_schemas_with_cddl.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
